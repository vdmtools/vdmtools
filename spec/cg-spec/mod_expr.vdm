%--------------------------------------------------------------------------------
% WHAT
%   Provides functions generating code corresponding to vdm expressions
% $Id: mod_expr.vdm,v 1.129 2005/03/11 03:09:29 vdmtools Exp $
% Implemented in: ???
%--------------------------------------------------------------------------------

\section{Module CGEXPR - Code Generating Expressions}

 The module provides a function generating code corresponding to vdm
expressions.

\vspace{1cm}

\begin{vdm_al}
module CGEXPR

imports
  from FD all,
  from CPP all,
  from AS all,
  from DS all,
  from BC all,
  from PM all,
  from CGMAIN all,
  from CGSTMT all,
  from CGAUX all,
  from ENV all,
  from TYPE all,
  from REP all,
  from CI all,
  from VD all,
  from TPGEN all,
  from CONC all,
  from STMT all

exports all

definitions

operations

\end{vdm_al}

The operations $CGExpr$ generates code corresponding to evaluation
of an expression. The operation takes two input parameters:

\begin{description}

\item{expr: } The VDM expression to be code generated.

\item{resVar-v: } A pair of the name of the C++ variable in which the
  result of the evaluation of the expression is to be stored and its
  type. It is assumed that the variable has been declared previously
  in the code generation.

\end{description}

The only purpose of this operation is to check the result type of the
operation $CGExpr'$. If the result type is a C++ statement, nothing is
done, otherwise (a C++ expression) the result is assigned to resVar-v.

\begin{vdm_al}

CGExpr: AS`Expr * CGMAIN`VT ==> seq of CPP`Stmt
CGExpr(expr, mk_CGMAIN`VT(res_v,type)) ==
  def pp_v = CGExpr'(expr, mk_CGMAIN`VT(res_v,type))
  in
    if CGAUX`IsSeqOfCPPStmt( pp_v )
    then return pp_v
    else if CPP`isCPP()
         then return [BC`GenAsgnStmt( res_v, pp_v )]
         else
           def tp = CGAUX`RemoveNil(TPGEN`RemoveInvType(CGAUX`FindType(expr)));
           in
            (dcl cast : CPP`Expr := pp_v;
             if CGAUX`IsStringType(type) and
                         is_CPP`ClassInstanceCreationExpr(pp_v) and
                         pp_v.classtype = DS`GenStringType().tp
             then
               if pp_v.arg <> []
               then cast := hd pp_v.arg
               else cast := BC`GenStringLit("")
               elseif CGAUX`IsSubType(tp, type)
               then skip
               else cast := DS`GenExplicitCast(type, pp_v, tp);
             return  [BC`GenAsgnStmt( res_v, cast )]);
\end{vdm_al}


The operation $CGExpr'$ generates code corresponding to evaluation
of an expression. The operation takes two input parameters:

\begin{description}

\item{expr: } The VDM expression to be code generated.

\item{resVar-v: } A pair of the name of the C++ variable in which the
  result of the evaluation of the expression is to be stored and its
  type. It is assumed that the variable has been declared previously
  in the code generation. This is only used if the operation returns
  as a statement, otherwise resVar-v is not used.

\end{description}

$CGExpr'$ returns either as statement or expression, and it is the
callers responsibility to take care of this situation. If this choice
is not needed, the operation $CGExpr$ can be called instead.

\begin{vdm_al}

CGExpr': AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGExpr'(expr, resVar_v) ==
cases true:
 (is_AS`CasesExpr(expr))                -> CGCasesExpr(expr, resVar_v),
 (is_AS`BoolLit(expr)),
 (is_AS`CharLit(expr)),
 (is_AS`TextLit(expr)),
 (is_AS`QuoteLit(expr)),
 (is_AS`RealLit(expr)),
 (is_AS`NumLit(expr)),
 (is_AS`NilLit(expr))                   -> CGLiteral(expr, resVar_v),
#ifdef VDMSL
 (is_AS`Name(expr))                     ->
     def tp = ENV`LookUpStateEnv(expr)
     in
       if is_REP`CompositeTypeRep(tp) and tp.nm = expr
       then
         def exprs = [ tp.fields(i).sel | i in set inds tp.fields ];
             cid = CI`PushCGType(TPGEN`RemoveInvType(CGAUX`FindType(expr)));
             rce = mk_AS`RecordConstructorExpr(tp.nm, exprs, cid)
         in CGRecordConstructorExpr(rce, resVar_v)
       else
         CGName(expr),      
#endif VDMSL
#ifdef VDMPP
 (is_AS`Name(expr))                     -> CGName(expr),
#endif VDMPP
 (is_AS`BinaryExpr(expr))               -> CGBinaryExpr(expr, resVar_v),
 (is_AS`SetEnumerationExpr(expr))       -> CGSetEnumerationExpr(expr, resVar_v),
 (is_AS`SeqEnumerationExpr(expr))       -> CGSeqEnumerationExpr(expr, resVar_v),
 (is_AS`MapEnumerationExpr(expr))       -> CGMapEnumerationExpr(expr, resVar_v),
 (is_AS`SetComprehensionExpr(expr))     -> CGSetComprehensionExpr(expr, resVar_v),
 (is_AS`MapComprehensionExpr(expr))     -> CGMapComprehensionExpr(expr, resVar_v),
 (is_AS`SeqComprehensionExpr(expr))     -> CGSeqComprehensionExpr(expr, resVar_v),
 (is_AS`SetRangeExpr(expr))             -> CGSetRangeExpr(expr, resVar_v),
 (is_AS`SubSequenceExpr(expr))          -> CGSubSeqExpr(expr, resVar_v),
 (is_AS`TupleConstructorExpr(expr))     -> CGTupleConstructorExpr(expr, resVar_v),
 (is_AS`ApplyExpr(expr))                -> CGApplyExpr(expr, resVar_v, nil, nil, false),
 (is_AS`RecordConstructorExpr(expr))    -> CGRecordConstructorExpr(expr, resVar_v),
 (is_AS`LetExpr(expr))                  -> CGLetExpr(expr, resVar_v),
 (is_AS`LetBeSTExpr(expr))              -> CGLetBeSTExpr(expr, resVar_v),
 (is_AS`DefExpr(expr))                  -> CGDefExpr(expr, resVar_v),
 (is_AS`IfExpr(expr))                   -> CGIfExpr(expr, resVar_v),
 (is_AS`BracketedExpr(expr))            -> CGBracketedExpr(expr, resVar_v),
 (is_AS`SeqModifyMapOverrideExpr(expr)) -> CGSeqModifyMapOverrideExpr(expr, resVar_v),
 (is_AS`FieldSelectExpr(expr))          -> CGFieldSelectExpr(expr, resVar_v, nil, nil),
 (is_AS`AllOrExistsExpr(expr)),
 (is_AS`ExistsUniqueExpr(expr))         -> CGAllOrExistsExpr(expr, resVar_v),
 (is_AS`IotaExpr(expr))                 -> CGIotaExpr(expr, resVar_v),
 (is_AS`IsExpr(expr))                   -> CGIsExpr(expr, resVar_v),
 (is_AS`PrefixExpr(expr))               -> CGPrefixExpr(expr, resVar_v),
 (is_AS`RecordModifierExpr(expr))       -> CGRecordModifierExpr(expr, resVar_v),
 (is_AS`UndefinedExpr(expr))            -> CGUndefinedExpr(),
 (is_AS`OldName(expr))                  -> CGOldName(expr),
 (is_AS`TokenConstructorExpr(expr))     -> CGTokenConstExpr(expr, resVar_v),
 (is_AS`FctTypeInstExpr(expr))          -> (CGAUX`SetNotSupportedException(true);
                                            return [CGAUX`NotSupported("function type instantiation expression")]),
 (is_AS`LambdaExpr(expr))               -> (CGAUX`SetNotSupportedException(true);
                                            return [CGAUX`NotSupported("lambda expression")]),
 (is_AS`TypeJudgementExpr(expr))        -> CGTypeJudgementExpr(expr, resVar_v),
 (is_AS`PreConditionApplyExpr(expr))    -> (CGAUX`SetNotSupportedException(true);
                                            return [CGAUX`NotSupported("precondition expression")]),
 (is_AS`TupleSelectExpr(expr))          -> CGTupleSelectExpr(expr, resVar_v),
 (is_AS`NarrowExpr(expr))               -> CGNarrowExpr(expr, resVar_v),
 (is_AS`Macro(expr))                    -> CGMacro(expr, resVar_v),
#ifdef VICE
 (is_AS`CurTimeExpr (expr))             ->  return [CGAUX`NotSupported("time expression")],
#endif VICE
#ifdef VDMPP
 (is_AS`NewExpr (expr))                 -> CGNewExpr (expr,resVar_v),
 (is_AS`SelfExpr(expr))                 -> GenSelfExpr(resVar_v),

 (is_AS`IsOfClassExpr(expr))            -> CGIsOfClassExpr(expr, resVar_v),
 (is_AS`IsOfBaseClassExpr(expr))        -> CGIsOfBaseClassExpr(expr, resVar_v),
 (is_AS`SameClassExpr(expr))            -> CGSameClassExpr(expr, resVar_v),
 (is_AS`SameBaseClassExpr(expr))        -> CGSameBaseClassExpr(expr, resVar_v),

-- Guard expr only exists for Java

 (is_AS`GuardExpr(expr))                -> let mk_AS`GuardExpr(innerExpr, origin) = expr
                                           in (CONC`SetDefaultCast(origin);
                                               return CGExpr'(innerExpr, resVar_v)),

 (is_AS`ActExpr(expr)),
 (is_AS`FinExpr(expr)),
 (is_AS`ActiveExpr(expr)),
 (is_AS`WaitingExpr(expr)),
 (is_AS`ReqExpr(expr)) ->
     if CPP`isJAVA() then
     return CONC`GenGuardExpr( expr )
     else cases true:
       (is_AS`ActExpr(expr)) -> return [CGAUX`NotSupported("act. expression")],
       (is_AS`FinExpr(expr)) -> return [CGAUX`NotSupported("fin. expression")],
       (is_AS`ActiveExpr(expr)) -> return [CGAUX`NotSupported("active. expression")],
       (is_AS`WaitingExpr(expr)) -> return [CGAUX`NotSupported("waiting expression")],
       (is_AS`ReqExpr(expr)) -> return [CGAUX`NotSupported("req. expression")],
       others -> error
     end,
  (is_AS`ThreadIdExpr(expr)) ->
     if CPP`isJAVA() and CGMAIN`get_conc_option() then return CONC`GenThreadId()
     else return [CGAUX`NotSupported("threadId expression")],

#endif
  others          -> error
end;
\end{vdm_al}



The operation {\em CGExprExcl} is an auxiliary operation that
generates code corresponding for expressions. The operation takes:


\begin{itemize}
\item an expression and,
\item possible a sequence of char, which is the name of the temporary
variable that the result is assigned to, or a CPP`Name.  If the {\em
e\_name} is of type {\em CPP`Name} the {\em e\_name} is the temporary
variable and it should not be declared.
\end{itemize}

The operation returns:

\begin{itemize}
\item a {\em CPP`Expr} which holds the result of the expression (is
either a temporary variable or an expression).
\item a sequence of {\em CPP`Stmt}. In case the expression can be
computed as an expresion this sequence is empty.
\end{itemize}

\begin{vdm_al}
CGExprExcl: AS`Expr * ([seq of char] | CPP`Name) * [REP`TypeRep] ==> CPP`Expr * seq of CPP`Stmt
CGExprExcl( expr, e_name, etp ) ==
 (dcl e_t : [REP`TypeRep] := etp,
      etmpVar : [seq of char] | CPP`Name := e_name;
  if e_name = nil
  then etmpVar := BC`GiveName("e")
  elseif is_CPP`Identifier(e_name)
  then skip
  else etmpVar := BC`GiveName(e_name);
  if etp = nil
  then e_t := CGAUX`FindType(expr);
  def exl_v : seq of CPP`Stmt | CPP`Expr = CGExpr'(expr, mk_CGMAIN`VT(etmpVar, e_t))
  in
    if CGAUX`IsSeqOfCPPStmt(exl_v)
    then
      if is_CPP`Identifier(e_name)
      then return mk_(etmpVar, exl_v)
      else
        def tp = TPGEN`RemoveInvType(e_t);
            decl_stmt = DS`GenDecl(tp, etmpVar, nil); -- must be here for include 
            stmt = exl_v(len exl_v)
        in
          cases stmt:
            mk_CPP`ExpressionStmt(mk_CPP`AssignExpr((etmpVar),
                                  mk_CPP`AssignOp(<ASEQUAL>,-),assignexpr,-),-)
                  -> (dcl retex : CPP`Expr;
                      if CGAUX`IsSubType(CGAUX`FindType(expr), tp)
                      then
                        cases true:
                          (is_CPP`Identifier(assignexpr)),
                          (is_CPP`ClassInstanceCreationExpr(assignexpr)),
                          (is_CPP`FctCall(assignexpr)),
                          (is_CPP`BracketedExpr(assignexpr)) -> retex := assignexpr,
                          (is_CPP`CastExpr(assignexpr))      -> if CPP`isCPP()
                                                                then retex := assignexpr
                                                                else retex := BC`GenBracketedExpr(assignexpr),
                          others                             -> retex := BC`GenBracketedExpr(assignexpr)
                        end
                      else
                        if CPP`isCPP()
                        then retex := BC`GenCastExpr(DS`GenType(tp), assignexpr)
                        else retex := DS`GenExplicitCast(tp, assignexpr, nil);
                      return mk_(retex, exl_v(1, ..., len exl_v - 1))),
            others -> cases hd exl_v:
                        mk_CPP`ExpressionStmt(mk_CPP`AssignExpr((etmpVar),
                                              mk_CPP`AssignOp(<ASEQUAL>,-),assignexpr,-),-)
                          -> return mk_(etmpVar,
                                        DS`GenDeclInit(tp, etmpVar, assignexpr) ^ tl exl_v),
                        others -> return mk_(etmpVar, decl_stmt ^ exl_v)
                      end
          end
    else -- not CGAUX`IsSeqOfCPPStmt(exl_v)
      if CPP`isCPP()
      then return mk_(exl_v, [])
      else
        def gtp = CGAUX`RemoveNil(CGAUX`FindType(expr));
            tp = if etp = nil
                 then gtp
                 else etp
        in 
          if CGAUX`IsSubType(gtp, tp)
          then if (CGAUX`IsIntType(tp) and not CGAUX`IsIntType(gtp)) or
                  (not CGAUX`IsIntType(tp) and CGAUX`IsIntType(gtp))
               then return mk_(DS`GenExplicitCast(tp, exl_v, nil), [])
               else return mk_(exl_v, [])
          elseif ((is_REP`EmptySeqTypeRep(gtp) and CGAUX`IsSeqType(tp)) or
                  (is_REP`EmptySetTypeRep(gtp) and CGAUX`IsSetType(tp)) or
                  (is_REP`EmptyMapTypeRep(gtp) and CGAUX`IsMapType(tp))) and
                 is_CPP`ClassInstanceCreationExpr(exl_v)
          then return mk_(exl_v, [])
          elseif CGAUX`IsProductType(tp) and CGAUX`IsProductType(gtp)
          then return mk_(exl_v, [])
          else return mk_(DS`GenExplicitCast(tp, exl_v, nil), []);
 );

MergeStmts: seq of CPP`Stmt * seq of CPP`Stmt ==> seq of CPP`Stmt
MergeStmts(decls,pm) ==
  let id_m = { decls(i).decl.dl(1).decl |-> decls(i) | i in set inds decls &
                  cases decls(i):
                    mk_CPP`DeclarationStmt(
                      mk_CPP`IdentDeclaration(
                        -,[mk_CPP`InitDeclarator(mk_CPP`Identifier(-,-),-,-)],-,-),-) -> true,
                    others -> false
                  end }
  in
   (dcl new_decls : seq of CPP`Stmt := decls,
        stmts : seq of CPP`Stmt := pm;
    for index = 1 to len pm do
      cases pm(index):
        mk_CPP`ExpressionStmt(mk_CPP`AssignExpr(unary,
                              mk_CPP`AssignOp(<ASEQUAL>,-),assignexpr,-),-)
          -> if unary in set dom id_m
             then
              (dcl initExpr : CPP`Initializer;
               if CPP`isCPP()
               --then initExpr := BC`GenObjectInit([assignexpr])
               then
                 cases assignexpr:
                   mk_CPP`FctCall(mk_CPP`Identifier(-,-),[],-)
                      -> cases assignexpr.fct:
                           mk_CPP`Identifier("vdm_" ^ -,-) -> initExpr := BC`GenObjectInit([assignexpr]),
                           others -> initExpr := BC`GenAsgnInit(assignexpr)
                         end,
                   others -> initExpr := BC`GenObjectInit([assignexpr])
                 end
               else initExpr := BC`GenAsgnInit(assignexpr);
               def mk_CPP`DeclarationStmt(mk_CPP`IdentDeclaration(ds,[idec],-,-),-) = id_m(unary);
                   stmt = mu (id_m(unary), decl |->
                            mu (id_m(unary).decl, 
                                       ds |-> [ BC`GenTypeSpecifier(<CONST>) ] ^ ds,
                                       dl |-> [ mu(idec, i |-> initExpr ) ] ))
               in
                (stmts := stmts ++ { index |-> stmt };
                 let idx = iota i in set inds new_decls & new_decls(i) = id_m(unary)
                 in new_decls := new_decls(1,...,idx - 1) ^ new_decls(idx + 1,..., len new_decls)
                )
               ),
        others -> skip
      end;
    return new_decls ^ stmts;
   );
\end{vdm_al}

\subsection{Cases Expression}

Consider the VDM expression below:

\begin{verbatim}
cases e:
   a, {1,a}   -> b1
   [1,b]      -> b2,
   others     -> b3
end
\end{verbatim}

The corresponding pseudo code of the cases expression is listed
below. In the example the variable named $resVar$ is assigned to the
result of the evaluation of the cases expression, and it is assumed
that in an outer block this variable has been declared to the
corresponding type of the cases expression (assume that the type of
the cases expression is a union, in case using the \MCL{} we assume
that the following declaration is done in the an outer block:
{\tt Generic resVar}).



The pseudo code generated by $CGCasesExpr$:

\begin{small}
\begin{verbatim}
Generic tmpE;  // Declaration of a temporary variable to store
               // the result of the evaluation of the expression e.

...CGExpr(e, mk_CGMAIN`VT(tmpE, "Generic");
bool succ = false; // boolean indicating if a pattern match has succeeded.
                  // See also module PM.

//Pattern match of first branch:
{ Generic vdm_var_a;     // Declaration of variables corresponding to
                         // the pattern identifiers appearing in the patterns.

  ...CGPatternMatch( "a", tmpE, {}, succ);
                         // Code corresponding to the pattern match
                         // of the expression "e" against the pattern "a":

  if ( ! succ )
    ...CGPatternMatch( "{1,a}", mk_CGMAIN`VT( tmpE, "Generic"), {}, succ )
  if ( succ )   // If either pattern match succeeded with the expression "e"
                // against either "a" or "{1,a}".
   {
     ...CGExpr( b1, mk_CGMAIN`VT( resVar, "Generic") );
                               // Notice, that since the declaration of the variable
                               // a is done in an outer block the scope of "a" also
                               // apply in this block.
   }
}
if ( ! succ )           // No pattern match succeeded in the first guard.
 { Generic vdm_var_b;   // Declaration of variables corresponding to the
                        // pattern identifiers appearing in the patterns.
   ...CGPatternMatch( "[1,b]", mk_CGMAIN`VT( tmpE, "Generic" ), {}, succ )
   if ( succ )
    {
      ...CGExpr(b2, resVar );
    }
 }
if (!succ ) // No pattern match succeeded
 {
   ...CGExpr(e, resVar);
 }
\end{verbatim}
\end{small}

This example does not cover any complexity in sense of

\begin{enumerate}

\item identifiers which are to be bound to the same value:

\begin{verbatim}
cases e:
  {a, { a }, 1} -> b1,
  others  -> b2
end;
\end{verbatim}

\item branches which consists of alternative patterns which do not
share a common set of pattern identifiers:
\begin{verbatim}
cases e:
  {1,a}, {2, b} -> b1,
  others        -> b2
end
\end{verbatim}
\end{enumerate}

The problem on how to deal with the case expression in item number 1 is
solved in the pattern match which statically detects if it is
necessary to generate code checking that identically pattern
identifiers are bound to equal values.

The second problem on how to deal with the case expression in item number 2
is solved by generating code as if the cases expression was written:
\begin{verbatim}
cases e:
  {1,a}  -> b1,
  {2,b}  -> b1,
  others -> b2
end
\end{verbatim}

The main operation $CGCasesExpr$ describing the code generation of
a cases expression is listed below.  It takes two input parameters:

\begin{description}

\item{mk-CasesExpr(sel, altns, Others, type):} The abstract syntax of
the the cases expression.

\item{resVar-v:} Is the temporary variable in which the result of the
evaluation of the expression should be stored.

\end{description}

\begin{vdm_al}

CGCasesExpr: AS`CasesExpr * CGMAIN`VT ==> seq  of CPP`Stmt
CGCasesExpr(mk_AS`CasesExpr(sel, altns, Others,-), mk_CGMAIN`VT(resVar_v,type)) ==
  def succ_v = BC`GiveName( "succ" );
      mk_(selRes1_v, selRes_stmt) = CGExprExcl(sel, "selRes", nil) ;
      all_pat_ids = FindAllPatIdInCasesAlt(altns);
      all_nm_in_expr = CGAUX`FindAllNamesInExpr(sel);
      pat_in_expr = all_nm_in_expr inter all_pat_ids <> {};
      sel_v = BC`GiveName("selRes");
      sel_type = CGAUX`FindType(sel);
      need_decl = pat_in_expr and selRes_stmt = [] or
#ifdef VDMPP
                 exists n in set all_nm_in_expr & is_REP`ObjRefTypeRep(CGAUX`FindType(n)) or
#endif VDMPP
                 cases true:
                   (is_AS`TupleConstructorExpr(sel)),
                   (is_AS`RecordConstructorExpr(sel)),
                   (is_AS`SetEnumerationExpr(sel)),
                   (is_AS`SeqEnumerationExpr(sel))    -> true,
                   others                             -> false
                 end;
      selRes_v = if need_decl
                 then sel_v
                 else selRes1_v
  in
   (dcl rb : seq of CPP`Stmt := selRes_stmt;
    if need_decl
    then rb := rb ^ DS`GenConstDeclInit(sel_type, sel_v, selRes1_v);
    rb := rb ^ [ BC`GenDecl( DS`GenSmallBoolType(), succ_v, BC`GenAsgnInit(BC`GenBoolLit(false))) ];
    rb := rb ^ CGCasesExprAltn( altns, mk_CGMAIN`VT(selRes_v, sel_type), mk_CGMAIN`VT(resVar_v, type), succ_v ) ;
    if Others <> nil
    then
       def alt1 = BC`GenBlock( CGExpr(Others, mk_CGMAIN`VT( resVar_v, type) ))
       in
         rb := rb ^ [ BC`GenIfStmt( BC`GenNot( succ_v ), alt1, nil)]
    else
       rb := rb ^ [ BC`GenIfStmt( BC`GenNot(succ_v ),
               BC`GenBlock([CGAUX`RunTime("No 'others' branch in 'cases' expr" )]), nil ) ];
    return rb);
\end{vdm_al}

The operation {\em FindAllPatIdInCasesAlt} finds all pattern names in
the cases alternative.

\begin{vdm_al}
FindAllPatIdInCasesAlt: seq of (AS`CaseAltn | AS`CasesStmtAltn) ==> set of AS`Name
FindAllPatIdInCasesAlt( altns ) ==
 (dcl res : set of AS`Name := {};
  for altn in altns do
    cases altn:
      mk_AS`CaseAltn(p_l, -, -),
      mk_AS`CasesStmtAltn(p_l,-,-) -> for p in p_l do
                                        res := res union dom FindPatternId(p)
    end;
  return res);
\end{vdm_al}

The next operation $CGCasesExprAltn$ is an auxiliary operation of
$CGCasesExpr$. It generates code corresponding to all the alternative
branches in a cases expression. The four input parameters are
described below:

\begin{description}

\item{altns:} The alternative branches in a cases expression.

\item{selRes-v:} This parameter is of type $CG`VT$, it is a record
with two fields. The first field is contains the C++ variable name of
the variable in which the evaluation of the selector expression in the
cases expression is store. The second field contains the type of the
selector expression.

\item{resVar-v:} Is a pair of the temporary variable in which the
result of the evaluation of the cases expression should be stored and
its type.

\item{succ-v:} Is a temporary variable which is assigned to true if
one of the pattern match in the branches succeeds and otherwise to
false.

\end{description}



\begin{vdm_al}
CGCasesExprAltn: seq1 of AS`CaseAltn * CGMAIN`VT * CGMAIN`VT * CPP`Name ==> seq of CPP`Stmt
CGCasesExprAltn( altns, selRes_v, resVar_v, succ_v ) ==
( dcl rb : seq of CPP`Stmt;
  rb := [ CGAltn( hd altns, selRes_v, resVar_v, succ_v ) ];
  for i = 2 to len altns do
    rb := rb ^ [ BC`GenIfStmt( BC`GenNot( succ_v ),
                               CGAltn( altns( i ), selRes_v, resVar_v, succ_v ),
                               nil ) ];
  return rb
);
\end{vdm_al}

The operation $CGAltn$ is an auxiliary function to
$CGCasesExprAltn$. It generates code corresponding to one branch in
the cases expression. The operation takes four input parameters:

\begin{description}

\item{mk-AS`CaseAltn( p-l, e):} Is the abstract syntax of the branch
in the cases expression.

\item{selRes-v:} This parameter is of type $CG`VT$, it is a record
of with two fields. The first field is contains the C++ variable name
of the variable in which the evaluation of the selector expression in
the cases expression is store. The second field contains the type of
the selector expression.

\item{resVar-v:} Is a pair of the temporary variable in which the
result of the evaluation of the cases expression should be stored and
its type.

\item{succ-v:} Is a temporary variable which is assigned to true if
one of the pattern match in the branches succeeds and otherwise to
false.

\end{description}

Remember the example where the alternative patterns do not share a
common set of pattern identifiers:

\begin{verbatim}
cases e:
  {1,a}, {2, b} -> b1,
  others        -> b2
end
\end{verbatim}

As it was described previously we have chosen to solve this problem by
generating code as if the cases expression was written:

\begin{verbatim}
cases e:
  {1,a}  -> b1,
  {2,b}  -> b1,
  others -> b2
end
\end{verbatim}

It is the operation $CGAltn$ in which it is investigated if the
alternative patterns in the branch do not share a common set of
pattern identifiers, this is, as it appears in the specification, done
by calling the operation $SamePatternIds$. This operation returns a
tuple, which --- in this case --- is bound to the identifiers
$samepatternIds$ and $pid-m$. The identifier $samepatternIds$ is
assigned to true if the alternative patterns share a common set of
identifiers and false otherwise. The identifier $pid-m$ is --- if the
alternative patterns share common set of identifiers - assigned to a
map from the identifiers in the pattern alternatives to a set of types
which they could be bound to.

\begin{vdm_al}
CGAltn: AS`CaseAltn * CGMAIN`VT * CGMAIN`VT * CPP`Name ==> CPP`Stmt
CGAltn(mk_AS`CaseAltn(p_l, e, cid), selRes_v, resVar_v, succ_v) ==
 (dcl rb : seq of CPP`Stmt := [];
  FD`PushEnv();
  CGAUX`PushEnv();
  def mk_(samepatternIds, pid_m) = SamePatternIds( p_l )
  in
    if samepatternIds
    then
      -- each pattern in the pattern list contains the same set of PatternId.
      def decl = DeclarePatterns( pid_m );
      in
       (if len p_l > 1
        then rb := rb ^ decl;
        for i = 1 to len p_l do
          def mk_(pm, Is_Excl) = PM`CGPatternMatchExcl(p_l(i), selRes_v, {}, succ_v, nil, nil, false);
              pm1 = (if Is_Excl
                     then [BC`GenAsgnStmt( succ_v, BC`GenBoolLit(true))]
                     else []) ^ pm
          in
            if i = 1 
            then
              if len p_l > 1
              then rb := rb ^ pm1
              else rb := rb ^ CGEXPR`MergeStmts( decl, pm1 )
            else rb := rb ^ [BC`GenIfStmt( BC`GenNot( succ_v ), BC`GenBlock(pm1), nil )];
        def stmts : seq of CPP`Stmt = CGExpr(e, resVar_v)
        in
          rb := rb ^ [ BC`GenIfStmt( succ_v, BC`GenBlock(stmts), nil) ]
       )
    else
     (dcl ca_l: seq of AS`CaseAltn := [];
      for i =1 to len p_l do
        ca_l := ca_l ^ [ mk_AS`CaseAltn([p_l(i)], e, cid) ];
      rb := rb ^ CGCasesExprAltn( ca_l, selRes_v, resVar_v, succ_v )
     );
  CGAUX`PopEnv();
  FD`PopEnv();
  return BC`GenBlock(rb)
 );
\end{vdm_al}

The next operation is an auxiliary function to the operation
$CGAltn$. It investigates if each pattern in the sequence of pattern
($p-l$) contains exactly the same set of pattern name, if this is the
case it returns a tuple containing the value {\sf true} and the map of
identifier names to a set of types which the identifier can be bound to.

\begin{vdm_al}
SamePatternIds: seq of AS`Pattern ==> bool * map (AS`Name | AS`OldName) to set of REP`TypeRep
SamePatternIds( p_l ) ==
  if p_l <> []
  then
   (dcl same_pid : bool := true,
        pid_m : map (AS`Name | AS`OldName) to set of REP`TypeRep := FindPatternId( hd p_l );
    for i = 2 to len p_l do
      def tmp_m = FindPatternId( p_l( i) )
      in
       (same_pid := same_pid and forall n in set dom tmp_m & n in set dom pid_m;
        if same_pid
        then pid_m := MergePidM(tmp_m, pid_m)
        else pid_m := pid_m ++ tmp_m );
    return mk_( same_pid, pid_m );
   )
  else return mk_( false, {|->} );
\end{vdm_al}

The operation $FindPatternId$ is an auxiliary operation to
$SamePatternIds$. It takes a pattern and returns a map from the name of
a pattern to a set of types, which the pattern possible could be of.

\begin{vdm_al}
FindPatternId: AS`Pattern ==> map (AS`Name | AS`OldName) to set of REP`TypeRep
FindPatternId( pat ) ==
  cases pat:
    mk_AS`MatchVal(-,-),
    mk_AS`PatternName(nil, -, -)    -> return {|->},
    mk_AS`PatternName(name, -, -)   -> def tp = CGAUX`FindType(pat)
                                       in return { name |-> { if tp <> nil then tp else mk_REP`AllTypeRep() } },
#ifdef VDMPP
    mk_AS`FieldPattern(-,p,-)       -> return FindPatternId(p),
    mk_AS`ObjectPattern(-,pat_l, -),
#endif VDMPP
    mk_AS`SetEnumPattern(pat_l, -),
    mk_AS`SeqEnumPattern(pat_l,-),
    mk_AS`TuplePattern(pat_l, -),
    mk_AS`MapEnumPattern(pat_l,-),
    mk_AS`RecordPattern(-,pat_l,-)  -> (dcl pid_m : map (AS`Name | AS`OldName) to set of REP`TypeRep := {|->};
                                        for tmp in pat_l do
                                          pid_m := MergePidM(FindPatternId( tmp ), pid_m);
                                        return pid_m),
    mk_AS`SeqConcPattern(lp, rp,-),
    mk_AS`SetUnionPattern(lp, rp,-),
    mk_AS`MapMergePattern(lp, rp,-) -> return FindPatternId(lp) ++ FindPatternId(rp),
    mk_AS`MapletPattern(dp,rp,-)    -> return FindPatternId(dp) ++ FindPatternId(rp),
    others -> error
  end;

MergePidM: map (AS`Name | AS`OldName) to set of REP`TypeRep * 
           map (AS`Name | AS`OldName) to set of REP`TypeRep
           ==> map (AS`Name | AS`OldName) to set of REP`TypeRep
MergePidM(pid_m1, pid_m2) ==
 return { id |-> (if id in set dom pid_m1 then pid_m1(id) else {})
                  union
                 (if id in set dom pid_m2 then pid_m2(id) else {})
             | id in set dom pid_m1 union dom pid_m2 };
\end{vdm_al}

The operation $DeclarePatterns$ is an auxiliary operation to $CGAltn$,
$CGSeqComprehensionExpr$ and $DeclarePatVars$. It generates code
corresponding to the declaration of temporary variable corresponding
to the pattern names in the set $pid-s$.

\begin{vdm_al}
DeclarePatterns: map (AS`Name | AS`OldName) to set of REP`TypeRep ==> seq of CPP`Stmt
DeclarePatterns( pid_m ) ==
 (dcl rb : seq of CPP`Stmt := [];
  for all tmp in set dom pid_m do
    let tp_s = pid_m(tmp), -- set of REP`TypeRep
        type = cases tp_s:
                 {tp} -> tp,
                 others -> mk_REP`UnionTypeRep(tp_s)
               end
    in
     (def - = CGAUX`InsertName(tmp)
      in rb := rb ^ DS`GenDecl(type, BC`Rename(tmp), nil);
      if CGAUX`PossibleFnType(type)
      then FD`InsertLocFct(tmp);
     );
  return rb;
 );
\end{vdm_al}

\subsection{Set Enumeration Expression}

In this section the specification of set enumeration is described.
The operation main operation is called $CGSetEnumerationExpr$.

Consider the set enumeration expression below:

\begin{verbatim}

  { 1, 1 + 2, cases 3:
                a -> true,
                {3} -> false
              end }

\end{verbatim}

The corresponding pseudo code of this VDM expression is listed below,
assuming that the temporary variables in which the evaluation of the
expression is to be stored is named $resVar\_v$.
\begin{verbatim}
Set res_s;
{
  Int tmpVar;
  ... CGExpr( "1", mk_CGMAIN`VT( tmpVar, "nat");
  res_s.Insert(tmpVar);
}
{ Int tmpVar;
  ... CGExpr( "1+2", mk_CGMAIN`VT(tmpVar, "nat" );
  res_s.Insert(tmpVar);
}
{ Int tmpVar;
  ... CGExpr( "cases 3: a -> true, {3} -> false end", mk_CGMAIN`VT( tmpVar, "bool") )
  res_s.Insert(tmpVar);
}
resVar_v = res_s;
\end{verbatim}

\begin{vdm_al}
CGSetEnumerationExpr: AS`SetEnumerationExpr * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGSetEnumerationExpr(mk_AS`SetEnumerationExpr(expr, -), mk_CGMAIN`VT(resVar_v, rType)) ==
  if expr = []
  then return DS`GenEmptySetExpr()
  else
    def casting = not CGAUX`IsSetType( rType );
    in
     (dcl resVar_v' : CPP`Expr := resVar_v,
          rb : seq of CPP`Stmt := [],
          allsimple : bool := true,
          args : seq of CPP`Expr := [],
          etp : [REP`TypeRep] := nil;

      if casting
      then
       (resVar_v' := DS`GenCastSetTypeForModify(resVar_v);
        rb := [BC`GenAsgnStmt(resVar_v, DS`GenEmptySetExpr())]);
      
      if CPP`isJAVA()
      then etp := CGAUX`FindSetElemType(rType);

      for e in expr do
        --def mk_(e_v, e_stmt) = CGExprExcl(e, "enum_set", nil)
        def mk_(e_v, e_stmt) = CGExprExcl(e, "enum_set", etp)
        in
          (rb := rb ^ e_stmt ^ [DS`GenSetInsert( resVar_v', e_v )];
           if e_stmt <> [] or is_AS`ApplyExpr(e)
           then allsimple := false;
           args := args ^ [e_v]);

      cases rb:
        [] -> return DS`GenEmptySetExpr(),
        others -> if CPP`isCPP() and allsimple and len args <= 8
                  then return BC`GenFctCall( BC`GenIdentifier("mk_set"), args )
                  else return rb
      end;
     );
\end{vdm_al}

\subsection{Sequence Enumeration}
In this section the code generation of sequence enumeration is described.

Consider the following VDM expression of a sequence enumeration:

\begin{verbatim}
  [ 1, 1+2, cases 3:
                a -> true,
                {3} -> false
              end  ]
\end{verbatim}

The corresponding pseudo code listed below:


\begin{verbatim}
Sequence res_l;
{
  Int tmpVar;
  ... CGExpr( "1", mk_CGMAIN`VT( tmpVar, "nat");
  res_l.ImpAppend(tmpVar);
}
{ Int tmpVar;
  ... CGExpr( "1+2", mk_CGMAIN`VT(tmpVar, "nat" );
  res_s.ImpAppend(tmpVar);
}
{ Int tmpVar;
  ... CGExpr( "cases 3: a -> true, {3} -> false end", mk_CGMAIN`VT( tmpVar, "bool") )
  res_s.ImpAppend(tmpVar);
}
resVar_v = res_l;
\end{verbatim}

The overall structure of the pseudo code is similar to the pseudo code
corresponding to the set enumeration.

\begin{vdm_al}
CGSeqEnumerationExpr: AS`SeqEnumerationExpr * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGSeqEnumerationExpr( mk_AS`SeqEnumerationExpr(expr, -), mk_CGMAIN`VT( resVar_v, rType) ) ==
  if CPP`isCPP()
  then
    if expr = []
    then return DS`GenEmptySeqExpr()
    else
    def casting = not CGAUX`IsSeqType( rType );
        isstringexpr = CGAUX`IsSeqType( rType ) and 
                       CGAUX`IsCharType(CGAUX`FindSeqElemType(rType)) and
                       forall e in set elems expr & is_AS`CharLit(e);
    in
      if isstringexpr
      then
        return BC`GenFctCall(DS`GenSeq0Type().tp, [BC`GenStringLit([ expr(i).val | i in set inds expr ])])
      else
       (dcl resVar_v' : CPP`Expr := resVar_v,
            rb : seq of CPP`Stmt := [],
            allsimple : bool := true,
            args : seq of CPP`Expr := [],
            etp : [REP`TypeRep] := nil;

        if casting
        then
         (resVar_v' := DS`GenCastSeqTypeForModify(resVar_v);
          rb := [BC`GenAsgnStmt(resVar_v, DS`GenEmptySeqExpr())]);

        if CPP`isJAVA()
        then etp := CGAUX`FindSeqElemType(rType);

        for i = 1 to len expr do
          def e = expr(i);
              --mk_(tmpExpr, st_l) = CGExprExcl(e, "e_seq", nil)
              mk_(tmpExpr, st_l) = CGExprExcl(e, "e_seq", etp)
          in
           (rb := rb ^ st_l ^ [DS`GenImpAppend( resVar_v', tmpExpr )];
            if st_l <> [] or is_AS`ApplyExpr(e)
            then allsimple := false;
            args := args ^ [tmpExpr]);

        cases rb:
          []     -> return DS`GenEmptySeqExpr (),
          others -> if allsimple and len args <= 8
                    then return BC`GenFctCall( BC`GenIdentifier("mk_sequence"), args )
                    else return rb
        end;
       )
  else
    def isstring = CGAUX`IsStringType(rType);
        possiblestringtype = CGAUX`IsPossibleStringType(rType);
        isstringexpr = forall e in set elems expr & is_AS`CharLit(e);
    in
     (dcl seqCall : CPP`Expr;
      if isstring or (possiblestringtype and isstringexpr)
      then seqCall := DS`GenEmptyStringExpr()
      else seqCall := DS`GenEmptySeqExpr();

      if len expr = 0
      then return seqCall
      elseif isstringexpr
      then
        return BC`GenStringLit([ expr(i).val | i in set inds expr ])
      elseif isstring or (possiblestringtype and isstringexpr)
      then
        def tmpSeq = BC`GiveName("tmpSeq")
        in
         (dcl rb : seq of CPP`Stmt := [];
          rb := rb ^ [BC`GenDecl(DS`GenStringType(), tmpSeq, BC`GenAsgnInit(seqCall))];
          for e in expr do
            def mk_(tmpExpr, st_l) = CGExprExcl(e, "e_seq", nil);
                insert = BC`GenAsgnStmt(tmpSeq, BC`GenPlus( tmpSeq, tmpExpr ))
            in rb := rb ^ st_l ^ [insert];
          rb := rb ^ [BC`GenAsgnStmt(resVar_v, tmpSeq)];
          return rb;
         )
      else
        def tmpSeq = BC`GiveName("tmpSeq")
        in
         (dcl rb : seq of CPP`Stmt := [],
              args : seq of CPP`Expr := [],
              allsimple : bool := true,
              hasstring : bool := false;
          rb := rb ^ [BC`GenDecl(DS`GenSeq0Type(), tmpSeq, BC`GenAsgnInit(seqCall))];
          for e in expr do
            def mk_(tmpExpr, st_l) = CGExprExcl(e, "e_seq", nil);
                insert = DS`GenImpAppend( tmpSeq, tmpExpr )
            in
             (rb := rb ^ st_l ^ [insert];
              if st_l <> [] or is_AS`ApplyExpr(e)
              then allsimple := false;
              args := args ^ [tmpExpr];
              def etp = CGAUX`FindType(e)
              in hasstring := CGAUX`IsStringType(etp) or hasstring;
             );
          if allsimple
          then
            def ai = BC`GenArrayInitializer(args);
                etp = CGAUX`FindSeqElemType(rType);
            in
             (dcl ts : CPP`TypeSpecifier;
              if CGAUX`IsSeqType(etp) and not CGAUX`IsStringType(etp) and hasstring
              then ts := BC`GenGeneric()
              else ts := DS`GenType(etp);
              def expr = BC`GenArrayCreationExpr(ts.tp, nil, nil, ai);
                  res = BC`GenFctCall(BC`GenIdentifier("Arrays.asList"), [expr])
              in
               (CGAUX`InsertImport("java.util.Arrays");
                return res);
             );
          rb := rb ^ [BC`GenAsgnStmt(resVar_v, tmpSeq)];
          return rb;
         );
     );
\end{vdm_al}

\subsection{Map Enumeration}

This section describes the code generation of map enumeration expressions.

Consider the VDM map enumeration expression below:
\begin{verbatim}
  { 1 |-> 3, 1 + 2 |-> cases 3:
                         a -> true,
                        {3} -> false
                       end }
\end{verbatim}


The corresponding pseudo code is listed below:

\begin{verbatim}
Map res_m;
{ Int tmpVar1;
  Int tmpVar2;
  ...CGExpr ("1", mk_CGMAIN`VT(tmpVar1, "nat" ) );
  ...CGExpr ("3", mk_CGMAIN`VT(tmpVar2, "nat" ) );
  res_m.Insert(tmpVar1, tmpVar2);
}
{ Int tmpVar1;
  Int tmpVar2;
  ...CGExpr("1+2", mk_CGMAIN`VT(tmpVar1, "nat" ) );
  ...CGExpr("cases 3: a -> true, {3} -> false end", mk_CGMAIN`VT( tmpVar2, "bool" ) )
}
resVar_v = res_m;
\end{verbatim}

Note, that the variable {\tt resVar-v} might be declared as a union
type, that is, using \MCL{} declared as a Generic. This is, one of the
reasons why we need the temporaray variable {\tt res\_m}. Note also
that the library checks for duplicate entries with different values.

\begin{vdm_al}
CGMapEnumerationExpr: AS`MapEnumerationExpr * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGMapEnumerationExpr(mk_AS`MapEnumerationExpr(ml, -), mk_CGMAIN`VT(resVar_v, rType)) ==
  if ml = []
  then return DS`GenEmptyMapExpr()
  else
    def casting = not CGAUX`IsMapType( rType );
    in
     (dcl resVar_v' : CPP`Expr := resVar_v,
          rb : seq of CPP`Stmt := [],
          dtp : [REP`TypeRep] := nil,
          rtp : [REP`TypeRep] := nil,
          allsimple : bool := true, --
          expr : CPP`Expr := DS`GenEmptyMapExpr(); --
         
      if casting
      then
       (resVar_v' := DS`GenCastMapTypeForModify(resVar_v);
        rb := [BC`GenAsgnStmt(resVar_v, DS`GenEmptyMapExpr())]);

      if CPP`isJAVA()
      then
       (dtp := CGAUX`FindMapDomType(rType);
        rtp := CGAUX`FindMapRngType(rType);
       );
      for mk_AS`Maplet(md, mr, -) in ml do
        --def mk_(var1_v, tmpVar1_stmt) = CGExprExcl(md, "tmpVar1", nil);
        --    mk_(var2_v, tmpVar2_stmt) = CGExprExcl(mr, "tmpVar2", nil)
        def mk_(var1_v, tmpVar1_stmt) = CGExprExcl(md, "tmpVar1", dtp);
            mk_(var2_v, tmpVar2_stmt) = CGExprExcl(mr, "tmpVar2", rtp)
        in
         (rb := rb ^ tmpVar1_stmt ^ tmpVar2_stmt ^ [ DS`GenMapInsert(resVar_v', var1_v, var2_v) ];
          allsimple := allsimple and tmpVar1_stmt = [] and tmpVar2_stmt = [];
          if CPP`isCPP() and allsimple
          then expr := DS`GenMapInsertExpr( expr, var1_v, var2_v );
         );
      if CPP`isCPP() and allsimple
      then return expr;
      return  rb;
     );
\end{vdm_al}

\subsection{Set Comprehension Expression}\label{EXPRSetCompExpr}

Consider the set comprehension below:

\begin{verbatim}
  { a + b | a, b in set { 1, 3}, c in set { 4, 5} & a + b = c }
\end{verbatim}

Assume that the evaluation of this set comprehension is to be stored
in the variable named $resVar$. The strategy used in the interpreter
is to compute all the bindings of the patterns (i.e.\ $a, b$ and $c$)
in the bindlist and store these in some temporary variable. We do not
apply this strategy to the code generation as this would imply that we
needed some data value containing the names of the pattern identifiers
(this has been discussed in section \ref{TI}). The strategy applied
in the code generator is, for each possible binding of the pattern
identifiers to compute if the predicate is fulfilled, if this is the
case add an elemnent corresponding to the evaluation of $a + b$ to
the resulting set.

The corresponding pseudo code is listed below:

\begin{small}
\begin{verbatim}
Set res_s;  // A temporaray variable containing the
            // result of the evaluation of the set comprehension.
Int elem;  // variable used to store the evaluation of the expression "a+b"
Int vdm_var_a;
Int vdm_var_b;
Int vdm_var_c; // Declaration of the corresponding pattern variables included in the bind list.
// In the next 10 lines a set of sequence of all the
// combinations of the values in the bind list is computed
Set tmpVar1;
Set tmpVar2;  // Declaration of temporary variable to contain the evaluation of the
              // sets {1,3 } and { 4, 5}, respectively,
Seq seq_lv;   // Declaration of temporary variable to contain the sequence of set of values
              // corresponding to the values in the bind list of the set comprehension.
...CGExpr( "{1,3}", tmpVar1 );
seq_lv.ImpAppend(tmpVar1);
seq_lv.ImpAppend(tmpVar1);
...CGExpr( "{4,5}", tmpVar2 );
seq_lv.ImpAppend(tmpVar2); // Now: seq_lv = [ {1, 3}, {1, 3}, { 4, 5 } ]
Set allComb;   // Temporary variable to contain all the combinations of the
...GenSeqOfSetOf2SetOfSeqOf( seq_lv, allComb ) // In this case the code generated by
                                               // GenSeqOfSetOf2SetOfSeqOf is:
                                               // allComb = { [ 1,1,4], [1,1 5], [1,3,4], [1,3, 5],
                                               //             [ 3,1,4], [3,1,5], [3,1,4], [3,3,5] }
// Now, iterate through the set allComb:
bool succ;  // variable used in the pattern match
Bool pred; // variable used to store the evalutionn of the prediacate "a+b=c"
// Iterate over all the set allComb, in this example we used the Meta-IV Class Library
Generic e;
for ( int bb = allComb.First( e ); bb; bb = allComb.Next( e) )
  { Sequence tmp = e;
    ...CGPatternMatch( "a", mk_CGMAIN`VT(tmp[1], "Int"), {}, succ )
    if ( succ )
      ...CGPatternMatch( "b", mk_CGMAIN`VT(tmp[2], "Int"), {}, succ )
    if ( succ )
      ...CGPatternMatch( "c", mk_CGMAIN`VT(tmp[3], "Int"), {}, succ )
    if ( succ )
      {
        ...CGExpr( "a+b=c", mk_CGMAIN`VT(pred, "Bool") )
        if ( pred.GetValue() )
           { ...CGExpr("a+b", mk_CGMAIN`VT( elem, "Int"));
             res_s.Insert(elem);
           }

      }
  }
resVar = res_s;
\end{verbatim}
\end{small}

The code generation of set comprehension includes several elements
which are similar to the code generation of  sequence
comprehension and map comprehension. The common strategy  of
code generation of all these constructs are:

\begin{enumerate}
\item Computation of the possible combinations of some bind list

\item Evaluation of some predicate which must be fulfilled to do what ever
the construct describe, e.g.\ map comprehenion.
\end{enumerate}

The code generation of corresponding to these two tasks is specified
in one operation $CGComprehension$, the specification and description
of this operation is listed in section \ref{ExprAux}.

Using this auxiliary operation the pseudo code corresponding to the
set comprehension appeared as listed below:

\begin{verbatim}
Set res_s;
Int elem;
...CGComprehension("a, b in set {1, 3}, c in set {4, 5}", "a+b=c",
                   "{ ...CGExpr("a+b", mk_CGMAIN`VT( elem, "Int" ) );
                      res_s.Insert(elem) }", nil, nil );
resVar = res_s;
\end{verbatim}



\begin{vdm_al}
CGSetComprehensionExpr: AS`SetComprehensionExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGSetComprehensionExpr(expr, vt) ==
  def mk_AS`SetComprehensionExpr(elem, bind, pred, -) = expr;
      mk_CGMAIN`VT(resVar_v, -) = vt;
      pid_m = CGAUX`FindPatIdMap(expr)
  in
   (dcl seqapply_s : set of (CPP`Expr * CPP`Expr) := {};
    CGAUX`PushEnv();
    def - = CGAUX`InsertNamesinEnv(dom pid_m) in skip;
    VD`PushFctLoc(dom pid_m);
--
    cases bind:
      [mk_AS`MultSetBind(p_l,setexpr,-)]
               -> if CGAUX`IsSeqIndicesSet(setexpr)
                  then
                   (for p in p_l do
                    cases p:
                      mk_AS`PatternName(nm,-,-) -> if nm <> nil
                                                   then seqapply_s := seqapply_s union
                                                      {mk_(BC`Rename(setexpr.arg), BC`Rename(nm))},
                      others -> skip
                    end),
      others -> skip
    end;
--
    CGAUX`AddNoCheckSeqApply(seqapply_s);
    def resS_v = BC`GiveName("res_s");
        mk_(elem_v, elem_stmt) = CGExprExcl(elem, "res_s", nil);
    in
     (CGAUX`RemNoCheckSeqApply(seqapply_s);
      def todo = elem_stmt ^ [DS`GenSetInsert(resS_v, elem_v)];
          rb = DS`GenDeclEmptySet(resS_v) ^
               [ CGComprehension(bind, pred, todo, nil, nil, pid_m, true),
                 BC`GenAsgnStmt(resVar_v, resS_v ) ]
      in
       (VD`DeleteLoc();
        CGAUX`PopEnv();
        return rb);
     );
   );

\end{vdm_al}


\subsection{Map Comprehension}

The strategy behind code generation of map comprehension is analog to
the code generation of set comprehension, therefore the description of
the code generation of map comprehension is limited.

Consider the map comprehension below:
\begin{verbatim}
{ a |-> b | a, b in set { 1, 3}, c in set {4} & a+b=c }
\end{verbatim}

The corresponding pseudo code is listed below:

\begin{verbatim}
Map res_m;
Int md;
Int mr;
...CGComprehension( "a, b in set {1, 3}, c in set {4}, "a+b=c",
                    { ...CGExpr("a", mk_CGMAIN`VT(md, "Int" ) );
                      ...CGExpr("b", mk_CGMAIN`VT(mr, "Int" ) );
                      if ( res_m.DomExists( md ) )
                         { if !( res_m[ md ] == mr )
                              RunTimeError( "Duplicate entries had different values" )
                         }
                      else
                         res_m.Insert( md, mr ); }
resVar = res_m;
\end{verbatim}



\begin{vdm_al}
CGMapComprehensionExpr: AS`MapComprehensionExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGMapComprehensionExpr(expr, mk_CGMAIN`VT( resVar_v, -)) ==
  def mk_AS`MapComprehensionExpr(mk_AS`Maplet(md,mr,-),bind,pred,-) = expr;
      type = CGAUX`FindType(expr);
      pid_m = CGAUX`FindPatIdMap(expr)
  in
   (CGAUX`PushEnv();
    def - = CGAUX`InsertNamesinEnv(dom pid_m) in skip;
    VD`PushFctLoc(dom pid_m);
    def resM_v = BC`GiveName( "res_m");
        mk_(md_v, md_stmt ) = CGExprExcl( md, "md", nil);
        mk_(mr_v, mr_stmt ) = CGExprExcl( mr, "mr", nil);
        todo = md_stmt ^ mr_stmt ^ [DS`GenMapInsert( resM_v, md_v, mr_v ) ];
        rb = DS`GenDeclEmptyMap(type, resM_v ) ^
             [ CGComprehension( bind, pred, todo, nil, nil, pid_m, true ),
               BC`GenAsgnStmt( resVar_v, resM_v ) ]
    in
     (VD`DeleteLoc();
      CGAUX`PopEnv();
      return rb);
   );

\end{vdm_al}

\subsection{Sequence Comprehension}

Consider the VDM sequence comprehension expression below:

\begin{verbatim}
[ a + b | a in set { 3, 1} & a < 4 ]
\end{verbatim}

Sequence Comprehension differs from map and set comprehension in two ways:

\begin{enumerate}
\item The bind list (in the example {\tt a in set \{3,1\}}) must
only contain one set bind, whereas in map and set comprehension the
bind list could be a sequence of multiple bindings

\item The pattern in the bind bind list must be bound to natural numbers.

\item The pattern (in this case {\tt a}) will be matched to the
numbers in the set ({\tt \{3, 1\}}) in the normal order.
\end{enumerate}

The corresponding pseudo code of the VDM example is listed below:

\begin{small}
\begin{verbatim}
Sequence res_l // A temporaray variable to contain the result of
               // the evaluation of the sequence comprehension.
Int reselem;      // A variable used to store evaluation of the expression "a+b"
Int vdm_var_a;     // Declaration of the corresponding variables to the patternid "a"
Set res_s;
...CGExpr( "{3, 1}", res_s ); // Evaluation of the set enuemeration "{ 3, 1}"
Sequence bind_l;
if (resS_s.Card() > 0 )
then
  bind_l := Sort(res_s);           // Assigns the variable
                                   // res_l to a sequence of the ordered numbers contained in the
                                   // the set res_s, that is, in the example, bind_l = [ 1, 3 ]
// Transverse the sequence res_l, doing pattern match in each iteration
// evaluate the predicate " a < 4" with the current pattern match, if the
// the predicate evaluates to true, evaluate the expression "a+b" and concatenate
// the result to the variable res_l
bool succ;
Bool pred;
Generic eg;
for ( int bb = bind_l.First( eg ); bb; bb = bind_l.Next( eg ) )
 {
   Int e;
   ...CGPatternMatch( "a", mk_CGMAIN`VT( e, "Int"), {}, succ );
   if ( succ )
      { ...CGExpr( "a < 4", mk_CGMAIN`VT( pred, "Bool" ) );
        if ( pred.GetValue() )
           {
             ...CGExpr( "a + b", mk_CGMAIN`VT( reselem, "Int" ) );
             res_l.ImpAppend(elem);
           }
      }
  }
resVar = res_l;
\end{verbatim}
\end{small}

In some cases we dynamically have to check if binding set consists
only of numbers.  Consider forexample the following VDM example:

\begin{verbatim}
[ a | a in set { true, 3} ]
\end{verbatim}

That is, if it is possible that the binding set can consists of values
other than numbers, we dynamically must check if the values are
numbers. Consider the following part of the pseudo code corresponding
to the sequence comprehension above:

\begin{small}
\begin{verbatim}
Sequence res_l // A temporaray variable to contain the result of
               // the evaluation of the sequence comprehension.
Int reselem;      // A variable used to store evaluation of the expression "a+b"
Int vdm_var_a;     // Declaration of the corresponding variables to the patternid "a"
Set res_s;
...CGExpr( "{3, 1}", res_s ); // Evaluation of the set enuemeration "{ 3, 1}"
Sequence bind_l;
if (resS_s.Card() > 0 )
then
  bind_l = Sort(res_s);           // Assigns the variable
                                   // res_l to a sequence of the ordered numbers contained in the
                                   // the set res_s, that is, in the example, bind_l = [ 1, 3 ]
// Transverse the sequence res_l, doing pattern match in each iteration
// evaluate the predicate " a < 4" with the current pattern match, if the
// the predicate evaluates to true, evaluate the expression "a+b" and concatenate
// the result to the variable res_l
bool succ;
Bool pred;
Generic eg;
for ( int bb = bind_l.First( eg ); bb; bb = bind_l.Next( eg ) )
 {
   if (!is_Int( eg ) )
        RunTimeError("The binding set can only contain integers");
   Int e = eg;
   ...CGPatternMatch( "a", mk_CGMAIN`VT( e, "Int"), {}, succ );
   if ( succ )
      { ...CGExpr( "a < 4", mk_CGMAIN`VT( pred, "Bool" ) );
        if ( pred.GetValue() )
           {
             ...CGExpr( "a + b", mk_CGMAIN`VT( reselem, "Int" ) );
             res_l.ImpAppend(elem);
           }
      }
  }
resVar = res_l;
\end{verbatim}
\end{small}


\begin{vdm_al}
CGSeqComprehensionExpr: AS`SeqComprehensionExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGSeqComprehensionExpr(rc1, vt) ==
  let mk_AS`SeqComprehensionExpr(-, bind, -, -) = rc1
  in
    if is_AS`SeqBind(bind)
    then CGSeqComprehensionSeqBind(rc1, vt)
    else
      let mk_AS`SetBind(pat, expr,-) = bind
      in
        if is_AS`PatternName(pat) and pat.nm <> nil and
           (CGAUX`IsSeqIndicesSet(expr) or
           (is_AS`SetRangeExpr(expr) and CGAUX`IsIntType(CGAUX`FindType(expr.lb))
                                  and CGAUX`IsIntType(CGAUX`FindType(expr.lb))))
          -- [ l(i) | i in set inds l ] or [ l(i) | i in set {1,...,len l} ]
        then CGSeqComprehensionIndexLoop(rc1, vt)
        else CGSeqComprehensionSetBind(rc1, vt);

CGSeqComprehensionIndexLoop: AS`SeqComprehensionExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGSeqComprehensionIndexLoop(rc1, vt) ==
  def mk_AS`SeqComprehensionExpr(elem, bind, pred, -) = rc1;
      --pid_m = CGAUX`FindPatIdMap(rc1);
      mk_CGMAIN`VT(resVar_v, rType) = vt;
      mk_AS`SetBind(mk_AS`PatternName(nm,-,-), expr,-) = bind;
      tmpSeq_v = BC`GiveName("tmpSeq");
      count = BC`GiveName("count")
  in
   (dcl stmts : seq of CPP`Stmt := [],
        lb : CPP`Expr,
        ub : CPP`Expr,
        seqapply_s : set of (CPP`Expr * CPP`Expr) := {};
    if is_AS`PrefixExpr(expr) -- in set inds
    then
      def mk_AS`PrefixExpr(-,arg,-) = expr;
          mk_(bl_expr, bl_stmt) = CGExprExcl(arg, "bind_l", nil);
          argtype = CGAUX`FindType(arg);
      in
       (dcl bl_cast : CPP`Expr := bl_expr;
        if not CGAUX`IsSeqType(argtype)
        then if CPP`isCPP()
             then bl_cast := DS`GenCastSeq(bl_expr, nil)
             else if CGAUX`IsStringType(argtype)
                   then bl_cast := DS`GenCastString(bl_expr)
                   else bl_cast := DS`GenCastSeq(bl_expr, nil);
        stmts := bl_stmt;
        lb := BC`GenIntegerLit(1);
        if CPP`isCPP()
        then ub := DS`GenLen_int(bl_cast)
        else if CGAUX`IsPossibleStringType(argtype)
             then ub := DS`GenLenString_int(bl_cast)
             else ub := DS`GenLen_int(bl_cast);
        seqapply_s := seqapply_s union {mk_(bl_expr, BC`Rename(nm))};
       )
    else
      let mk_AS`SetRangeExpr(srlb,srub,-) = expr -- in set {x,...,y}
      in 
       (if is_AS`RealLit(srlb) or is_AS`NumLit(srlb)
        then lb := BC`GenIntegerLit(srlb.val)
        else
          def mk_(lb_expr, lb_stmt) = CGExprExcl(srlb, "lb", nil)
          in
           (stmts := lb_stmt;
            lb := DS`GenGetValue(lb_expr, mk_REP`NumericTypeRep(<INTEGER>)));
        if is_AS`RealLit(srub) or is_AS`NumLit(srub)
        then ub := BC`GenIntegerLit(srub.val)
        else
          def mk_(ub_expr, ub_stmt) = CGExprExcl(srub, "ub", nil)
          in
           (stmts := stmts ^ ub_stmt;
            ub := DS`GenGetValue(ub_expr, mk_REP`NumericTypeRep(<INTEGER>)))
       );
    CGAUX`AddNoCheckSeqApply(seqapply_s);
    CGAUX`PushEnv();
    def - = CGAUX`InsertName(nm);
        mk_(elemExpr, e_stmt) = CGExprExcl(elem, "reselem", nil);
    in
     (dcl append : CPP`Stmt,
          succbody : seq of CPP`Stmt;
      if CPP`isCPP()
      then append := DS`GenImpAppend(tmpSeq_v, elemExpr)
      else if CGAUX`IsPossibleStringType(rType)
           then append := BC`GenAsgnStmt(tmpSeq_v, BC`GenPlus(tmpSeq_v, elemExpr))
           else append := DS`GenImpAppend(tmpSeq_v, elemExpr);
      let elemStmt = e_stmt ^ [append]
      in
        cases pred:
          nil,
          mk_AS`BoolLit(true,-) -> succbody := elemStmt,
          others                -> def predType = CGAUX`FindType (pred);
                                       mk_(pred_v, pred_stmt) = CGExprExcl(pred, "pred", nil);
                                   in
                                    (dcl cond : CPP`Expr;
                                     if CPP`isCPP()
                                     then cond := DS`GenGetValue(pred_v, predType)
                                     else cond := DS`GenGetValue(pred_v, mk_REP`BooleanTypeRep());
                                     succbody := pred_stmt ^ [BC`GenIfStmt(cond, BC`GenBlock(elemStmt), nil)])
        end;
      CGAUX`RemNoCheckSeqApply(seqapply_s);
      def ini = BC`GenDecl(DS`GenSmallNumType(), count, BC`GenAsgnInit(lb));
          e1 = BC`GenLeq(count, ub);
          e2 = BC`GenPostPlusPlus(count);
      in
       (dcl initExpr : CPP`Initializer,
            decl : seq of CPP`Stmt;
        if CPP`isCPP()
        then initExpr := BC`GenObjectInit([count])
        else initExpr := BC`GenAsgnInit(DS`GenIntExpr(count));
        if CPP`isCPP()
        then decl := DS`GenDeclEmptySeq(tmpSeq_v)
        else if CGAUX`IsPossibleStringType(rType)
             then decl := DS`GenStringDecl(tmpSeq_v, BC`GenAsgnInit(DS`GenEmptyStringExpr()))
             else decl := DS`GenDeclEmptySeq(tmpSeq_v);
        def inner_rb_l = DS`GenDecl(mk_REP`NumericTypeRep(<NAT>), BC`Rename(nm), initExpr) ^
                     succbody;
            rb_l = stmts ^ decl ^
               [BC`GenForStmt(ini, e1, [e2], BC`GenBlock(inner_rb_l)),
                BC`GenAsgnStmt(resVar_v, tmpSeq_v)]
        in
         (CGAUX`PopEnv();
          return rb_l))
     )
   );

CGSeqComprehensionSetBind: AS`SeqComprehensionExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGSeqComprehensionSetBind(rc1, vt) ==
  def mk_AS`SeqComprehensionExpr(elem, bind, pred, -) = rc1;
      pid_m = CGAUX`FindPatIdMap(rc1);
      mk_CGMAIN`VT(resVar_v, rType) = vt;
      mk_AS`SetBind(pat, expr,-) = bind;
  in
   (FD`PushEnv();
    VD`PushFctLoc(dom pid_m);
    def exprType = CGAUX`FindType(expr);
        resL_v = BC`GiveName( "res_l" );
        bindL_v   = BC`GiveName( "bind_l" );
        bindLType = let mk_REP`SetTypeRep(type) = exprType
                    in mk_REP`SeqTypeRep(type);
        resSType  = exprType;
        succ_v    = BC`GiveName( "succ" );
        e_v       = BC`GiveName( "e" );
        eType     = let mk_REP`SetTypeRep(type) = exprType
                    in CGAUX`CleanFlatType(type);
        mk_(rb_expr, rb_stmt) = CGExprExcl(expr, "resBind_s", resSType)
    in
      (dcl predType : [REP`TypeRep] := nil,
           sort_f : CPP`Identifier,
           rb : seq of CPP`Stmt := [],
           resS_v : CPP`Expr := rb_expr;

       if pred <> nil
       then predType := CGAUX`FindType( pred );

       if CPP`isJAVA()
       then sort_f := BC`GenIdentifier( "UTIL.Sort" )
       else sort_f := BC`GenIdentifier( "CGUTIL::Sort" );

       rb := rb ^ rb_stmt;
       if not is_CPP`Identifier(rb_expr)
       then
         (resS_v := BC`GiveName( "resBind_s" );
          rb := rb ^ DS`GenDecl(resSType, resS_v, BC`GenAsgnInit(rb_expr)););
       rb := rb ^ DS`GenDeclEmptySeq(resL_v);

       CGAUX`PushEnv();
       def - = CGAUX`InsertNamesinEnv(dom pid_m) in skip;
       def mk_(elemExpr, e_stmt) = CGExprExcl(elem, "reselem", nil);
           impappend = DS`GenImpAppend(resL_v, elemExpr);
           elemStmt = e_stmt ^ [impappend];
           decls = DeclPatVars( pid_m );
       in
        (dcl succbody : seq of CPP`Stmt;
         if pred = mk_AS`BoolLit(true, CI`NilContextId) or pred = nil
         then succbody := elemStmt
         else
           def mk_(pred_v, pred_stmt) = CGExprExcl(pred, "pred", nil);
           in
            (dcl cond : CPP`Expr;
             if CPP`isCPP()
             then cond := DS`GenGetValue(pred_v, predType)
             else cond := DS`GenGetValue(pred_v, mk_REP`BooleanTypeRep());
             succbody := pred_stmt ^ [BC`GenIfStmt(cond, BC`GenBlock(elemStmt), nil)]);
         def mk_(pm, Is_excl) = PM`CGPatternMatchExcl(pat, mk_CGMAIN`VT(e_v, eType), {},
                                                      succ_v, pid_m, succbody, false);
             pm' = (if not Is_excl
                    then [BC`GenDecl( DS`GenSmallBoolType(), succ_v,
                                      BC`GenAsgnInit( BC`GenBoolLit(false) ) )]
                    else []) ^ pm;
       in
        (dcl cast : CPP`Expr,
             rb_inner : seq of CPP`Stmt := [],
             todo : seq of CPP`Stmt := [];

         if CPP`isCPP()
         then cast := resL_v
         else if CGAUX`IsSubType(bindLType, rType)
              then cast := resL_v
              else cast := DS`GenExplicitCast(rType, resL_v, bindLType);

         rb_inner := rb_inner ^ DS`GenDecl (bindLType, bindL_v,
                                   BC`GenAsgnInit(BC`GenFctCall (sort_f, [resS_v])));
         rb_inner := rb_inner ^ decls;
        
         if not CGAUX`IsIntType( eType )
         then
           todo := [ BC`GenIfStmt( BC`GenNot(DS`GenIsInt(e_v)),
                  BC`GenBlock([CGAUX`RunTime("The binding set must only contain integers")]),
                                   nil ) ];
         todo := todo ^ pm';

         rb_inner := rb_inner ^ DS`GenIterSeq( mk_CGMAIN`VT( bindL_v,bindLType ),
                                               nil,
                                               mk_CGMAIN`VT( e_v, eType ),
                                               todo);

         rb := rb ^ [ BC`GenIfStmt(BC`GenNot(DS`GenSetIsEmpty(resS_v)),
                                   BC`GenBlock(rb_inner), nil) ];
         rb := rb ^ [ BC`GenAsgnStmt( resVar_v, cast ) ];

         FD`PopEnv();
         CGAUX`PopEnv();
         VD`DeleteLoc();
         return [BC`GenBlock(rb)])))
   );

CGSeqComprehensionSeqBind: AS`SeqComprehensionExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGSeqComprehensionSeqBind(rc1, vt) ==
  def mk_AS`SeqComprehensionExpr(elem, bind, pred, -) = rc1;
      pid_m = CGAUX`FindPatIdMap(rc1);
      mk_CGMAIN`VT(resVar_v, rType) = vt;
      mk_AS`SeqBind(pat, expr,-) = bind;
  in
   (FD`PushEnv();
    VD`PushFctLoc(dom pid_m);
    def exprType = CGAUX`FindType(expr);
        resL_v = BC`GiveName( "res_l" );
        bindL_v   = BC`GiveName( "bind_l" );
        bindLType = exprType;
        resSType  = exprType;
        succ_v    = BC`GiveName( "succ" );
        e_v       = BC`GiveName( "e" );
        eType     = let mk_REP`SeqTypeRep(type) = exprType
                    in CGAUX`CleanFlatType(type);
        mk_(rb_expr, rb_stmt) = CGExprExcl(expr, "resBind_s", resSType)
    in
      (dcl predType : [REP`TypeRep] := nil,
           rb : seq of CPP`Stmt := [],
           resS_v : CPP`Expr := rb_expr;

       if pred <> nil
       then predType := CGAUX`FindType( pred );

       rb := rb ^ rb_stmt;
       if not is_CPP`Identifier(rb_expr)
       then
         (resS_v := BC`GiveName( "resBind_s" );
          rb := rb ^ DS`GenDecl(resSType, resS_v, BC`GenAsgnInit(rb_expr)););
       rb := rb ^ DS`GenDeclEmptySeq(resL_v);

       CGAUX`PushEnv();
       def - = CGAUX`InsertNamesinEnv(dom pid_m) in skip;
       def mk_(elemExpr, e_stmt) = CGExprExcl(elem, "reselem", nil);
           impappend = DS`GenImpAppend(resL_v, elemExpr);
           elemStmt = e_stmt ^ [impappend];
           decls = DeclPatVars( pid_m );
       in
        (dcl succbody : seq of CPP`Stmt;
         if pred = mk_AS`BoolLit(true, CI`NilContextId) or pred = nil
         then succbody := elemStmt
         else
           def mk_(pred_v, pred_stmt) = CGExprExcl(pred, "pred", nil);
           in
            (dcl cond : CPP`Expr;
             if CPP`isCPP()
             then cond := DS`GenGetValue(pred_v, predType)
             else cond := DS`GenGetValue(pred_v, mk_REP`BooleanTypeRep());
             succbody := pred_stmt ^ [BC`GenIfStmt(cond, BC`GenBlock(elemStmt), nil)]);
         def mk_(pm, Is_excl) = PM`CGPatternMatchExcl(pat, mk_CGMAIN`VT(e_v, eType), {},
                                                      succ_v, pid_m, succbody, false);
             pm' = (if not Is_excl
                    then [BC`GenDecl( DS`GenSmallBoolType(), succ_v,
                                      BC`GenAsgnInit( BC`GenBoolLit(false) ) )]
                    else []) ^ pm;
       in
        (dcl cast : CPP`Expr,
             rb_inner : seq of CPP`Stmt := [],
             todo : seq of CPP`Stmt := [];

         if CPP`isCPP()
         then cast := resL_v
         else if CGAUX`IsSubType(bindLType, rType)
              then cast := resL_v
              else cast := DS`GenExplicitCast(rType, resL_v, bindLType);

         rb_inner := rb_inner ^ DS`GenDecl (bindLType, bindL_v, BC`GenAsgnInit(resS_v));
        
         todo := todo ^ MergeStmts( decls, pm');

         rb_inner := rb_inner ^ DS`GenIterSeq( mk_CGMAIN`VT( bindL_v,bindLType ),
                                               nil,
                                               mk_CGMAIN`VT( e_v, eType ),
                                               todo);

         rb := rb ^ [ BC`GenIfStmt(BC`GenNot(DS`GenSeqIsEmpty(resS_v)),
                                   BC`GenBlock(rb_inner), nil) ];
         rb := rb ^ [ BC`GenAsgnStmt( resVar_v, cast ) ];

         FD`PopEnv();
         CGAUX`PopEnv();
         VD`DeleteLoc();
         return [BC`GenBlock(rb)])))
   );
\end{vdm_al}

\subsection{Set Range Expression}

In this section the specification of code generation of set range
expression is described. Consider the set range expression:

\begin{verbatim}
{ -1, ..., f(x) }
\end{verbatim}

The corresponding pseudo code is listed below, assuming that the
result of evaluating the expression is to be store in the variable
$resVar$, and that the signature of $f$ is $f: \Nat \To \Nat | \Char$.


\begin{verbatim}
Set tmpRng;
Int lb;
Generic ub;
...CGExpr("-1", CGMAIN`VT(lb, "Int"));
...CGExpr("f(x)", CGMAIN`VT(ub, "Generic"));
if (! ub.IsInt())
  RunTimeError("Upper bound was not an integer in set range expression")
int ubi = ((Int) ub).GetValue();
for (int count=lb.GetValue(); count <= ubi; count++)
  tmpRng.Insert((Int) count);
resVar_v = tmpRng;
\end{verbatim}


The operation $CGSetRangeExpr$ generates the code corresponding to set
range expression.

\begin{vdm_al}
CGSetRangeExpr: AS`SetRangeExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGSetRangeExpr(mk_AS`SetRangeExpr(lb, ub, -), mk_CGMAIN`VT(resVar_v, rType)) ==
  def casting = not CGAUX`IsSetType( rType );
      mk_(lb_v, lb_stmt) = CGExprExcl(lb, "lb", nil);
      mk_(ub_v, ub_stmt) = CGExprExcl(ub, "ub", nil);
      lbt : REP`TypeRep = CGAUX`FindType(lb);
      ubt : REP`TypeRep = CGAUX`FindType(ub);
      count : CPP`Name = BC`GiveName("count");
      irep : REP`TypeRep = mk_REP`NumericTypeRep(<INTEGER>);
      its : CPP`TypeSpecifier = DS`GenIntType();
      sint : CPP`TypeSpecifier = DS`GenSmallNumType()
  in
   (dcl rb_l : seq of CPP`Stmt := [BC`GenAsgnStmt(resVar_v, DS`GenEmptySetExpr())],
        lbi_v : CPP`Expr := BC`GiveName("lbi"),
        ubi_v : CPP`Expr := BC`GiveName("ubi");

    rb_l := rb_l ^ lb_stmt ^ ub_stmt;

    if (not CGAUX`IsIntType(lbt))
    then
     (dcl lb_v' : CPP`Expr := BC`GiveName("lb");
      if is_CPP`Identifier(lb_v) or CGAUX`IsIntExpr(lb_v)
      then lb_v' := lb_v
      --else rb_l := rb_l ^ [BC`GenDecl(DS`GenType(lbt), lb_v', BC`GenAsgnInit(lb_v))];
      else rb_l := rb_l ^ DS`GenConstDeclInit(lbt, lb_v', lb_v);

      def cond = BC`GenNot(DS`GenIsInt(lb_v'));
          rti = CGAUX`RunTime("Lower bound was not an integer in set range expression");
      in
       (dcl lbval : CPP`Expr;
        if CPP`isCPP()
        then lbval := DS`GenGetValue(BC`GenCastExpr(its, lb_v'), irep)
        else lbval := DS`GenGetValue(DS`GenExplicitCast(irep, lb_v', lbt), irep);
        --rb_l := rb_l ^ [BC`GenIfStmt(cond, rti, nil)];
        rb_l := rb_l ^ [BC`GenIfStmt(cond, BC`GenBlock([rti]), nil)];
        rb_l := rb_l ^ [BC`GenDecl(sint, lbi_v, BC`GenAsgnInit(lbval))];))
    else
      def lb_v' = DS`GenGetValue(lb_v, irep)
      in
        if is_CPP`IntegerLit(lb_v')
        then lbi_v := lb_v'
        else rb_l := rb_l ^ [BC`GenDecl(sint, lbi_v, BC`GenAsgnInit(lb_v'))];

    if (not CGAUX`IsIntType(ubt))
    then
     (dcl ub_v' : CPP`Expr := BC`GiveName("ub");
      if is_CPP`Identifier(ub_v) or CGAUX`IsIntExpr(ub_v)
      then ub_v' := ub_v
      --else rb_l := rb_l ^ [BC`GenDecl(DS`GenType(ubt), ub_v', BC`GenAsgnInit(ub_v))];
      else rb_l := rb_l ^ DS`GenConstDeclInit(ubt, ub_v', ub_v);

     def cond = BC`GenNot(DS`GenIsInt(ub_v'));
         rti = CGAUX`RunTime("Upper bound was not an integer in set range expression");
     in
      (dcl ubval : CPP`Expr;
       if CPP`isCPP()
       then ubval := DS`GenGetValue(BC`GenCastExpr(its, ub_v'), irep)
       else ubval := DS`GenGetValue(DS`GenExplicitCast(irep,ub_v',ubt), irep);
       --rb_l := rb_l ^ [BC`GenIfStmt(cond, rti, nil)];
       rb_l := rb_l ^ [BC`GenIfStmt(cond, BC`GenBlock([rti]), nil)];
       rb_l := rb_l ^ [BC`GenDecl(sint, ubi_v, BC`GenAsgnInit(ubval))];))
    else
      def ub_v' = DS`GenGetValue(ub_v, irep)
      in
        if is_CPP`IntegerLit(ub_v')
        then ubi_v := ub_v'
        else rb_l := rb_l ^ [BC`GenDecl(sint, ubi_v, BC`GenAsgnInit(ub_v'))];

    def ini = BC`GenDecl(sint, count, BC`GenAsgnInit(lbi_v));
        e1 = BC`GenLeq(count, ubi_v);
        e2 = BC`GenPostPlusPlus(count);
        cast = DS`GenIntExpr(count);
    in
     (dcl stmt : CPP`Stmt;
      if casting
      then
        if CPP`isCPP()
        then stmt := BC`GenAsgnStmt(resVar_v, DS`GenSetInsertExpr(DS`GenSetExpr(resVar_v), cast))
        else stmt := BC`GenExpressionStmt(DS`GenSetInsertExpr(DS`GenCastSetType(resVar_v), cast))
      else stmt := DS`GenSetInsert(resVar_v, cast);
      --rb_l := rb_l ^ [BC`GenForStmt(ini, e1, [e2], stmt)]
      rb_l := rb_l ^ [BC`GenForStmt(ini, e1, [e2], BC`GenBlock([stmt]))]
     );
  return rb_l;
);
\end{vdm_al}

\subsection{Subsequence Expression}

In this section the specification of code generation of subsequence
expression is described. Consider the subsequence expression:


\begin{verbatim}
g(y)(2,...,f(x))
\end{verbatim}

The corresponding pseudo code is listed below, assuming that the
result of evaluating the expression is to be store in the variable
$resVar$, that the signature of $f$ is $f: \Nat \To \Nat | \Bool$, and
that the signature of $g$ if $g: \Nat \To \Nat | \seq*{\Nat}$.

\begin{verbatim}
Generic tmpSeq;
Sequence resSeq;
...CGExpr("g(y)", CGMAIN`VT(tmpSeq, "Generic"));
Real n1;
Real n2;
...CGExpr("2", CGMAIN`VT(n1, "Real"))
...CGExpr("f(x), CGMAIN`VG(n2, "Real"))
double from = n1.GetValue()
double to = n2.GetValue()
int max = Sequence (tmpSeq).Length();
for (int i = 1; i <= max; i++)
  if (from <= i && i <= to)
    resSeq.ImpAppend(Sequence(tmpSeq)[i]);
resVar_v = resSeq;
\end{verbatim}

The operation $CGSubSeqExpr$ generates the code corresponding to
subsequence expressions.

\begin{vdm_al}
CGSubSeqExpr: AS`SubSequenceExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGSubSeqExpr(mk_AS`SubSequenceExpr(sq, n1, n2, -), mk_CGMAIN`VT(resVar_v,-)) ==
( dcl rb_l : seq of CPP`Stmt := [],
      resSeq : CPP`Name := BC`GiveName("resSeq"),
      n1_v : CPP`Expr := BC`GiveName("n1"),
      n2_v : CPP`Expr := BC`GiveName("n2"),
      From : CPP`Name := BC`GiveName("from"),
      To : CPP`Name := BC`GiveName("to"),
      max : CPP`Name := BC`GiveName("max"),
      i : CPP`Name := BC`GiveName("i"),
      sqt : REP`TypeRep := CGAUX`FindType(sq),
      irep : REP`TypeRep := mk_REP`NumericTypeRep(<INTEGER>),
      rrep : REP`TypeRep := mk_REP`NumericTypeRep(<REAL>),
      sint : CPP`TypeSpecifier := DS`GenSmallIntType(),
      tmpSeq : CPP`Expr;
  def mk_(tmpSeq1, sq_stmt) = CGExprExcl(sq, "tmpSeq", nil) in
  ( tmpSeq := tmpSeq1;
    rb_l := sq_stmt;
    if not CGAUX`IsSeqType(sqt) then
    ( def tmpGSeq = BC`GiveName("tmpGSeq")
      in (tmpSeq := tmpGSeq;
          rb_l := rb_l ^ DS`GenDecl(sqt, tmpGSeq, BC`GenAsgnInit(tmpSeq1)));
      def cond = BC`GenNot(DS`GenIsSeq(tmpSeq));
          rti = BC`GenBlock([CGAUX`RunTime("A sequence was expected in subsequence expression")])
      in rb_l := rb_l ^ [BC`GenIfStmt(cond, rti, nil)];
      tmpSeq := DS`GenCastSeq(tmpSeq, sqt)
    );
    def mk_(n1_expr_v, n1_stmt) = CGExprExcl(n1, "n1", nil);
        mk_(n2_expr_v, n2_stmt) = CGExprExcl(n2, "n2", nil)
    in (rb_l := rb_l ^ n1_stmt ^ n2_stmt;
        n1_v := n1_expr_v;
        n2_v := n2_expr_v );
    if CPP`isJAVA()
    then
      (
        def isStringType = CGAUX`IsStringType(sqt) or CGAUX`IsPossibleStringType(sqt);
            n1tp = CGAUX`FindType(n1);
            n2tp = CGAUX`FindType(n2)
        in
         (dcl n1value : CPP`Expr,
              n2value : CPP`Expr,
              n1intvalue : CPP`Expr,
              n2intvalue : CPP`Expr;
          if CGAUX`IsNumType(n1tp)
          then if CGAUX`IsIntExpr(n1_v)
               then n1value := DS`GenGetValue(n1_v, irep)
               else n1value := DS`GenGetValue(n1_v, rrep)
          else def From2 = BC`GiveName("from")
               in
                (rb_l := rb_l ^ DS`GenDecl(n1tp, From2, BC`GenAsgnInit(n1_v));
                 rb_l := rb_l ^ [BC`GenIfStmt(BC`GenNot(DS`GenIsReal(From2)),
                                 BC`GenBlock([CGAUX`RunTime ("A number was expected")]), nil)];
                 n1_v := From2;
                 n1value := DS`GenGetValue(DS`GenExplicitCast(rrep, n1_v, n1tp), rrep));
          if CGAUX`IsNumType(n2tp)
          then if CGAUX`IsIntExpr(n2_v)
               then n2value := DS`GenGetValue(n2_v, irep)
               else n2value := DS`GenGetValue(n2_v, rrep)
          else def To2 = BC`GiveName("to")
               in
                (rb_l := rb_l ^ DS`GenDecl(n2tp, To2, BC`GenAsgnInit(n2_v));
                 rb_l := rb_l ^ [BC`GenIfStmt(BC`GenNot(DS`GenIsReal(To2)),
                                 BC`GenBlock([CGAUX`RunTime ("A number was expected")]), nil)];
                 n2_v := To2;
                 n2value := DS`GenGetValue(DS`GenExplicitCast(rrep, n2_v, n2tp), rrep));
          if CGAUX`IsIntType(CGAUX`FindType(n1))
          then n1intvalue := n1value
          else n1intvalue := BC`GenFctCall(BC`GenIdentifier("Math.ceil"), [n1value]);
          if CGAUX`IsIntType(CGAUX`FindType(n2))
          then n2intvalue := n2value
          else n2intvalue := BC`GenFctCall(BC`GenIdentifier("Math.floor"), [n2value]);
          let ai1max = if is_CPP`IntegerLit(n1intvalue)
                       then BC`GenFctCall(BC`GenIdentifier("Math.max"),
                                  [BC`GenIntegerLit(n1intvalue.val - 1), BC`GenIntegerLit(0)])
                       else BC`GenFctCall(BC`GenIdentifier("Math.max"),
                                  [BC`GenMinus(n1intvalue, BC`GenIntegerLit(1)), BC`GenIntegerLit(0)]),
              ai2final = if isStringType
                         then BC`GenFctCallObjMemAcc(tmpSeq, "length",[])
                         else BC`GenFctCallObjMemAcc(tmpSeq, "size",[]),
              ai2min = BC`GenFctCall(BC`GenIdentifier("Math.min"), [n2intvalue, ai2final]),
              ai1 = BC`GenAsgnInit(BC`GenCastExpr(BC`GenTypeSpecifier(BC`GenIdentifier("int")), ai1max)),
              ai2 = BC`GenAsgnInit(BC`GenCastExpr(BC`GenTypeSpecifier(BC`GenIdentifier("int")), ai2min))
          in
           (rb_l := rb_l ^ [BC`GenDecl(sint, From, ai1)];
            rb_l := rb_l ^ [BC`GenDecl(sint, To, ai2)];
            def fcall = if isStringType
                        then BC`GenFctCallObjMemAcc(tmpSeq,"substring",[From,To])
                        else BC`GenFctCallObjMemAcc(tmpSeq,"subList",[From,To]);
            in
             (dcl classcr : CPP`Expr := fcall,
                  emptySeq : CPP`Expr;
              if not isStringType
              then classcr := DS`GenSeqExpr(fcall);
              if isStringType
              then emptySeq := BC`GenStringLit("")
              else emptySeq := DS`GenEmptySeqExpr();
              def thenstmt = BC`GenAsgnStmt(resVar_v, emptySeq);
                  elsestmt = BC`GenAsgnStmt(resVar_v, classcr);
                  cond = BC`GenGt(From, To)
              in
                rb_l := rb_l ^ [ BC`GenIfStmt(cond, thenstmt, elsestmt)]);
            return rb_l;
           )
         )
    )
    else
     (def n1tp = CGAUX`FindType(n1);
          n2tp = CGAUX`FindType(n2)
      in
       (dcl n1value : CPP`Expr,
            n2value : CPP`Expr;
            if CGAUX`IsNumType(n1tp)
            then if CGAUX`IsIntType(n1tp)
                 then n1value := DS`GenGetValue(n1_v, rrep)
                 else n1value := DS`GenGetValue(BC`GenFctCallObjMemAcc(n1_v, "Ceil", []), rrep) 
            else
              def From2 = BC`GiveName("from")
              in (rb_l := rb_l ^ DS`GenDecl(n1tp, From2, BC`GenAsgnInit(n1_v));
                  rb_l := rb_l ^ [BC`GenIfStmt(BC`GenNot(DS`GenIsReal(From2)),
                                  BC`GenBlock([CGAUX`RunTime ("A number was expected")]), nil)];
                  n1_v := From2;
                  if CPP`isCPP()
                  then n1value := DS`GenGetValue(BC`GenCastExpr(DS`GenRealType(), n1_v), rrep)
                  else n1value := DS`GenGetValue(DS`GenExplicitCast(rrep, n1_v, n1tp), rrep);
                 );
            if CGAUX`IsNumType(n2tp)
            then if CGAUX`IsIntType(n2tp)
                 then n2value := DS`GenGetValue(n2_v, rrep)
                 else n2value := DS`GenGetValue(BC`GenFctCallObjMemAcc(n2_v, "Floor", []), rrep) 
            else
              def To2 = BC`GiveName("to")
              in (rb_l := rb_l ^ DS`GenDecl(n2tp, To2, BC`GenAsgnInit(n2_v));
                  rb_l := rb_l ^ [BC`GenIfStmt(BC`GenNot(DS`GenIsReal(To2)),
                                  BC`GenBlock([CGAUX`RunTime ("A number was expected")]), nil)];
                  n2_v := To2;
                  if CPP`isCPP()
                  then n2value := DS`GenGetValue(BC`GenCastExpr(DS`GenRealType(),n2_v),rrep)
                  else n2value := DS`GenGetValue(DS`GenExplicitCast(rrep, n2_v, n2tp), rrep);
                 );
        if CPP`isCPP()
        then
          (let subSeq = BC`GenFctCallObjMemAcc(tmpSeq, "SubSequence", [n1value, n2value])
           in
             rb_l := rb_l ^ [BC`GenAsgnStmt(resVar_v, subSeq)];
           return rb_l;
          )
        else
          (def ai1 = BC`GenAsgnInit(n1value);
               ai2 = BC`GenAsgnInit(n2value);
           in
             (dcl ai3 : CPP`AsgnInit;
              if CPP`isCPP()
              then ai3 := BC`GenAsgnInit(DS`GenLen(tmpSeq))
              else ai3 := BC`GenAsgnInit(DS`GenLen_int(tmpSeq));
              rb_l := rb_l ^ [BC`GenDecl(sint, From, ai1)];
              rb_l := rb_l ^ [BC`GenDecl(sint, To, ai2)];
              rb_l := rb_l ^ [BC`GenDecl(sint, max, ai3)] );
              def ini = BC`GenDecl(sint, i, BC`GenAsgnInit(BC`GenIntegerLit(1)));
                  e1 = BC`GenLeq(i, max);
                  e2 = BC`GenPostPlusPlus(i);
                  c1 = BC`GenLeq(From, i);
                  c2 = BC`GenLeq(i, To);
                  stmt = DS`GenImpAppend(resSeq, DS`GenSeqApply(nil,tmpSeq, i)) in
              let ifs = BC`GenIfStmt(BC`GenLogAnd(c1,c2), stmt, nil) in
                rb_l := rb_l ^ [BC`GenForStmt(ini, e1, [e2], ifs)];
                rb_l := rb_l ^ [BC`GenAsgnStmt(resVar_v, resSeq)];
                return rb_l;
          )
        )
      )
    )
);

\end{vdm_al}


\subsection{Tuple Constructor}

In this section the specification of code generation of tuple
constructor is described.

Consider the VDM specification below:
\begin{verbatim}
mk_( 2, 3, { 21, 34} )
\end{verbatim}

The corresponding pseudo code is listed below, assuming that the
result of evaluating the expression is to be store in the variable
$resVar$:

\begin{verbatim}
Tuple tmptup(3);  // Declaration of a temporary variable to store
                  // the result of the evalaution in
                  // Notice that the length of the tuple is 3.
{ Int tmpVar;
  ...CGExpr( "2", mk_CGMAIN`VT( tmpVar, "Int" ) );
  tmptup.SetField(1, tmpVar);
}
{ Int tmpVar;
  ...CGExpr("3", mk_CGMAIN`VT( tmpVar, "Int" ) );
  tmptup.SetField(2, tmpVar);
}
{ Set tmpVar;
  ...CGExpr("{ 21, 34 }", mk_CGMAIN`VT( tmpVar, "Set" ) );
  tmptup.SetField(3, tmpVar)
}
resVar = tmptup;
\end{verbatim}

\begin{vdm_al}
CGTupleConstructorExpr: AS`TupleConstructorExpr * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGTupleConstructorExpr(mk_AS`TupleConstructorExpr(fields,-), mk_CGMAIN`VT(resVar_v,rType)) ==
 (dcl resVar_v' : CPP`Expr := resVar_v,
      tc : CPP`Expr,
      rb : seq of CPP`Stmt,
      allsimple : bool := true,
      args : seq of CPP`Expr :=[];

  if not CGAUX`IsProductType(rType)
  then resVar_v' := DS`GenCastProductTypeForModify(resVar_v);
  tc := DS`GenProductExpr(BC`GenIntegerLit(len fields));

  rb := [BC`GenAsgnStmt(resVar_v, tc)];

  def etp_l = CGAUX`FindProductElemType(rType, len fields)
  in
    for i = 1 to len fields do
     (dcl etp : [REP`TypeRep] := nil;
      if CPP`isJAVA() then etp := etp_l(i);
      def expr = fields(i);
          mk_(tmpExpr, e_stmt) = CGExprExcl(expr, "tmpVar", etp);
          field = BC`GenIntegerLit(i);
          setField = DS`GenTupSetField(resVar_v', field, tmpExpr)
      in
        (rb := rb ^ e_stmt ^ [setField];
         if e_stmt <> [] or is_AS`ApplyExpr(expr)
         then allsimple := false;
         args := args ^ [tmpExpr]);
     );
  if (len fields <= 8) and allsimple
  then
   (dcl fnm : CPP`Identifier;
    if CPP`isCPP()
    then fnm := BC`GenIdentifier("mk_")
    else fnm := BC`GenIdentifier("Tuple.mk_");
    return BC`GenFctCall(fnm, args))
  else return rb
);
\end{vdm_al}

\subsection{Record Constructor Expression}

In this section the specification code generation of record constructor expression is described.

Consider the VDM specification below:
\begin{verbatim}
mk_A(2, 3, {21, 34})
\end{verbatim}

The corresponding pseudo code is listed below, assuming that the
result of evaluating the expression is to be store in the variable
$resVar$:

\begin{verbatim}
Record tmprec(1, 3);  // Declaration of a temporary variable to store
                      // the result of the evalaution in
                      // Notice that the length of the record is 3.
{ Int tmpVar;
  ...CGExpr("2", mk_CGMAIN`VT(tmpVar, "Int"));
  tmprec.SetField(1, tmpVar);
}
{ Int tmpVar;
  ...CGExpr("3", mk_CGMAIN`VT(tmpVar, "Int"));
  tmprec.SetField(2, tmpVar);
}
{ Set tmpVar;
  ...CGExpr("{21, 34}", mk_CGMAIN`VT(tmpVar, "Set"));
  tmprec.SetField(3, tmpVar)
}
resVar = tmprec;
\end{verbatim}


\begin{vdm_al}
CGRecordConstructorExpr: AS`RecordConstructorExpr * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGRecordConstructorExpr(recordexpr, mk_CGMAIN`VT( resVar_v, - ) ) ==
def mk_AS`RecordConstructorExpr( -, fields, - ) = recordexpr;
    mk_REP`CompositeTypeRep(tag,-) = CGAUX`FindType(recordexpr);
in
  if CPP`isCPP()
  then
    def rc = BC`GenFctCall(TPGEN`Name2CppTpId(tag), [])
    in
      if len fields = 0
      then return rc
      else
        (dcl rb : seq of CPP`Stmt := [],
             args : seq of CPP`Expr := [];
         for expr in fields do
           def mk_(tmpExpr, e_stmt) = CGExprExcl(expr, "tmpVar", nil)
           in
             (dcl tmpExpr' : CPP`Expr := tmpExpr;
              rb := rb ^ e_stmt;
              if is_AS`ApplyExpr(expr) and is_CPP`CastExpr(tmpExpr)
              then tmpExpr' := tmpExpr.expr;
              args := args ^ [tmpExpr'];
             );
           rb := rb ^ [BC`GenAsgnStmt(resVar_v, BC`GenFctCallObjMemAcc(rc, "Init", args))];
           return rb;)
  else -- Java
    def rc = DS`GenEmptyRecordExpr(tag)
    in
      if len fields = 0
      then return rc
      else
        (dcl rb : seq of CPP`Stmt := [],
             par: seq of CPP`Expr := [];
         def mk_REP`CompositeTypeRep(-,rcfields) = CGAUX`FindType(recordexpr)
         in
           for i = 1 to len fields do
             def expr = fields(i);
                 mk_REP`FieldRep(-,type,-) = rcfields(i);
                 mk_(tmpExpr, e_stmt) = CGExprExcl(expr, "tmpVar", nil);
#ifdef VDMSL
                 castExpr = DS`GenExplicitCast(type,tmpExpr,CGAUX`FindType(expr))
             in
              (rb := rb ^ e_stmt;
               par := par ^ [castExpr];);
#endif VDMSL
#ifdef VDMPP
             in
              (dcl casttp : REP`TypeRep := type;
               if is_REP`ObjRefTypeRep (CGAUX`CleanFlatType(type))
               then casttp := CGAUX`UnQClassType (CGAUX`CleanFlatType(type));
               def castExpr = DS`GenExplicitCast(casttp,tmpExpr,CGAUX`FindType(expr))
               in
                 (rb := rb ^ e_stmt;
                  par := par ^ [castExpr];);
              );
#endif VDMPP
           rb := rb ^ [BC`GenAsgnStmt(resVar_v, DS`GenRecordExpr(tag,par))];
           return rb);
\end{vdm_al}

\subsection{Token Constructor Expression}

In this section the code generation of token constructor expression is
described. Consider the expression below:

\begin{verbatim}
mk_token({1, 2})
\end{verbatim}

The corresponding pseudo code is listed below, assuming that the
result of evaluating the expression is to be store in the variable
{\tt resVar}:

The operation $CGTokenConstExpr$ generates the code corresponding to
a token constructor expression.

\begin{vdm_al}
CGTokenConstExpr: AS`TokenConstructorExpr * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGTokenConstExpr(mk_AS`TokenConstructorExpr(elem, -), mk_CGMAIN`VT(resVar,-)) ==
  def mk_(tmpvar, e_stmt) = CGExprExcl(elem, "tmpvar", nil);
  in
   (dcl tokenconst : CPP`Expr;
    if CPP`isCPP()
    then tokenconst := BC`GenFctCall(BC`GenIdentifier("mk_token"), [tmpvar])
    else tokenconst := DS`GenTokenExpr(tmpvar);
    if e_stmt <> []
    then return e_stmt ^ [BC`GenAsgnStmt(resVar, tokenconst)]
    else return tokenconst;
   );
\end{vdm_al}

\subsection{Type Judgement Expression}

\begin{vdm_al}
CGTypeJudgementExpr: AS`TypeJudgementExpr * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGTypeJudgementExpr(mk_AS`TypeJudgementExpr(expr,type,cid), vt) ==
  if not is_AS`Name(expr) 
  then
   (def ecid = CI`PushCGType(CGAUX`FindType(expr));
        tjTempId = BC`GiveName("tjTemp");
        tjTemp = mk_AS`Name([tjTempId.id], ecid);
        pn = mk_AS`PatternName(tjTemp, nil, ecid);
        ntj = mk_AS`TypeJudgementExpr(tjTemp, type, cid)
    in
      return CGExpr'(mk_AS`DefExpr([mk_(pn, expr)], ntj, cid), vt);
   )
  else
   (dcl e : [AS`Expr] := ConvertTypeJudgementExprAS(expr, type);
    if e <> nil
    then return CGExpr'(e, vt)
    else
     (CGAUX`SetNotSupportedException(true);
      return [CGAUX`NotSupported("type judgement expression")]);
   );

ConvertTypeJudgementExprAS: AS`Expr * AS`Type ==> [AS`Expr]
ConvertTypeJudgementExprAS(expr, tp) ==
  def bt = mk_REP`BooleanTypeRep();
      cid = CI`PushCGType(bt)
  in
    cases tp:
      mk_AS`BooleanType(-),
      mk_AS`NumericType(-,-),
      mk_AS`TokenType(-),
      mk_AS`CharType(-)            -> return mk_AS`IsExpr(tp, expr, cid),
      mk_AS`CompositeType(nm,-,-)  -> return mk_AS`IsExpr(nm, expr, cid),
      mk_AS`QuoteType(lit,-)       -> return mk_AS`BinaryExpr(expr, <EQ>, lit, cid),
      mk_AS`BracketedType(type,-)  -> return ConvertTypeJudgementExprAS(expr, type),
      mk_AS`AllType(-)             -> return mk_AS`BoolLit(true, cid),
      -- is_(expr, T1 | ... | Tn) ==
      --   is_(expr, T1) or ... or is_(expr, Tn)
      mk_AS`UnionType(tps,-) -> (dcl allOk : bool := true,
                                     e_l : seq of AS`Expr := [];
                                 for gt in tps do
                                   def e = ConvertTypeJudgementExprAS(expr, gt)
                                   in if e <> nil
                                       then e_l := e_l ^ [e]
                                       else allOk := false and allOk;
                                  if allOk and e_l <> []
                                  then
                                    (dcl e : AS`Expr := e_l(len e_l);
                                     for i = len e_l - 1 to 1 by -1 do
                                       let e2 = mk_AS`BinaryExpr(e_l(i), <OR>, e, cid)
                                       in e := e2;
                                     return e;)
                                  else return nil;),
      -- is_(expr, T1 * ... * Tn) ==
      --   cases expr:
      --     mk_(-, ..., -) -> is_(expe.#1, T1) and ... and is_(expe.#n, Tn),
      --     others -> false
      --   end
      mk_AS`ProductType(tp_l,-) ->
         def ncid = CI`PushCGType(mk_REP`NumericTypeRep(<NATONE>));
             ptp_l = CGAUX`FindProductElemType(CGAUX`FindType(expr), len tp_l)
         in
           if ptp_l = nil
           then return nil
           else
             def pcid = CI`PushCGType(mk_REP`ProductTypeRep(ptp_l))
             in
               (dcl allOk: bool := true,
                    e_l : seq of AS`Expr := [];
                for i = 1 to len ptp_l do
                  def ecid = CI`PushCGType(ptp_l(i));
                      tse = mk_AS`TupleSelectExpr(expr, mk_AS`NumLit(i, ncid), ecid);
                      e = ConvertTypeJudgementExprAS(tse, tp_l(i))
                  in
                    if e <> nil
                    then e_l := e_l ^ [e]
                    else allOk := false and allOk;
                if allOk
                then 
                  (dcl e : AS`Expr := e_l(len e_l),
                       p_l : seq of AS`PatternName := [];
                   for i = len e_l - 1 to 1 by -1 do
                     let e2 = mk_AS`BinaryExpr(e_l(i), <AND>, e, cid)
                     in e := e2;
                   for i = 1 to len e_l do
                     def tcid = CI`PushCGType(ptp_l(i))
                     in p_l := p_l ^ [ mk_AS`PatternName(nil, nil, tcid) ];
                   let ca1 = mk_AS`CaseAltn([mk_AS`TuplePattern(p_l, pcid)], e, cid)
                   in return mk_AS`CasesExpr(expr, [ca1], mk_AS`BoolLit(false, cid), cid))
                else return nil;
                ),
      -- is_(expr, seq of T) ==
      --   cases expr:
      --     - ^ - -> forall elem in set elems expr & is_(elem, T),  -- for Seq0Type
      --     [-] ^ - -> forall elem in set elems expr & is_(elem, T),-- for Seq1Type
      --     others -> false
      --   end
      mk_AS`Seq0Type(elemtp,-),
      mk_AS`Seq1Type(elemtp,-) ->
         def bcid = CI`PushCGType(mk_REP`BooleanTypeRep());
             seqtp = CGAUX`FindSeqElemType(CGAUX`FindType(expr));
             ecid = CI`PushCGType(seqtp);
             elemId = BC`GiveName("elem");
             elem = mk_AS`Name([elemId.id], ecid);
             pid_m = {elem |-> seqtp}
         in
          (CI`SetPidM(bcid, pid_m);
           def pred = ConvertTypeJudgementExprAS(elem, elemtp)
           in if pred <> nil
              then
                def scid = CI`PushCGType(mk_REP`SetTypeRep(seqtp));
                    msb = mk_AS`MultSetBind([mk_AS`PatternName(elem, nil, ecid)],
                                            mk_AS`PrefixExpr(<SEQELEMS>, expr, scid),
                                            CI`NilContextId);
                    aoee = mk_AS`AllOrExistsExpr(<ALL>, [msb], pred, bcid);
                    p = if is_AS`Seq0Type(tp)
                        then mk_AS`PatternName(nil, nil, CI`NilContextId)
                        else mk_AS`SeqEnumPattern([mk_AS`PatternName(nil, nil, CI`NilContextId)],                              CI`NilContextId);
                    scp = mk_AS`SeqConcPattern(p,
                                               mk_AS`PatternName(nil, nil, CI`NilContextId),
                                               CI`NilContextId);
                    ca = mk_AS`CaseAltn([scp], aoee, cid)
                in return mk_AS`CasesExpr(expr, [ca], mk_AS`BoolLit(false, cid), cid)
              else return nil),
      -- is_(expr, set of T) ==
      --   cases expr:
      --     - union - -> forall elem in set expr & is_(elem, T),   -- for Set0Type
      --     {-} union - -> forall elem in set expr & is_(elem, T), -- for Set1Type
      --     others -> false
      --   end
      mk_AS`Set0Type(elemtp,-),
      mk_AS`Set1Type(elemtp,-) ->
         def bcid = CI`PushCGType(mk_REP`BooleanTypeRep());
             settp = CGAUX`FindSetElemType(CGAUX`FindType(expr));
             ecid = CI`PushCGType(settp);
             elemId = BC`GiveName("elem");
             elem = mk_AS`Name([elemId.id], ecid);
             pid_m = {elem |-> settp}
         in
          (CI`SetPidM(bcid, pid_m);
           def pred = ConvertTypeJudgementExprAS(elem, elemtp)
           in if pred <> nil
              then
                def msb = mk_AS`MultSetBind([mk_AS`PatternName(elem, nil, ecid)], expr, CI`NilContextId);
                    aoee = mk_AS`AllOrExistsExpr(<ALL>, [msb], pred, bcid);
                    p = if is_AS`Set0Type(tp)
                        then mk_AS`PatternName(nil, nil, CI`NilContextId)
                        else mk_AS`SetEnumPattern([mk_AS`PatternName(nil, nil, CI`NilContextId)],                              CI`NilContextId);
                    sup = mk_AS`SetUnionPattern(p,
                                                mk_AS`PatternName(nil, nil, CI`NilContextId),
                                                CI`NilContextId);
                    ca = mk_AS`CaseAltn([sup], aoee, cid)
                in return mk_AS`CasesExpr(expr, [ca], mk_AS`BoolLit(false, cid), cid)
              else return nil),
      -- is_(expr, map Td to Tr) ==
      --   cases expr:
      --     - munion -         -- for GeneralMap0Type and InjectiveMap0Type
      --     {-|->-} munion -   -- for GeneralMap1Type and InjectiveMap1Type
      --    -> forall e in set dom expr & is_(e, Td) and is_(narrow_(expr, map ? to ?)(e), Tr),
      --                        -- for GeneralMap0Type and GeneralMap1Type
      --    -> (forall e in set dom expr & is_(e, Td) and
      --          is_(narrow_(expr, map ? to ?)(e), Tr)) and card dom expr = card rng expr
      --                        -- for InjectiveMap0Type and InjectiveMap1Type
      --     others -> false
      --   end
      mk_AS`GeneralMap0Type(mapdomtp, maprngtp,-),
      mk_AS`GeneralMap1Type(mapdomtp, maprngtp,-),
      mk_AS`InjectiveMap0Type(mapdomtp, maprngtp,-),
      mk_AS`InjectiveMap1Type(mapdomtp, maprngtp,-) ->
         def bcid = CI`PushCGType(mk_REP`BooleanTypeRep());
             getp = CGAUX`FindType(expr);
             domtp = CGAUX`FindMapDomType(getp);
             rngtp = CGAUX`FindMapRngType(getp);
             domcid = CI`PushCGType(domtp);
             rngcid = CI`PushCGType(rngtp);
             mapcid = CI`PushCGType(mk_REP`GeneralMapTypeRep(domtp, rngtp));
             elemId = BC`GiveName("elem");
             elem = mk_AS`Name([elemId.id], domcid);
             pid_m = { elem |-> domtp }
         in
           (CI`SetPidM(bcid, pid_m);
            def ae = if is_REP`AllTypeRep(getp)
                     then 
                       let atp = mk_AS`AllType(CI`NilContextId),
                           gmt = mk_AS`GeneralMap0Type(atp, atp, CI`NilContextId)
                       in mk_AS`ApplyExpr(mk_AS`NarrowExpr(expr, gmt, mapcid), [elem], rngcid)
                     else mk_AS`ApplyExpr(expr, [elem], rngcid);
                pred1 = ConvertTypeJudgementExprAS(elem, mapdomtp);
                pred2 = ConvertTypeJudgementExprAS(ae, maprngtp)
            in
              if pred1 <> nil and pred2 <> nil
              then
                def scid = CI`PushCGType(mk_REP`SetTypeRep(domtp));
                    mdom = mk_AS`PrefixExpr(<MAPDOM>, expr, scid);
                    rcid = CI`PushCGType(mk_REP`SetTypeRep(rngtp));
                    mrng = mk_AS`PrefixExpr(<MAPRNG>, expr, rcid);
                    ncid = CI`PushCGType(mk_REP`NumericTypeRep(<NAT>));
                    msb = mk_AS`MultSetBind([mk_AS`PatternName(elem, nil, domcid)],
                                            mdom, CI`NilContextId);
                    aoee = mk_AS`AllOrExistsExpr(<ALL>,
                                                 [msb],
                                                 mk_AS`BinaryExpr(pred1, <AND>, pred2, bcid),
                                                 bcid);
                    cond = if is_AS`GeneralMap0Type(tp) or is_AS`GeneralMap1Type(tp)
                           then aoee
                           else mk_AS`BinaryExpr(aoee, <AND>,
                                  mk_AS`BinaryExpr(
                                    mk_AS`PrefixExpr(<SETCARD>,mdom,ncid),
                                    <EQ>,
                                    mk_AS`PrefixExpr(<SETCARD>,mrng,ncid),bcid),bcid);
                    p = if is_AS`GeneralMap0Type(tp) or is_AS`InjectiveMap0Type(tp)
                        then mk_AS`PatternName(nil, nil, CI`NilContextId)
                        else mk_AS`MapEnumPattern([mk_AS`MapletPattern(
                                 mk_AS`PatternName(nil, nil, CI`NilContextId),
                                 mk_AS`PatternName(nil, nil, CI`NilContextId),
                                 CI`NilContextId)],CI`NilContextId);
                    mmp = mk_AS`MapMergePattern(p,
                             mk_AS`PatternName(nil, nil, CI`NilContextId), CI`NilContextId);
                    ca = mk_AS`CaseAltn([mmp], cond, cid)
                 in return mk_AS`CasesExpr(expr, [ca], mk_AS`BoolLit(false, cid), cid)
              else return nil),
      mk_AS`TypeName(name,-) ->
#ifdef VDMPP
         if CGAUX`IsClass(name)
         then return mk_AS`IsOfClassExpr(name, expr, cid)
         else
#endif VDMPP
           def tdef = TPGEN`GetTypeDef(name)
           in
             if tdef <> nil
             then
               def e = ConvertTypeJudgementExprAS(expr, tdef.shape)
               in
                 if tdef.Inv <> nil and e <> nil
                 then
                   def ids = name.ids ++ { len name.ids |-> "inv_" ^ name.ids(len name.ids)};
                       tftr = mk_REP`TotalFnTypeRep([CGAUX`FromAS2RepType(tp)],
                                                    mk_REP`BooleanTypeRep());
                       fncid = CI`PushCGType(tftr);
                       invfn = mk_AS`Name(ids, fncid);
                       tn = mk_AS`TypeName(name, name.cid);
                       tnr = mk_REP`TypeNameRep(name);
                       ne = mk_AS`NarrowExpr(expr, tn, CI`PushCGType(tnr));
                       inve = mk_AS`ApplyExpr(invfn, [ne], cid)
                   in return mk_AS`BinaryExpr(e, <AND>, inve, cid)
                 else return e
             else return nil,

      others -> return nil
    end;
\end{vdm_al}

\subsection{Narrow Expression}

\begin{vdm_al}
CGNarrowExpr: AS`NarrowExpr * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGNarrowExpr(mk_AS`NarrowExpr(expr,type,-), mk_CGMAIN`VT(resvar,restp)) ==
  def rtp = CGAUX`FindType(expr);
      tp = TPGEN`RemoveInvType(CGAUX`FromAS2RepType(type))
  in
    if rtp <> nil
    then
      def mk_(tmpVar_v, stmts) = CGExprExcl(expr, "tmpVar", nil);
      in
       (dcl cast : CPP`Expr := tmpVar_v;
        if not CGAUX`IsSubType(rtp, tp)
        then
          if CPP`isCPP()
          then cast := DS`GenCastType(tp, tmpVar_v)
          else cast := DS`GenExplicitCast(tp, tmpVar_v, rtp);
        if stmts = []
        then return cast
        else return stmts ^ [BC`GenAsgnStmt(resvar, cast)])
    else return CGExpr'(expr, mk_CGMAIN`VT(resvar, restp));
\end{vdm_al}

\begin{vdm_al}
CGMacro: AS`Macro * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGMacro(mk_AS`Macro(tp,-), -) ==
  cases tp:
    <MACRO_FILE>  -> 
      if CPP`isCPP()
      then
        let ds = BC`GenFctCall(BC`GenIdentifier("string2wstring"), [BC`GenIdentifier("__"^"FILE__")])
        in return BC`GenFctCall(DS`GenStringType().tp, [ds])
      else
        let th = BC`GenClassInstanceCreationExpr(BC`GenIdentifier("Throwable"), []),
            gs = BC`GenFctCallObjMemAcc (BC`GenBracketedExpr(th), "getStackTrace", []),
            aa = BC`GenArrayApply(gs, BC`GenIntegerLit (0))
        in return BC`GenFctCallObjMemAcc(aa, "getFileName", []),
    <MACRO_LINE>  -> 
      if CPP`isCPP()
      then return DS`GenIntExpr(BC`GenIdentifier("__"^"LINE__"))
      else
        let th = BC`GenClassInstanceCreationExpr(BC`GenIdentifier("Throwable"), []),
            gs = BC`GenFctCallObjMemAcc (BC`GenBracketedExpr(th), "getStackTrace", []),
            aa = BC`GenArrayApply(gs, BC`GenIntegerLit (0))
        in return BC`GenFctCallObjMemAcc(aa, "getLineNumber", []),
    <MACRO_COLUMN> ->
      let colno = BC`GenIntegerLit (0)
      in return DS`GenIntExpr(colno),
    <MACRO_CLMOD> ->
      if CPP`isCPP()
      then
#ifdef VDMSL
        def clmod = CGAUX`GiveCurMASName();
#endif VDMSL
#ifdef VDMPP
        def clmod = CGAUX`GiveCurCASName();
#endif VDMPP
            mk_CPP`Identifier(ch_l,- ) = BC`Rename(clmod)
        in return BC`GenFctCall(DS`GenStringType().tp, [BC`GenStringLit(ch_l)])
      else
        let th = BC`GenClassInstanceCreationExpr(BC`GenIdentifier("Throwable"), []),
            gs = BC`GenFctCallObjMemAcc (BC`GenBracketedExpr(th), "getStackTrace", []),
            aa = BC`GenArrayApply(gs, BC`GenIntegerLit (0))
        in
          return BC`GenFctCallObjMemAcc(aa, "getClassName", []),
    <MACRO_FNOP> ->
      if CPP`isCPP()
      then
        let ds = BC`GenFctCall(BC`GenIdentifier("string2wstring"), [BC`GenIdentifier("__func__")])
        in return BC`GenFctCall(DS`GenStringType().tp, [ds])
      else
        let th = BC`GenClassInstanceCreationExpr(BC`GenIdentifier("Throwable"), []),
            gs = BC`GenFctCallObjMemAcc (BC`GenBracketedExpr(th), "getStackTrace", []),
            aa = BC`GenArrayApply(gs, BC`GenIntegerLit (0))
        in
          return BC`GenFctCallObjMemAcc(aa, "getMethodName", [])
  end;
\end{vdm_al}

\subsection{Tuple Select Expression}
The tuple select expression extracts a field from a tuple. It takes as
parameters:
\begin{description}
\item[\texttt{ts : AS\`TupleSelectExpr}] The tuple select expression to
be code generated.
\item[\texttt{vtv : CGMAIN\`VT}] The name and type of the result of the
expression.
\end{description}
The operation works as follows:
\begin{itemize}
\item The tuple expression is code generated giving a result in
\texttt{tupleName} and generated code in \texttt{tupleCode}. If the
result can be computed in an expression, \texttt{tupleCode} will be
empty. In this case the expression is delivered in
\texttt{tupleName}.
\item If the type of the tuple is not a product type,
\texttt{tupleName} needs to be cast to the Tuple type. This is done
via the binding to \texttt{tupleVal}.
\item The name of the result is declared and initialized to be
null. Note that it can not be directly initialized since the tuple
expression may contain arbitrary code. If \texttt{tupleCode} is empty
then the result name is not declared, since it is not needed.
\item The field selector is code generated.
\item The field selection is code generated, and the result is cast to
the expected result type. This is then assigned to the name of the
result.
\end{itemize}
\begin{vdm_al}
  CGTupleSelectExpr : AS`TupleSelectExpr * CGMAIN`VT ==> (seq of CPP`Stmt) | CPP`Expr
  CGTupleSelectExpr(mk_AS`TupleSelectExpr(tuple,no,-), mk_CGMAIN`VT(resvar,resTp)) ==
    def tupleTp = CGAUX`FindType(tuple);
        mk_(tupleName,tupleCode) = CGExprExcl( tuple, "tuple", tupleTp);
        selector = BC`GiveName("fieldsel");
        selObj = CGLiteral(no, mk_CGMAIN`VT(selector, mk_REP`NumericTypeRep(<NATONE>)));
    in
     (dcl selVal : CPP`Expr := DS`GenGetValue(selObj, mk_REP`NumericTypeRep(<NATONE>)),
          tupleVal : CPP`Expr := tupleName;
      if CPP`isJAVA() and CGMAIN`get_longs_option()
      then selVal := BC`GenCastExpr(DS`GenSmallIntType(), selVal);

      if not is_REP`ProductTypeRep(tupleTp)
      then
        if CPP`isCPP()
        then tupleVal := BC`GenFctCall(DS`GenProductType().tp, [tupleName])
        else tupleVal := DS`GenCastProduct(tupleName);

      def tupleCall = BC`GenFctCallObjMemAcc(tupleVal,"GetField",[selVal]);
          expr = DS`GenCastType(resTp,tupleCall);
      in
        if tupleCode = []
        then return expr
        else return tupleCode ^ [BC`GenAsgnStmt(resvar, expr)];
     );
\end{vdm_al}

\subsection{Apply Expression}
\label{sec:apply}

In this section specification of code generation of apply expression
is described.  An apply expression is used for looking up in a map,
indexing a sequence and finally for calling a function.

Consider the three examples of all three ways of using an apply expression:

An example of a map apply:
\begin{verbatim}
{ 1|-> 3, 3|-> 4}(3)
\end{verbatim}

The corresponding pseudo code of the map apply is listed below,
assuming that the result of the evaluation of the map apply is to be
assigned to the temporary variable $resVar$:

\begin{verbatim}
Map tmpmap; // Declaration of a temporary variable to contain
            // the evaluation of the map.
...CGExpr( "{ 1 |-> 3, 3 |-> 4}", mk_CGMAIN`VT( tmpmap, "Map") )  //Generate code to evaluate map.
Int tmpVar;
...CGExpr( "3", mk_CGMAIN`VT( tmpVar, "Int" ) ) // Generate code to evaluate "3".
resVar = tmpmap[tmpVar];
\end{verbatim}


An example of a sequence index:
\begin{verbatim}
let l = [ 1, 4, 6]
in l(3)
\end{verbatim}

The corresponding pseudo code is listed below:

\begin{verbatim}
Sequence tmp_l;
...CGExpr( "[1, 4, 6]", mk_CGMAIN`VT( tmp_l, "Sequence") // Generate code to evaluate sequence
Int tmpVar;
...CGExpr( "3", mk_CGMAIN`VT( tmp_l, "Sequence" ) // Generate to evaluate "3"
resVar = tmp_l[tmp_l];
\end{verbatim}


An example of a function apply:
\begin{verbatim}
let f: nat * set of nat-> nat
    f(n, {l}) == n+l+3
in f(3, {3})
\end{verbatim}

The corresponding pseudo code is listed below:


\begin{verbatim}
Int tmpVar1;      // Evaluation of the first paramter.
...CGExpr( "3", mk_CGMAIN`VT( tmpVar1, "Int" ) ) ;
Set tmpVar2;  // Evaluation of the second parameter.
...CGExpr( "{3}", mk_CGMAIN`VT( tmpVar2, "Set" ) );
resVar = f ( tmpVar1, tmpVar2 );
\end{verbatim}


Beside generating code for apply expressions the operation {\em
CGApplyExpr} also generates code for parts of state designators.
The generated pseudo code for state designators for the assign statement:

\begin{verbatim}
m(1)(2).b(3) := 49;
\end{verbatim}

The corresponding pseudo code is (see also Section \ref{sec:asgnstmt}):

\begin{verbatim}
Sequence level2 := m(1);
Map level3 := level2(2);
....
\end{verbatim}

The {\em CGApplyExpr} generates code for \verb+level2(2)+. In this case the
expression that should be applied (\verb+level2+) is a temporary variable.



The operation {\em CGApplyExpr} takes following parameters:
\begin{description}
\item[ae:] The apply expression.

\item[resVar\_v:] The variable and type of the variable that the
result of the apply expression should be assigned.

\item[expr1:] In the case that the operation {\em CGApplyExpr}
generates code for the state designator it takes the name of the
temporary variable.

\item[type1:] This is the type of the temporary variable {\em expr1}.

\item[sd:] A boolean representing if {\em CGApplyExpr} is called
as part of computing code for a state designator construct.

\end{description}


The specification of $CGApplyExpr$ is listed below:

\begin{vdm_al}
CGApplyExpr: AS`ApplyExpr * CGMAIN`VT * [CPP`Name] * [REP`TypeRep | set of REP`TypeRep] * bool ==>
               seq of CPP`Stmt | CPP`Expr
CGApplyExpr(ae, resVar_v, expr1, type1, sd) ==
  let mk_AS`ApplyExpr(expr, -, -) = ae
  in
   (dcl ti : [REP`TypeRep] := type1;
    if expr1 = nil
    then ti := CGAUX`FindType(expr);
    cases true:
     (is_REP`GeneralMapTypeRep(ti)),
     (is_REP`InjectiveMapTypeRep(ti)) -> CGMapApplyExpr(ae, resVar_v, expr1, type1, sd),
     (is_REP`SeqTypeRep(ti))          -> CGSeqApplyExpr(ae, resVar_v, expr1, type1),
     (is_REP`OpTypeRep(ti)),
     (is_REP`PartialFnTypeRep(ti)),
     (is_REP`TotalFnTypeRep(ti))      -> CGFctApplyExpr(ae, resVar_v),
     (is_REP`UnionTypeRep(ti))        -> CGUnionTypeApply(ae, resVar_v, expr1, type1, sd),
#ifdef VDMPP
     (is_REP`OverTypeRep(ti))         -> CGFctApplyExpr(ae, resVar_v),
#endif VDMPP
     others -> error
    end;
   );

\end{vdm_al}

The operations $CGMapApplyExpr$, $CGSeqApplyExpr$, $CGFctApplyExpr$
and $CGUnionTypeApply$ are auxiliary operations to $CGApplyExpr$,
which generates code corresponding to the three different cases of
apply (map, seq and function apply).

\begin{vdm_al}
CGMapApplyExpr: AS`ApplyExpr * CGMAIN`VT * [CPP`Name] * [REP`TypeRep] * bool ==> seq of CPP`Stmt | CPP`Expr
CGMapApplyExpr(mk_AS`ApplyExpr(expr,[par], -), mk_CGMAIN`VT(resVar_v,-), expr1, expr1_type, sd) ==
 (dcl tmpmap_v : [CPP`Expr] := expr1,
      e_stmt : seq of CPP`Stmt := [],
      tmpmapType : [REP`TypeRep] := expr1_type,
      rb : seq of CPP`Stmt := [];
  if expr1 = nil
  then
    def mk_(tmpmap_v', e_stmt') = CGExprExcl(expr, "tmp_m", nil)
    in
     (tmpmap_v := tmpmap_v';
      e_stmt := e_stmt';
      tmpmapType := CGAUX`FindType( expr ));
  def mk_(tmppar_v, par_stmt) = CGExprExcl(par, "tmppar", nil);
      mk_(-, rngType) = DS`FindMapDomRng(tmpmapType);
      cond = DS`GenDomExists(tmpmap_v, tmppar_v);
      alt1 = DS`GenMapApply(mk_CGMAIN`VT(tmpmap_v, tmpmapType), tmppar_v)
  in if CGAUX`IsMapType(rngType) or
        CGAUX`IsSeqType(rngType) or
        is_REP`CompositeTypeRep(rngType) or
        not sd
     then
      (dcl mapapply : CPP`Expr := alt1;
       if sd
       then
        (dcl alt2 : CPP`Expr;
         cases true:
           (CGAUX`IsMapType(rngType))         -> alt2 := DS`GenEmptyMapExpr(),
           (CGAUX`IsSeqType(rngType))         -> alt2 := DS`GenEmptySeqExpr(),
           (is_REP`CompositeTypeRep(rngType)) -> alt2 := DS`GenEmptyRecordExpr(rngType.nm)
         end;
         BC`GenBracketedExpr(BC`GenCondExpr(cond, alt1, alt2)));
       rb := e_stmt ^ par_stmt;
       if rb = []
       then return mapapply
       else rb := rb ^ [ BC`GenAsgnStmt( resVar_v, mapapply ) ]
      )
     else
       def alt2 = DS`GenEmptyMapExpr();
           asgn1 = BC`GenAsgnStmt(resVar_v, alt1);
           asgn2 = BC`GenAsgnStmt(resVar_v, alt2)
       in
         rb := e_stmt ^ par_stmt ^ [ BC`GenIfStmt( cond, asgn1, asgn2) ];
  return rb
);
\end{vdm_al}


\begin{vdm_al}
CGSeqApplyExpr: AS`ApplyExpr * CGMAIN`VT * [CPP`Name] * [REP`TypeRep] ==> seq of CPP`Stmt | CPP`Expr
CGSeqApplyExpr( mk_AS`ApplyExpr( expr, [ par ], - ), mk_CGMAIN`VT( resVar_v, restp), expr1, type1 ) ==
 (dcl tmpseq_v : [CPP`Expr] := expr1,
      e_stmt : seq of CPP`Stmt := [],
      tmpseqType : [REP`TypeRep] := type1;
  if expr1 = nil
  then
   (def mk_(tmp_expr, tmp_stmt) = CGExprExcl(expr, "tmp_l", nil)
    in  
      if is_CPP`Identifier(tmp_expr)
      then
       (tmpseq_v := tmp_expr;
        e_stmt := tmp_stmt)
      else
       (tmpseq_v := BC`GiveName("argTmp");
        e_stmt := tmp_stmt ^ DS`GenDeclSeq (tmpseq_v, tmp_expr));
    tmpseqType := CGAUX`FindType( expr ));
  def mk_(tmppar_v, par_stmt) = CGExprExcl(par, "tmppar", nil);
      nattype = mk_REP`NumericTypeRep(<NAT>);
      tmpparType = CGAUX`FindType( par );
  in
   (dcl rb : seq of CPP`Stmt := e_stmt ^ par_stmt,
        seqexpr : CPP`Expr,
        casting : CPP`Expr := tmppar_v;
    if CPP`isCPP()
    then if CGAUX`IsSeqType(tmpseqType)
         then seqexpr := tmpseq_v
         else seqexpr := DS`GenCastSeq( tmpseq_v, nil )
    else if CGAUX`IsSeqType(tmpseqType) or CGAUX`IsStringType(tmpseqType)
         then seqexpr := tmpseq_v
         else if CGAUX`IsPossibleStringType(tmpseqType)
              then seqexpr := DS`GenCastString( tmpseq_v)
              else seqexpr := DS`GenCastSeq( tmpseq_v, nil );
    if not CGAUX`IsIntType(tmpparType)
    then if CPP`isCPP()
         then casting := DS`GenCastType( nattype, tmppar_v)
         else casting := DS`GetIntVal(tmppar_v);
    if CGAUX`IsIntType( tmpparType )
    then
      def parapply = DS`GenGetValue( casting, tmpparType );
      in
       (dcl seqapply : CPP`Expr;
        if CPP`isCPP()
        then seqapply := DS`GenSeqApply(restp,seqexpr,parapply)
        else if CGAUX`IsPossibleStringType(tmpseqType)
             then seqapply := DS`GenSeqApplyString(seqexpr,parapply)
             else seqapply := DS`GenSeqApply(restp,seqexpr,parapply);
        if CGAUX`CheckSeqApply(mk_(seqexpr, casting))
        then
         (dcl l_check : CPP`Expr;
          if CPP`isCPP()
          then l_check := BC`GenFctCallObjMemAcc(seqexpr, "OutOfRange", [parapply])
          else
            def l_lcheck = BC`GenGt(BC`GenIntegerLit(1), parapply);
            in
             (dcl l_rcheck : CPP`Expr;
              if CGAUX`IsPossibleStringType(tmpseqType)
              then l_rcheck := BC`GenGt(parapply, DS`GenLenString_int(seqexpr))
              else l_rcheck := BC`GenGt(parapply, DS`GenLen_int(seqexpr));
              l_check := BC`GenLogOr(BC`GenBracketedExpr(l_lcheck), BC`GenBracketedExpr(l_rcheck)));
          def l_then = BC`GenBlock([CGAUX`RunTime("Illegal index")])
          in rb := rb ^ [BC`GenIfStmt(l_check, l_then, nil)]);
        rb := rb ^ [BC`GenAsgnStmt(resVar_v, seqapply)])
    else
      def parapply = DS`GenGetValue( casting, nattype );
          isnat = GenIsNat( tmppar_v);
          rre = CGAUX`RunTime("An integer was expected in apply expression" )
      in
       (dcl seqapply : CPP`Expr;
        if CPP`isCPP()
        then seqapply := DS`GenSeqApply(restp,seqexpr,parapply)
        else if CGAUX`IsPossibleStringType(tmpseqType)
             then seqapply := DS`GenSeqApplyString(seqexpr,parapply)
             else seqapply := DS`GenSeqApply(restp,seqexpr,parapply);
        rb := rb ^ [ BC`GenIfStmt( isnat,
                                   BC`GenBlock([BC`GenAsgnStmt( resVar_v, seqapply )]),
                                   BC`GenBlock([rre]))]);
      return rb);
 );
\end{vdm_al}

\begin{vdm_al}
GenIsNat: CPP`Name ==> CPP`Expr
GenIsNat( name ) ==
( def ntype = mk_REP`NumericTypeRep( <NAT> );
      istype = DS`GenIsType( name, ntype );
      btype = mk_REP`BooleanTypeRep()
  in return DS`GenGetValue( istype, btype);
);
\end{vdm_al}

For function apply expressions, if Java is being generated and the
function name is prefixed by a class, this is code generated using the
function GenMethodInvoke. If the class prefix is the current class,
then \texttt{this} is generated; otherwise the class prefix
\texttt{super} is generated. Since this is Java, there can only be one
class supplying a definition of this function, so the unique
superclass ought to locate this function.

\begin{vdm_al}
CGFctApplyExpr: AS`ApplyExpr * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGFctApplyExpr(mk_AS`ApplyExpr(expr, par_l, cid), vt) ==
  cases expr:
    mk_AS`FctTypeInstExpr(expr, -, -),
    mk_AS`Name(-, -) ->
#ifdef VDMSL
      let mk_AS`Name(-, -) = expr in
#endif VDMSL
#ifdef VDMPP
      let mk_AS`Name(ids, cidnm) = expr in
#endif VDMPP
       (if FD`LookUpLocFct(expr)
        then
         (CGAUX`SetNotSupportedException(true);
          return [CGAUX`NotSupported("function value or local function definitions")])
        elseif CGAUX`IsFctType(CI`GetTypeInfo(cid))
        then
         (CGAUX`SetNotSupportedException(true);
          return [CGAUX`NotSupported("Higher order functions")])
#ifdef VDMPP
        elseif CPP`isJAVA() and (len ids > 1)
        then
         (dcl obj : CPP`Expr,
              vt' : [CGMAIN`VT] := vt;
          if hd ids = CGAUX`GiveCurCName()
          then obj := DS`GenThis()
          elseif CGAUX`IsSuperClass(CGAUX`GiveCurCASName(), mk_AS`Name([hd ids], cidnm))
          then obj := DS`GenSuper()
          else obj := BC`GenIdentifier(CGAUX`CleanIdentifier(hd ids));
          if vt.type = nil or (is_REP`UnitTypeRep (vt.type))
          then vt' := nil;
          def mthdnm = mk_AS`Name(tl ids, cidnm);
              ti = mk_REP`ObjRefTypeRep(mk_AS`Name([hd ids], cidnm));
              objvt = mk_CGMAIN`VT(obj, ti)
          in return GenMethodInvoke(objvt, vt', false, mk_(mthdnm, par_l), false)
         )
#endif VDMPP
        else
          let mk_CGMAIN`VT(resVar_v, restype) = vt
          in
           (dcl fctname : CPP`Expr;
          if CPP`isCPP()
            then fctname := BC`Rename(expr)
            else
              if CGAUX`IsSuperClass(CGAUX`GiveCurCASName(), expr)
              then fctname := DS`GenSuper()
              elseif CGAUX`GiveCurCASName() = expr
              then fctname := DS`GenThis()
              else fctname := BC`Rename(expr);
              if par_l = []
              then return BC`GenFctCall(fctname, [])
              else
                def tmptp = CGAUX`FindType(expr);
                in
                 (dcl exprtp : [REP`TypeRep],
                      fntype : [REP`TypeRep],
                      rb_l : seq of CPP`Stmt := [],
                      var_l : seq of CPP`Expr := [],
                      index : int := 0;
                  cases tmptp: 
                    nil -> exprtp := nil,
#ifdef VDMPP
                    mk_REP`OverTypeRep(-) -> exprtp := GetOverFNOP(TPGEN`RemoveInvType(tmptp), par_l),
#endif VDMPP
                    others -> exprtp := TPGEN`RemoveInvType(tmptp)
                  end;
                  cases exprtp:
                    mk_REP`PartialFnTypeRep(-,fnrng) -> fntype := fnrng,
                    mk_REP`TotalFnTypeRep(-,fnrng)   -> fntype := fnrng,
                    mk_REP`OpTypeRep(-,oprng)        -> fntype := oprng,
                    others                           -> fntype := nil
                  end;

                  for par in par_l do
                   (dcl eval : CPP`Expr;
                    index := index + 1;
                    def mk_(evalx, eval_stmt) = CGExprExcl(par, "par", nil)
                    in
                     (eval := evalx;
                      if CPP`isCPP()
                      then
                       (if is_AS`ApplyExpr(par) and is_CPP`CastExpr(eval)
                        then eval := eval.expr;
                        let gtype = BC`GenGeneric()
                        in
                          cases exprtp:
                            mk_REP`PartialFnTypeRep(fndom,-),
                            mk_REP`TotalFnTypeRep(fndom,-),
                            mk_REP`OpTypeRep(fndom,-) ->
                             (dcl gtp : REP`TypeRep := CGAUX`FindType(par);
                              if CGAUX`IsSubType(gtp, fndom(index))
#ifdef VDMPP
                                  and not CGAUX`IsSuperClass(CGAUX`GiveCurCASName(), expr)
#endif VDMPP
                              then (rb_l := rb_l ^ eval_stmt;
                                   var_l := var_l ^ [eval];)
                              elseif DS`GenType(gtp) = gtype
                              then (rb_l := rb_l ^ eval_stmt;
                                   var_l := var_l ^ [eval];)
                              else (rb_l := rb_l ^ eval_stmt;
                                    def lgtp = CGAUX`LOT(gtp);
                                        ldomtp = CGAUX`LOT(fndom(index))
                                    in if CGAUX`IsSubType(lgtp, ldomtp) or
                                          CGAUX`IsCompositeType(lgtp) and CGAUX`IsCompositeType(ldomtp) or
                                          CGAUX`IsSeqType(lgtp) and CGAUX`IsSeqType(ldomtp) or 
                                          CGAUX`IsSetType(lgtp) and CGAUX`IsSetType(ldomtp) or 
                                          CGAUX`IsIntType(lgtp) and CGAUX`IsIntType(ldomtp)
                                       then var_l := var_l ^ [eval]
                                       else var_l := var_l ^ [BC`GenCastExpr(gtype, eval)])
                             ),
                            others -> (rb_l := rb_l ^ eval_stmt;
                                       var_l := var_l ^ [BC`GenCastExpr(gtype, eval)])
                            end
                       )
                      else -- java
                        cases exprtp:
                          mk_REP`OpTypeRep(fndom,-),
                          mk_REP`PartialFnTypeRep(fndom,-),
                          mk_REP`TotalFnTypeRep(fndom,-) -> def tp1 = fndom(index);
                                                                tp2 = CGAUX`RemoveNil(CGAUX`FindType(par)) in
                                                            (rb_l := rb_l ^ eval_stmt;
                                                             var_l := var_l ^ [DS`GenExplicitCast(tp1,eval,tp2)]),
                          others -> (rb_l := rb_l ^ eval_stmt;
                                     var_l := var_l ^ [eval])
                        end;
                     );
                   ); -- end of for loop
                  let fcCall = BC`GenFctCall(fctname, var_l)
                  in
                    if CPP`isCPP()
                    then if rb_l = []
                         then return fcCall
                         else return rb_l ^ [BC`GenAsgnStmt(resVar_v, fcCall)]
                    else
                     (dcl cast : CPP`Expr := fcCall;
                      if not is_REP`UnitTypeRep(restype)
                      then cast := DS`GenExplicitCast(restype, fcCall, fntype );
                      if rb_l = []
                      then return cast
                      else return rb_l ^ [BC`GenAsgnStmt(resVar_v, cast)]);
             );
         )
       ),
#ifdef VDMPP
    mk_AS`FieldSelectExpr(-,-,-) -> return CGApplyFieldSel (expr,par_l,vt),
#endif VDMPP
    others -> return CGExpr(expr, vt)
  end;
\end{vdm_al}

#ifdef VDMPP
\begin{vdm_al}
GetOverFNOP: REP`OverTypeRep * seq of AS`Expr ==> [REP`PartialFnTypeRep | REP`TotalFnTypeRep | REP`OpTypeRep]
GetOverFNOP(mk_REP`OverTypeRep(tp_s), par_l) ==
  let tps = { tp | tp in set tp_s & cases tp:
                                      mk_REP`PartialFnTypeRep(fndom,-) -> len fndom = len par_l,
                                      mk_REP`TotalFnTypeRep(fndom,-)   -> len fndom = len par_l,
                                      mk_REP`OpTypeRep(opdom,-)        -> len opdom = len par_l,
                                      others -> false
                                    end}
  in
    cases tps:
      {}     -> return nil,
      {tp}   -> return tp,
      others -> (for all tp in set tps do
                   let fdom = cases tp:
                                mk_REP`PartialFnTypeRep(fndom,-) -> fndom,
                                mk_REP`TotalFnTypeRep(fndom,-)   -> fndom,
                                mk_REP`OpTypeRep(opdom,-)        -> opdom,
                                others                           -> undefined
                              end
                   in
                     if forall i in set inds fdom & (CGAUX`IsSubType(CGAUX`FindType(par_l(i)), fdom(i)) or
                                           CGAUX`IsIntType(CGAUX`FindType(par_l(i))) and CGAUX`IsIntType(fdom(i)))
                     then return tp;
                 return nil;)
    end;
             
CGApplyFieldSel: AS`FieldSelectExpr * seq of AS`Expr * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGApplyFieldSel (fexpr,par_l, vt) ==
  def tp = CGAUX`FindType (fexpr.rec) in
    cases true:
      (is_REP`ObjRefTypeRep(tp)),
      (CGAUX`IsObjRefType (tp)),
      (is_REP`UnionTypeRep (tp)) -> CGObjRef (fexpr,par_l,vt),
      others -> error
    end;

CGObjRef : AS`FieldSelectExpr * seq of AS`Expr * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGObjRef (fexpr,par_l, vt) ==
  let vt' = if vt.type = nil or (is_REP`UnitTypeRep (vt.type))
            then nil
            else vt,
      fexpr_nm = if is_AS`FctTypeInstExpr(fexpr.nm)
                 then fexpr.nm.polyfct
                 else fexpr.nm,
      fexpr_cid = if is_AS`FctTypeInstExpr(fexpr.nm)
                  then fexpr_nm.cid
                  else fexpr.cid
  in
  cases true:
    (is_AS`Name (fexpr.rec)) -> def ti = CGAUX`FindType (fexpr.rec);
                                    obj = BC`Rename (fexpr.rec)
                                in
                                  if CGMAIN`get_j2v_option() and is_REP`ObjRefTypeRep(ti) and
                                     ( CGAUX`IsAbstractClass(ti.nm) or CGMAIN`isInterface(ti.nm)) and
                                     ( fexpr_nm.ids = ["IsNil"] and len par_l = 0)
                                  then
                                    def eqExpr = BC`GenEq(obj, DS`GenNullExpr());
                                        isNilExpr = DS`GenInvokeExpr(ti, obj, BC`Rename(fexpr_nm), []);
                                        getValExpr = DS`GenGetValue(isNilExpr, mk_REP`BooleanTypeRep());
                                        orExpr = BC`GenLogOr(eqExpr, getValExpr)
                                    in
                                      return DS`GenBoolExpr(orExpr)
                                  else
                                    def objvt  = mk_CGMAIN`VT(obj,ti);
                                    in
                                     (dcl mthdnm : AS`Name;
                                      if CPP`isCPP()
                                      then mthdnm := mk_AS`Name(fexpr_nm.ids, fexpr_cid)
                                      else if len fexpr_nm.ids > 1
                                           then mthdnm := mk_AS`Name(tl fexpr_nm.ids, fexpr_cid)
                                           else mthdnm := mk_AS`Name(fexpr_nm.ids, fexpr_cid);
                                      return GenMethodInvoke(objvt, vt', false, mk_(mthdnm,par_l), false)
                                      ),
    (is_AS`SelfExpr (fexpr.rec)) -> if CPP`isCPP()
                                    then
                                      let mthdnm = mk_AS`Name(fexpr_nm.ids, fexpr_cid)
                                      in return GenMethodInvoke (nil, vt', false, mk_(mthdnm, par_l), false)
                                    else
                                     (dcl obj : CPP`Expr;
                                      if len fexpr_nm.ids > 1
                                      then if ((hd fexpr_nm.ids) = CGAUX`GiveCurCName())
                                           then obj := DS`GenThis()
                                           else obj := DS`GenSuper()
                                      else obj := DS`GenThis();
                                      def mthdnm = if len fexpr_nm.ids > 1
                                                   then mk_AS`Name(tl fexpr_nm.ids, fexpr_cid)
                                                   else mk_AS`Name(fexpr_nm.ids, fexpr_cid);
                                          ti = CGAUX`FindType (fexpr.rec);
                                          objvt = mk_CGMAIN`VT(obj,ti)
                                      in
                                        return GenMethodInvoke (objvt, vt', false, mk_(mthdnm,par_l), false)
                                      ),
     others -> def mthdnm = mk_AS`Name(fexpr_nm.ids, fexpr_cid);
                   ti  = CGAUX`FindType (fexpr.rec);
                   mk_(tmpobj, cgexpr) = CGExprExcl(fexpr.rec, "tmpObj", ti)
               in
                 if CPP`isJAVA() and is_AS`NewExpr(fexpr.rec)
                 then
                   let objvt = mk_CGMAIN`VT (tmpobj,ti)
                   in return cgexpr ^ GenMethodInvoke (objvt, vt', false, mk_(mthdnm, par_l), false)
                 else
                   def obj = BC`GiveName ("obj");
                       --declObj = DS`GenDecl (ti, obj, BC`GenAsgnInit(tmpobj));
                       declObj = DS`GenDeclInit (ti, obj, tmpobj);
                       objvt = mk_CGMAIN`VT (obj,ti)
                   in
                     return cgexpr ^ declObj ^ GenMethodInvoke (objvt, vt', false, mk_(mthdnm, par_l), false)
  end;

  GenMethodInvoke: [CGMAIN`VT] * [CGMAIN`VT] * bool * (AS`Name * seq of AS`Expr) * bool ==> seq of CPP`Stmt
  GenMethodInvoke(obj,res,res_decl,mi,last) ==
    if obj = nil
    then GenSimpleInvoke(obj,res,res_decl,mi,last)
    else
      let mk_CGMAIN`VT(nm,oti) = obj
      in
        if is_REP`ObjRefTypeRep(oti)
        then GenSimpleInvoke(obj,res,res_decl,mi,last)
        elseif CPP`isJAVA() and is_REP`ObjRefTypeRep(CGAUX`RemoveNil(oti))
        then GenSimpleInvoke(mk_CGMAIN`VT(nm,CGAUX`RemoveNil(oti)),res,res_decl,mi,last)
        else GenUnionInvoke(obj,res,res_decl,mi,last);

  GenSimpleInvoke: [CGMAIN`VT] * [CGMAIN`VT] * bool * (AS`Name * seq of AS`Expr) * bool ==> seq of CPP`Stmt
  GenSimpleInvoke(obj,res,res_decl,mi,last) ==
    def mk_(mthd,arg_l) = mi;
        mk_(pdecl_l,id_l) = GenParSequence(arg_l, CGAUX`FindType(mthd))
    in
     (dcl fcall : CPP`Expr,
          check : seq of CPP`Stmt := [],
          stmts : seq of CPP`Stmt;
      if obj <> nil
      then
        def mk_CGMAIN`VT(id, ti) = obj;
        in
         (--fcall := DS`GenInvokeExpr(ti, id', BC`Rename(mthd), id_l);
          dcl id' : CPP`Expr := id,
              mthdid : CPP`Name := BC`Rename (mthd);
          if not CGAUX`IsObjRefType(ti)
          then id' := BC`GenCastExpr(DS`GenObjRefType(nil), id);
          if CPP`isJAVA() and is_REP`ObjRefTypeRep(ti)
          then
            def clnm = hd ti.nm.ids;
                mid = CGAUX`CleanIdentifier(hd mthd.ids)
            in
              if "JDK_" = clnm(1, ..., 4)
              then
               (if "vdm_" = mid(1, ..., 4)
                then
                  mthdid := BC`GenIdentifier(mid(6, ..., len mid));
                (dcl id_l' : seq of CPP`Expr := id_l;
                 if clnm = "JDK_Calendar"
                 then 
                   if mid in set { "add", "set", "get" }
                   then
                    id_l' := [ DS`GenGetValue(id_l(i), mk_REP`NumericTypeRep(<INTEGER>)) | i in set inds id_l ];
                  fcall := DS`GenInvokeExpr(ti, id', mthdid, id_l');
                ))
              else
                fcall := DS`GenInvokeExpr(ti, id', mthdid, id_l)
          else
            fcall := DS`GenInvokeExpr(ti, id', mthdid, id_l);
          if CPP`isCPP()
          then
            (def exprtp = CGAUX`FindType(mthd);
             in
              (dcl exprtp' : [REP`TypeRep] := exprtp;
               if is_REP`OverTypeRep(exprtp)
               then exprtp' := GetOverFNOP(exprtp, arg_l);
               def fndom = cases exprtp':
                           mk_REP`PartialFnTypeRep(fndom, -) -> fndom,
                           mk_REP`TotalFnTypeRep(fndom, -)   -> fndom,
                           mk_REP`OpTypeRep(opdom, -)        -> opdom,
                           others                            -> []
                         end
             in
               if fndom <> [] and len fndom = len arg_l and len fndom = len fcall.arg
               then
                 let mk_CPP`FctCall(fct, arg, cid) = fcall
                 in
                  (dcl new_arg : seq of CPP`Expr := [];
                   for i = 1 to len arg do
                     def e = arg(i);
                         ti = CGAUX`FindType(arg_l(i))
                    in
                       if is_CPP`CastExpr(e) and ti <> nil and CGAUX`IsSubType(ti, fndom(i))
                       then new_arg := new_arg ^ [e.expr]
                       else new_arg := new_arg ^ [e];
                    fcall := mk_CPP`FctCall(fct, new_arg, cid))
              )
            );
         )
      else
        fcall := BC`GenFctCall(BC`Rename(mthd), id_l);

      if CPP`isJAVA()
      then
       (if res <> nil
        then let mk_CGMAIN`VT(-,tp) = res
             in
               def exprtp = CGAUX`FindType(mthd);
               in
                (dcl exprtp' : [REP`TypeRep] := exprtp,
                     fnrng : [REP`TypeRep] := nil;
                 if is_REP`OverTypeRep(exprtp)
                 then exprtp' := GetOverFNOP(exprtp, arg_l);
                 cases exprtp':
                   mk_REP`PartialFnTypeRep(-,r) -> fnrng := CGAUX`RemoveNil(CGAUX`CleanFlatType(r)),
                   mk_REP`TotalFnTypeRep(-,r)   -> fnrng := CGAUX`RemoveNil(CGAUX`CleanFlatType(r)),
                   mk_REP`OpTypeRep(-,r)        -> fnrng := CGAUX`RemoveNil(CGAUX`CleanFlatType(r))
                 end;
                 fcall := DS`GenExplicitCast(tp, fcall, fnrng);
                  -- hack TODO: to check object is JDK_ class
                 if obj <> nil
                 then 
                   let mk_CGMAIN`VT(-, ti) = obj
                   in
                     cases ti:
                       mk_REP`ObjRefTypeRep(mk_AS`Name([clnm], -))
                            -> fcall := CGAUX`CheckJavaPrimitiveType(fcall, clnm, hd mi.#1.ids),
                       others -> skip
                     end
                  else
                    def mk_AS`Name([clnm], -) = CGAUX`GiveCurCASName()
                    in
                      fcall := CGAUX`CheckJavaPrimitiveType(fcall, clnm, hd mi.#1.ids)
                ) 
       )
      else -- CPP
        def exprtp = CGAUX`FindType(mthd);
        in
         (dcl exprtp' : [REP`TypeRep] := exprtp;
          if is_REP`OverTypeRep(exprtp)
          then exprtp' := GetOverFNOP(exprtp, arg_l);
          def fnrng = cases exprtp':
                      mk_REP`PartialFnTypeRep(-,r) -> r,
                      mk_REP`TotalFnTypeRep(-,r)   -> r,
                      mk_REP`OpTypeRep(-,r)        -> r,
                      others                       -> nil
                    end
          in
            if fnrng <> nil
            then
              if CGAUX`IsMapType(fnrng) -- patch for Map
              then fcall := BC`GenFctCall(DS`GenMapType().tp, [fcall]);
         );
      stmts := GenInvoke(res, res_decl, fcall,last);
      if id_l <> []
      then return pdecl_l ^ check ^ stmts
      else return check ^ stmts
    );


  GenUnionInvoke: CGMAIN`VT * [CGMAIN`VT] * bool * (AS`Name * seq of AS`Expr) * bool ==> seq of CPP`Stmt
  GenUnionInvoke(mk_CGMAIN`VT(oid,oti),res,res_decl,mi,last) ==
    def mk_(mthd,arg_l) = mi;
        mk_(pdecl_l,id_l) = GenParSequence(arg_l, CGAUX`FindType(mthd))
    in
     (dcl body : seq of CPP`Stmt,
          alts_l : seq of (CPP`Expr * seq of CPP`Stmt) := [],
          ti_s : set of REP`TypeRep := {},
          nm_s : set of AS`Name := {},
          --tinm_s : set of AS`Name := {},
          oid' : CPP`Expr := oid,
          rv_d :seq of CPP`Stmt := [];
      if res = nil or not res_decl
      then rv_d := []
      else let mk_CGMAIN`VT(resVar, resType) = res
           in rv_d := DS`GenDecl(resType, resVar, nil);

      def mk_REP`UnionTypeRep(t_s) = oti;
          mthd' = BC`Rename(mthd)
      in
       (ti_s := { ti | ti in set t_s & is_REP`ObjRefTypeRep(ti) };
        for all objnm in set ti_s do
         (dcl nm : AS`Name;
          if CPP`isCPP()
          then nm := objnm.nm
          else nm := CGAUX`UnQClassType(objnm).nm;
          def luofn = ENV`LookUpOpOrFnName(nm, mthd)
          in
            if luofn <> nil and CGAUX`IsInClassNamespace(nm, mthd)
            then
              (if is_(luofn, REP`FnTypeRep) or is_REP`OpTypeRep(luofn)
               then 
                 (let fndom : seq of REP`TypeRep = if is_(luofn, REP`FnTypeRep)
                                                   then luofn.fndom
                                                   else luofn.Dom
                 in 
                   if len arg_l = len fndom and
                      forall i in set inds arg_l & TYPE`IsOverlapping(CGAUX`FindType(arg_l(i)), fndom(i), {})
                   then nm_s := nm_s union {nm})
               else
                 ( -- TODO: overload 
                  nm_s := nm_s union {nm});
              ));

        if nm_s = {}
        then return [CGAUX`RunTime("Cannot apply or invoke operation")];
        if not CGAUX`IsObjRefType(oti)
        --then oid' := if CPP`isCPP()
        then
          if CPP`isCPP() and DS`GenType(oti) <> BC`GenGeneric()
          then oid' := BC`GenCastExpr(DS`GenObjRefType(nil), oid)
          else oid' := oid;
        for all nm in set nm_s do
         (def cast = DS`CastToClassPtr(nm,oid')
          in
            if CPP`isCPP()
            --then let fcall = BC`GenGenericFctCallPtrToObjMemAcc(cast, mthd', id_l), --20120605
            then
              def fcall = BC`GenFctCallPtrToObjMemAcc(cast, mthd', id_l);
                  estmt = GenInvoke(res, false, fcall, last);
              in
               (dcl cond : CPP`Expr;
                if CGAUX`IsObjRefType(oti)
                then cond := DS`GenIsOfClassExpr(nm,oid)
                else cond := DS`GenAuxType(oid, mk_REP`ObjRefTypeRep(nm));
                alts_l := alts_l ^ [mk_(cond, estmt)]
               )
            else
             (dcl fcall : CPP`Expr;
              let fcalltmp = BC`GenFctCall(BC`GenObjectMemberAccess(cast, mthd'), id_l)
              in
                if res <> nil
                then let mk_CGMAIN`VT(-, tp) = res
                     in fcall := DS`GenExplicitCast(tp, fcalltmp, CGAUX`FindType(mthd))
                else fcall := fcalltmp;
              def estmt = GenInvoke(res, false, fcall, last);
                  isofclass = DS`GenIsThisClass(nm,oid')
              in alts_l := alts_l ^ [mk_(isofclass, estmt)]
             )
         );

        let t_s' = t_s \ { mk_REP`NilTypeRep() }
        in
        --if card ti_s = 1 and card t_s = 1
        if card ti_s = 1 and card t_s' = 1
        then let mk_(-,blk) = hd alts_l
             in
               body := blk
        else
          let err = if exists c in set t_s & is_REP`CompositeTypeRep(c)
                    then CGAUX`RunTime("Cannot apply or invoke operation")
                    else CGAUX`RunTime("Cannot invoke operation in a VDM value")
          in
          ( dcl body1 : [CPP`Stmt] := if card ti_s <> card nm_s
                                      then CGAUX`RunTime("No member method " ^ mthd'.id)
                                      --else nil;
                                      --else if ti_s <> t_s
                                      else if ti_s <> t_s'
                                           then err
                                           else nil;
            --for mk_(cond,stmt) in alts_l do
            --  body1 := BC`GenIfStmt(cond,stmt,body1);
            for idx = len alts_l to 1 by -1 do
              let mk_(cond,stmts) = alts_l(idx),
                  stmt = if len stmts = 1
                         then hd stmts
                         else BC`GenBlock(stmts)
              in
                if idx = len alts_l and body1 = nil
                then body1 := stmt
                else body1 := BC`GenIfStmt(cond,stmt,body1);
     
            body := [body1]
          );
--        if ti_s <> t_s
--        then let cond = if CPP`isCPP()
--                        then DS`GenIsClass(oid)
--                        else DS`GenIsClasses(tinm_s,oid),
--                 err = if exists c in set t_s & is_REP`CompositeTypeRep(c)
--                       then CGAUX`RunTime("Cannot apply or invoke operation")
--                       else CGAUX`RunTime("Cannot invoke operation in a VDM value"),
--                 blbd = if len body = 1
--                        then hd body
--                        else BC`GenBlock(body)
--             in
--               body  := [ BC`GenIfStmt(cond, blbd, err)];
      );
      return pdecl_l ^ rv_d ^ body;
    );
\end{vdm_al}

The operation {\em GenParSequence} is an auxiliary operation to the
operations {\em GenSimpleInvoke} and {\em GenUnionInvoke}.
This operation generates a sequence of C++ statements which declares
and initializes the variables, which holds the values of the actual
parameters.  {\em GenParSequence} returns a tuple containing the generated
C++ statenents and a sequence C++ identifiers representing the
variables which holds the actual parameters.

\begin{vdm_al}

  GenParSequence: seq of AS`Expr * [REP`TypeRep] ==> seq of CPP`Stmt * seq of CPP`Expr
  GenParSequence(arg_l,tp) ==
    if arg_l <> []
    then
      if CPP`isCPP()
      then
        (dcl stmt_l : seq of CPP`Stmt := [],
             id_l : seq of CPP`Expr := [] ;
         for i = 1 to len arg_l do
           def mk_(par_v, par_stmt) = CGExprExcl(arg_l(i), "par", nil)
           in ( stmt_l := stmt_l ^ par_stmt;
                id_l   := id_l ^ [par_v] );
         return mk_(stmt_l, id_l))
      else
        (dcl stmt_l : seq of CPP`Stmt := [],
             id_l : seq of CPP`Expr := [] ;
         for i = 1 to len arg_l do
           def mk_(par_v, par_stmt) = CGExprExcl(arg_l(i), "par", nil)
           in
            (cases tp:
               mk_REP`OpTypeRep(Dom,-) ->
                     (dcl tp1 : REP`TypeRep;
#ifdef VDMPP
                      if is_REP`ObjRefTypeRep (CGAUX`CleanFlatType(Dom(i)))
                      then tp1 := CGAUX`UnQClassType (CGAUX`CleanFlatType(Dom(i)))
                      else
#endif
                      if is_REP`TypeNameRep(Dom(i)) and
                             is_REP`UnionTypeRep(CGAUX`CleanFlatType(Dom(i))) and
                                    CGAUX`IsCompositeType(CGAUX`CleanFlatType(Dom(i)))
                      then tp1 := Dom(i)
                      else tp1 := CGAUX`CleanFlatType(Dom(i));
                      def tp2 = CGAUX`FindType(arg_l(i))
                      in
                       (stmt_l := stmt_l ^ par_stmt;
                        --id_l   := id_l ^ [DS`GenExplicitCast(tp1,par_v,tp2)] )),
                        id_l   := id_l ^ [DS`GenExplicitCast(CGAUX`RemoveNil(tp1),par_v,CGAUX`RemoveNil(tp2))] )
                     ),
               others -> (stmt_l := stmt_l ^ par_stmt;
                          id_l   := id_l ^ [par_v] )
             end);
         return mk_(stmt_l, id_l))
    else
      return mk_([], []);
\end{vdm_al}

The operation $GenInvoke$ is an auxiliary operation to
$GenSimpleInvoke$ and $GenUnionInvoke$. This operation generates one
of the following statements:

\begin{itemize}
\item If no result variable ($res$) is specified, the resulting
  statement will be an expression statement which simply invokes the
  function call specified in $fcall$.
\item If $last = $ {\sf true}, then the resulting statement will be a
  return statement which returns the function call specified in
  $fcall$.
\item If $last = $ {\sf true} and a result variable ($res$) is
  specified, then the resulting statement will be an assignment of
  the function call, $fcall$, to the result variable.
\end{itemize}

\begin{vdm_al}
  GenInvoke: [CGMAIN`VT] * bool * CPP`Expr * bool ==> seq of CPP`Stmt
  GenInvoke(res,res_decl,fcall,last) ==
    if res = nil then
      return [BC`GenExpressionStmt(fcall)]
    else
      if last then
        if CPP`isCPP()
        then return [BC`GenGenericReturnStmt(fcall)]
        else return [BC`GenReturnStmt(fcall)]
      else
        let mk_CGMAIN`VT(id,idtype) = res in
          if res_decl
          then return DS`GenDeclInit(idtype, id, fcall)
          else return [BC`GenAsgnStmt(id,fcall)];
\end{vdm_al}

#endif

Although, it is possible only to construct apply expression on maps,
sequences and functions identifier, it is legal to construct an
expression in which it dynamically is decided whether the expression
is a map or sequence apply, this is possible using the union type.
Consider the VDM example below:

\begin{verbatim}
let ms = if b
         then { 1 |-> 3}
         else [ 1, 3]
in ms( 1 )
\end{verbatim}

The type of the identifier $ms$ is the union type of a map from
nat to nat and a sequence of nat.


The next operation $CGUniontypeApply$ takes care of this case. First the
pseudo code of the apply expression above:

\begin{verbatim}
Generic tmpGen; // Declaration of temporary variable to contain the result of
                // the evaluation of "ms";
...CGExpr( ms, mk_CGMAIN`VT( tmpGen, "Generic" ) );
Int tmppar;     // Declaration of temporary variable to contain the result of
                // the evaluation of the parameter "1"
...CGExpr( "1", mk_CT`VT( tmppar, "Int" ) );
if ( ms.IsMap() )
 { Map tmpMap;
   tmpMap = tmpGen;
   resVar_v = tmpMap[ tmppar ];
 }
else if ( ms.IsSequence() )
   {
     Sequence tmpSeq;
     tmpSeq = tmpGen;
     resVar_v = tmpMap[ tmpSeq ];
   }
else
   RunTimeError( "Illegal apply performed" );
\end{verbatim}

Now, in the \MCL{} it is possible to check if an object is of type Map of ``any
thing''. However, as we want to design the code generator so that the basic data
type implementation can be exchanged, we have to consider the case where the
union type consists of several kind of map types. Consider the example below:

\begin{verbatim}
let m = if b
        then { 1 |-> 3}
        else { [ 1, 3] |-> 4 }
in m( [1,3] );
\end{verbatim}

The identifier $m$ can be bound to two different kinds of maps. If we follow
the strategy schetched above, the pseudo code of the body of the corresponding
if statement is listed below:

\begin{verbatim}
Map tmpMap;
tmpMap = tmpGen;
resVar_v = tmpMap[ tmppar ];
\end{verbatim}

However, when using another basic data type implementation it might be
necessary to declare the variable $tmpMap$ with the explicit
corresponding VDM data type. However, we do not know if the
declaration should correspond to the VDM data type: {\tt map nat to
  nat} or {\tt map seq of nat to nat}, the question is if

\begin{enumerate}
\item we should analyse which kind of type the value in question is of
  and declare a corresponding temporary variable. Of course we need to
  this dynamically and thus using this strategy gives less efficient
  code.
\item or if we should declare the variable as a map of the union type
  of natuaral number type and sequence of natuaral number type. Using
  this strategy will of course require that the basic data
  implementation can handle the case of applying a sequence to map
  where the domain type of the map is union type of among other types
  the sequence type.
\end{enumerate}

In this implementation of the code generator we have chosen the second
strategy, which implies one more requirement to the basic data
implementation.  From this decision it follows that the if condition
which dynamically checks the type shall be generated in a way in which
it checks if a value possible could be of the type. That is, expressed
in pseudo code it should be possible to check if the value:
{\tt \{[1, 2] |-> 3 \}} possible could be of type :
{\tt map (nat | seq of nat) to nat}.

VDM++ case:
Field selectors and apply will concern unions of record and class.


The specification of $CGUnionTypeApply$ is listed below:

\begin{vdm_al}
CGUnionTypeApply: AS`ApplyExpr * CGMAIN`VT * [CPP`Name] * [REP`TypeRep] * bool ==> seq of CPP`Stmt
CGUnionTypeApply( applexpr, rv, expr1, type1, sd ) ==
  def mk_AS`ApplyExpr( expr, par_l, - ) = applexpr;
  in
   (dcl tmpGen_v : [CPP`Expr] := expr1,
        e_stmt : seq of CPP`Stmt := [],
        tmpGenType : [REP`TypeRep] := type1;
    if expr1 = nil
    then
     (tmpGenType := CGAUX`FindType( expr );
      def mk_(e, stms) = CGExprExcl(expr, "tmpGen", nil)
      in
        if is_CPP`Identifier(e)
        then
         (tmpGen_v := e;
          e_stmt := stms)
        else
         (tmpGen_v := BC`GenIdentifier("temp");
          e_stmt := stms ^ [BC`GenDecl(DS`GenType(tmpGenType), tmpGen_v, BC`GenAsgnInit(e))])
     );
    def mk_CGMAIN`VT(resVar_v,restp) = rv;
        tmpRes_v = BC`GiveName( "tmpRes" );
#ifdef VDMSL
        e_stmt2 = e_stmt;
#endif VDMSL
#ifdef VDMPP
        e_stmt2 =
               if is_AS`FieldSelectExpr (expr) and CGAUX`IsUnionFunctionType (tmpGenType) and len e_stmt >= 1
               then e_stmt(1, ..., len e_stmt-1)
               else e_stmt;
#endif VDMPP
    in
     (dcl mapgens : [ REP`GeneralMapTypeRep ] := nil,
          mapinjs : [ REP`InjectiveMapTypeRep] := nil,
          seqs : [ REP`SeqTypeRep ] := nil,
          strings : [ REP`SeqTypeRep ] := nil,
          rb : seq of CPP`Stmt := e_stmt2,
          alt2 : [CPP`Stmt|CPP`Expr] := BC`GenBlock([CGAUX`RunTime("The argument could not be applied")]);

      if is_REP`UnionTypeRep(tmpGenType)
      then
        def mk_( mgs, mis, sqs , strs) = FindPosMapSeqComb(tmpGenType)
        in
         (mapgens := mgs;
          mapinjs := mis;
          seqs := sqs;
          strings := strs);
       
      if len par_l = 0
      then
        def apex = CGFctApplyExpr(applexpr, rv)
        in
          if is_(apex, seq of CPP`Stmt)
          then if len apex = 1
               then alt2 := hd apex
               else alt2 := BC`GenBlock(apex)
          else if is_REP`UnitTypeRep(restp) -- apex is CPP`Expr
               then alt2 := BC`GenExpressionStmt(apex)
               else alt2 := BC`GenAsgnStmt(resVar_v, apex)
      else
        def parType              = CGAUX`FindType( hd par_l );
            mk_(par_v, par_stmt) = CGExprExcl(hd par_l, "par", nil)
        in
         (rb := rb ^ par_stmt;
#ifdef VDMPP
          if CGAUX`IsUnionFunctionType (tmpGenType)
          then
            def apex = CGFctApplyExpr(applexpr,rv)
            in
              if is_(apex, seq of CPP`Stmt)
              then if len apex = 1
                   then alt2 := hd apex
                   else alt2 := BC`GenBlock(apex)
              else if is_REP`UnitTypeRep(restp) -- apex is CPP`Expr
                   then alt2 := BC`GenExpressionStmt(apex)
                   else alt2 := BC`GenAsgnStmt(resVar_v, apex);
#endif VDMPP
          if mapgens <> nil
          then
            alt2 := GenUTMapApply(mapgens,tmpRes_v,tmpGen_v,par_v,alt2,sd,resVar_v);

          if mapinjs <> nil
          then
            alt2 := GenUTMapApply(mapinjs,tmpRes_v,tmpGen_v,par_v,alt2,sd,resVar_v);

          --if seqs <> nil -- 20111221
          --if seqs <> nil and CGAUX`IsPosNumType(parType)
          if (seqs <> nil or (CPP`isCPP() and strings <> nil)) and CGAUX`IsPosNumType(parType)
          then
            let nattype = mk_REP`NumericTypeRep(<NAT>)
            in
             (dcl decl : seq1 of CPP`Stmt,
                  parapply : CPP`Expr,
                  asgn : CPP`Stmt;
              if CPP`isCPP()
              then decl := DS`GenDecl( seqs, tmpRes_v, BC`GenAsgnInit( tmpGen_v) )
              else decl := DS`GenDecl( seqs, tmpRes_v, BC`GenAsgnInit( DS`GenCastSeq(tmpGen_v,nil)) );
              if CGAUX`IsNumType( parType )
              then parapply := DS`GenGetValue(par_v, parType)
              else parapply := DS`GenGetValue(DS`GenCastType( nattype, par_v), nattype );
              if CPP`isCPP()
              then asgn := BC`GenAsgnStmt(resVar_v, DS`GenSeqApply(nil,tmpRes_v,parapply))
              else asgn := BC`GenAsgnStmt(resVar_v, DS`GenCastType(restp,DS`GenSeqApply(nil,tmpRes_v,parapply)));
              alt2 := BC`GenIfStmt(DS`GenIsSeq(tmpGen_v), BC`GenBlock( decl ^[ asgn ]), alt2);
             );

          if strings <> nil
          then
            if CPP`isJAVA()
            then
              def decl = DS`GenDecl( strings, tmpRes_v, BC`GenAsgnInit( DS`GenCastString(tmpGen_v) ));
                  nattype = mk_REP`NumericTypeRep(<NAT>);
              in
               (dcl parapply : CPP`Expr;
                if CGAUX`IsNumType( parType )
                then parapply := DS`GenGetValue(par_v, parType)
                else parapply := DS`GenGetValue(DS`GenCastType( nattype, par_v), nattype );
                def asgn = BC`GenAsgnStmt(resVar_v, DS`GenSeqApplyString(tmpRes_v,parapply))
                in
                  alt2 := BC`GenIfStmt(DS`GenIsString(tmpGen_v), BC`GenBlock( decl ^ [ asgn ]), alt2);
               )
         );
      return rb ^ [alt2];
     );
   );
\end{vdm_al}

The operation {\em GenUTMapApply} is an auxiliary operation to {\em
GenUnionTypeApply}. The operation computes the code corresponding to
application of map types.

\begin{vdm_al}
GenUTMapApply: REP`TypeRep * CPP`Name * CPP`Name * CPP`Expr * [CPP`Stmt] * bool * CPP`Name ==> CPP`Stmt
GenUTMapApply(mapgens, tmpRes_v, tmpGen_v, par_v, alt2, sd, resVar_v ) ==
 (dcl decl : seq of CPP`Stmt;
  if CPP`isCPP()
  then decl := DS`GenDecl( mapgens, tmpRes_v, BC`GenAsgnInit( tmpGen_v) )
  else decl := DS`GenDecl( mapgens, tmpRes_v, BC`GenAsgnInit( DS`GenCastMap(tmpGen_v)) );
  def mk_(-, rngType) = DS`FindMapDomRng(mapgens);
      cg_vt = mk_CGMAIN`VT(tmpRes_v, mapgens);
      mapapply = DS`GenMapApply(cg_vt, par_v);
      cond = DS`GenDomExists(tmpRes_v, par_v)
  in
   (dcl asgn : CPP`Stmt;
    if CGAUX`IsMapType(rngType) or CGAUX`IsSeqType(rngType) or
      is_REP`CompositeTypeRep(rngType) or
      not sd
    then
      if sd
      then
       (dcl emptyalt : CPP`Expr;
        cases true:
          (CGAUX`IsMapType(rngType))         -> emptyalt := DS`GenEmptyMapExpr(),
          (CGAUX`IsSeqType(rngType))         -> emptyalt := DS`GenEmptySeqExpr(),
          (is_REP`CompositeTypeRep(rngType)) -> emptyalt := DS`GenEmptyRecordExpr(rngType.nm)
        end;
        def condexpr = BC`GenBracketedExpr(BC`GenCondExpr(cond, mapapply, emptyalt))
        in asgn := BC`GenAsgnStmt( resVar_v, condexpr ))
      else asgn := BC`GenAsgnStmt( resVar_v, mapapply )
    else
      def emptymap = DS`GenEmptyMapExpr();
          asgn1 = BC`GenAsgnStmt(resVar_v, mapapply);
          asgn2 = BC`GenAsgnStmt(resVar_v, emptymap)
      in
        asgn := BC`GenIfStmt(cond, asgn1, asgn2);
    return BC`GenIfStmt( DS`GenIsMap(tmpGen_v), BC`GenBlock( decl ^ [ asgn ] ), alt2 );
   )
 );
\end{vdm_al}

The next operation is an auxiliary operation to the operation
$CGUnionTypeApply$. The operation is needed in order to compute the
possible types which a map or sequence value can be of. Consider the
follow VDM type:

\begin{verbatim}
( map nat to bool) |
( map bool to seq of nat ) |
( map bool to seq of bool )
( seq1 of nat ) |
( seq of bool ) |
( seq of map nat to nat )
\end{verbatim}

Assume that the operation $FindPosMapSeqComb$ was applied the corresponding
abstract syntax of type above, the output written in the abstract syntax is
then:

\begin{verbatim}
mk_( mk_AS`GeneralMap0Type( mk_AS`UnionType( [ mk_AS`NumericType( <NAT> ),
                                              mk_AS`BooleanType() ] ),
                           mk_AS`UnionType( [ mk_AS`NumericType( <NAT> ),
                                              mk_AS`Seq0Type( <BOOL> ),
                                              mk_AS`Seq1Type( <NAT> )] ) ),
     nil,
     mk_AS`Seq0Type( mk_AS`UnionType( [ mk_AS`NumericType( <NAT> ),
                                        mk_AS`BooleanType() ] ) ),
     mk_AS`Seq1Type( mk_AS`NumericType( <NAT> ) ) )
\end{verbatim}



\begin{vdm_al}
FindPosMapSeqComb: REP`UnionTypeRep ==> [ REP`GeneralMapTypeRep ] *
                            [ REP`InjectiveMapTypeRep]  * [ REP`SeqTypeRep ] * [ REP`SeqTypeRep ]
FindPosMapSeqComb(mk_REP`UnionTypeRep(type_s)) ==
( dcl gen : [ REP`GeneralMapTypeRep ] := nil,
      inj : [ REP`InjectiveMapTypeRep ] := nil,
      seqs : [ REP`SeqTypeRep ] := nil,
      strings : [ REP`SeqTypeRep ] := nil;
  def flattype_s = CGAUX`GiveFlatUnionType(type_s) in
  for all type in set flattype_s do
  ( cases CGAUX`CleanFlatType(type):
      mk_REP`GeneralMapTypeRep(md, mr)    -> gen := mk_REP`GeneralMapTypeRep(md, mr),
      mk_REP`InjectiveMapTypeRep(md, mr ) -> inj := mk_REP`InjectiveMapTypeRep(md, mr),
      mk_REP`SeqTypeRep(t)                -> if CGAUX`IsPossibleStringType(type)
                                             then strings := mk_REP`SeqTypeRep(mk_REP`CharTypeRep())
                                             else seqs := mk_REP`SeqTypeRep(t),
      others -> skip
    end
  );
  return mk_(gen, inj, seqs, strings)
);

\end{vdm_al}


\subsection{Let Expression}
\label{letexpr}

In this version of the code generator there is no support of local
function definitions. Consider the VDM let expression below:


\begin{verbatim}
let mk_(a, b) = 3,
    c = f(3)
in g(a, b, c)
\end{verbatim}

The corresponding code is listed below:
\begin{verbatim}
Int vdm_a;
Int vdm_b;
Int vdm_c;
bool succ = true;
{ Tuple tmpVar ;
  ...CGExpr( "3", mk_CGMAIN`VT( TmpVar, "Tuple" ) );
  ...PM`CGPatternMatch( "mk_(a, b), mk_CGMAIN`VT( tmpVal, "Tuple" ) )
  if (!succ)
     RunTimeError( "Pattern Match did not succeed in value definition" )
}
{ Int tmpVar;
  ...CGExpr( "f(3)", mk_CGMAIN`VT( TmpVar, "Int" ) );
  ...PM`CGPatternMatch( "f(3)", mk_CGMAIN`VT( tmpVal, "Int" ) );
  if (!succ)
     RunTimeError( "Pattern Match did not succeed in value definition" )
}
...CGExpr( "g(a,b,c)", mk_CGMAIN`VT( resVar_v, "resVarTmp" ) );
\end{verbatim}


\begin{vdm_al}
CGLetExpr: AS`LetExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGLetExpr( mk_AS`LetExpr(ld_l, body, -), resVar_v) ==
( dcl rb : seq of CPP`Stmt := [];
  FD`PushEnv();
  CGAUX`PushEnv();
  let vindex_s = { i | i in set inds ld_l & is_AS`ValueDef(ld_l(i)) } in
    let lvd_l = [ ld_l(i) | i in set vindex_s ],
        lfd_l = [ ld_l(i) | i in set inds ld_l \ vindex_s ] in
    ( FD`GenLocalFcts(lfd_l);
      rb := rb ^ VD`GenLocalValDef(lvd_l);
      rb := rb ^ CGExpr( body, resVar_v)
    );
  FD`PopEnv();
  CGAUX`PopEnv();
  VD`DeleteLoc();
  return [BC`GenBlock(rb)]
);
\end{vdm_al}

\subsection{Let-Be-Such-That Expression}
\label{letbeexpr}

In this version of the code generator does not support nested {\em
  let-be-such-that\/} expressions, like the example below:

\begin{verbatim}
let a in set {1,2,3,4} be st
  let b in set {2,4} be st b mod 2 = 0 and a + b > 3
  in true
in a
\end{verbatim}

Consider the let-be-such-that expression below:

\begin{verbatim}
let mk_(a,b,c) in set {mk_(2,2,3), mk_(3,2,10), mk_(1,2)}
    be st c = 10 in
in a
end{verbatim}


The corresponding code is listed below:

\begin{verbatim}
Set tmpSet;
...CGEXPR("{mk_(2,2,3), mk_(3,2,10), mk_(1,2)}", mk_CGMAIN`VT(tmpVar, "Set"));
Int vdm_a;
Int vdm_b;
Int vdm_c;
bool succ = false;
Bool tmpB;
Generic tmpG;
for (int cont=tmpSet.First(tmpG); cont && !succ; cont=tmpSet.Next(tmpG)) {
  Tuple tmpElem(tmpG);
  succ = true;
  ...PM`CGPatternMatch("mk_(a,b,c)", mk_CGMAIN`VT(tmpElem, "Tuple"))
  if (succ) {
    ...CGExpr("c = 10", mk_CGMAIN`VT(tmpB, "Bool"))
    succ = tmpB.GetValue();
  }
}
if (!succ)
  RunTimeError("The binding environment was empty in let-be-such-that expression")
...CGExpr("a", mk_CGMAIN`VT(resVar_v, "resVarTmp"))
\end{verbatim}

If the ``such-that'' expression do {\em not\/} return a boolean value,
the let-be-such-that expression will cause the  run-time error ``A
boolean was expected in let-be-such-that expression''.


If the optional {\em be-such-that\/} ({\tt be st c = 10 }) part is
left out, the generated code will reduce to:

\begin{verbatim}
Set tmpSet;
...CGEXPR("{mk_(2,2,3), mk_(3,2,10), mk_(1,2)}", mk_CGMAIN`VT(tmpVar, "Set"));
Int vdm_a;
Int vdm_b;
Int vdm_c;
bool succ = false;
Generic tmpe;
for (int cont=tmpSet.First(tmpe); cont && !succ; cont=tmpSet.Next(tmpe)) {
  Tuple tmpElem(tmpe);
  succ = true;
  ...PM`CGPatternMatch("mk_(a,b,c)", mk_CGMAIN`VT(tmpe, "Tuple"))
}
if (!succ)
  RunTimeError("The binding environment was empty let-be-such-that expression")
...CGExpr("a", mk_CGMAIN`VT(resVar_v, "resVarTmp"))
\end{verbatim}


The operation $CGLetBeSTExpr$ generates code corresponding to
let-be-such-that expressions:

\begin{vdm_al}
CGLetBeSTExpr: AS`LetBeSTExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGLetBeSTExpr(mk_AS`LetBeSTExpr(bind, St, In, -), vt) ==
  if exists b in set elems bind & is_AS`MultTypeBind(b)
  then
    (CGAUX`SetNotSupportedException(true);
    return [CGAUX`NotSupported("type bind")])
  else
    (CGAUX`PushEnv();
    def rb_l = GenBindListVariables(bind, St) ^ CGExpr(In, vt) in
      (CGAUX`PopEnv();
       return [BC`GenBlock(rb_l)]));

\end{vdm_al}

The operation $GenBindVariables$ is an auxiliary operation to both
$CGLetBeSTExpr$ and $CGLetBeSTStmt$ (see section \ref{letbestmt}).
This operation generates the declaration and initialization of the
local variables in the new scope.

It has to be noticed that two lines of this specification will never
be covered. Indeed, the problem is that for the moment when a
predicate for a Let Be Expression is omitted, the parser consider that
predicate as a boolean true and put this value in the abstract syntax
tree. Therefore, the value nil is never used for the predicate and the
first part of the tests will always be true. Then, the parser will
have to be changed to keep then nil value in the abstract syntax tree.

\begin{vdm_al}
GenBindVariables: AS`MultSetBind * [AS`Expr] ==> seq of CPP`Stmt
GenBindVariables(mk_AS`MultSetBind(pat_l, Set, -), St) ==
  def setType : REP`TypeRep = CGAUX`FindType(Set);
      settp : REP`TypeRep = CGAUX`FindSetElemType(setType);
      succ : CPP`Name = BC`GiveName("succ");
      tmpElem : CPP`Name = BC`GiveName("tmpElem");
      elemVT = mk_CGMAIN`VT(tmpElem, settp);
      pid_m = SamePatternIds(pat_l).#2;
      mk_(s_res, s_st_stmt) = CGExprExcl(Set, "tmpSet", nil) -- first -- must be before DeclarePatterns
  in
  ( dcl rb_l : seq of CPP`Stmt := [],
        inner_stmts : seq of CPP`Stmt := [],
        need_decl : bool := false,
        tmpSet : CPP`Expr := s_res;
    if not CGAUX`IsSetType(setType)
    then
      (dcl tmpS : CPP`Expr := s_res;
       if not is_CPP`Identifier(s_res)
       then
         (tmpSet := BC`GiveName("tmpS");
          rb_l := rb_l ^ [ BC`GenDecl(DS`GenType(setType), tmpS, BC`GenAsgnInit(s_res)) ]);
       rb_l := rb_l ^ [ BC`GenIfStmt (BC`GenNot (DS`GenIsSet(tmpS)),
                         BC`GenBlock([CGAUX`RunTime("A set was expected")]), nil) ];
       tmpSet := DS`GenCastSetType(tmpS));
          
    rb_l := rb_l ^ s_st_stmt;
    rb_l := rb_l ^ DeclarePatterns(pid_m); -- second -- must be before CGExprExcl and CGPatternMatchExcl

    if St <> nil
    then
      def mk_(res, st_stmt) = CGExprExcl(St, "tmpB", nil);
          bt = mk_REP`BooleanTypeRep()
      in
        (inner_stmts := inner_stmts ^ st_stmt;
         if CGAUX`IsBoolType(CGAUX`FindType(St))
         then inner_stmts := inner_stmts ^ [BC`GenAsgnStmt(succ, DS`GenGetValue(res, bt))]
         else def getval = DS`GenGetValue(BC`GenCastExpr(DS`GenBoolType(), res), bt)
              in inner_stmts := inner_stmts ^ [BC`GenIfStmt(DS`GenIsBool(res),
                                                            BC`GenAsgnStmt(succ, getval),
                             BC`GenBlock([CGAUX`RunTime("A boolean was expected")]))];);

    for i = len pat_l to 1 by -1 do
     (def p_s = dunion { dom FindPatternId(pat_l(j)) | j in set {1,...,i - 1} };
          p = if inner_stmts = [] then nil else inner_stmts;
          mk_(pm, Is_Excl) = PM`CGPatternMatchExcl(pat_l(i), elemVT, p_s, succ, nil, p, false)
      in 
        (inner_stmts := pm;
         need_decl := need_decl or not Is_Excl));

    if not need_decl and St = nil
    then inner_stmts := inner_stmts ^ [BC`GenAsgnStmt(succ,BC`GenBoolLit(true))];

    let setVT = mk_CGMAIN`VT(tmpSet, mk_REP`SetTypeRep(settp))
    in
      rb_l := rb_l ^ [BC`GenDecl(DS`GenSmallBoolType(), succ, BC`GenAsgnInit(BC`GenBoolLit(false)))]
                   ^ DS`GenIterSet(setVT, BC`GenNot(succ), elemVT, inner_stmts)
                   ^ [BC`GenIfStmt(BC`GenNot(succ),
                      BC`GenBlock([CGAUX`RunTime("The binding environment was empty")]), nil)];
    return rb_l;
  );

GenBindListVariables: AS`BindList * [AS`Expr] ==> seq of CPP`Stmt
GenBindListVariables(bind_l, St) ==
  cases bind_l:
    [mk_AS`MultSetBind([-],-,-)] -> return GenBindVariables(hd bind_l, St),
    others -> (dcl p_l : seq of AS`Pattern := [];
               for bind in bind_l do
               if (is_AS`MultSetBind(bind))
               then p_l := p_l ^ bind.pat;
               def mk_(-, m) = SamePatternIds(p_l)
               in
                 def pid_m = { nm |-> cases m(nm):
                                        {tp} -> tp,
                                        others -> mk_REP`UnionTypeRep(m(nm))
                                      end | nm in set dom m };
                     succ_bind_v = BC`GiveName("succ_bind");
                     stmt = BC`GenAsgnStmt(succ_bind_v, BC`GenBoolLit(true));
                     contexpr = BC`GenNot(succ_bind_v);
                     cstmt = CGComprehension(bind_l, St, [stmt], contexpr, nil, pid_m, false)
                 in
                  (dcl rb_l : seq of CPP`Stmt := [];
                   rb_l := [ BC`GenDecl(DS`GenSmallBoolType(), succ_bind_v, BC`GenAsgnInit(BC`GenBoolLit(false))) ];
                   rb_l := rb_l ^ CGAUX`StripCompoundStmt(cstmt);
                   rb_l := rb_l ^ [BC`GenIfStmt(BC`GenNot(succ_bind_v),
                      BC`GenBlock([CGAUX`RunTime("The binding environment was empty")]), nil)];
                   return rb_l))
  end;
\end{vdm_al}


\subsection{Define Expression}

The pseudo code of the define expression is very much a like the
pseudo code of let expressions. Therefore we refer to the code generation
of let expressions for further information.

Notice, that type binds are ignored, and that set binds are not
supported by the code generator (and the VDM parser as well).

\begin{vdm_al}
CGDefExpr: AS`DefExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGDefExpr(mk_AS`DefExpr(def_l, body, -), resVar_v) ==
( dcl rb_l : seq of CPP`Stmt := [],
      lvd_l : seq of AS`ValueDef := [];
  FD`PushEnv();
  CGAUX`PushEnv();
  for mk_(patb, expr) in def_l do
    cases patb:
      mk_AS`TypeBind(pat, tp, cid) ->
            lvd_l := lvd_l ^ [mk_AS`ValueDef(pat, tp, expr, <NOT_INITIALISED_AS>, false, cid)],
      mk_AS`SetBind(pat, Set, cid) ->
            def pcid = CI`PushCGType(mk_REP`SetTypeRep(CGAUX`FindType(pat)));
                ecid = CI`PushCGType(mk_REP`SetTypeRep(CGAUX`FindType(expr)));
                iscid = CI`PushCGType(mk_REP`UnionTypeRep({CGAUX`FindType(Set),
                                                           mk_REP`SetTypeRep(CGAUX`FindType(pat))}));
                iset = mk_AS`BinaryExpr(Set, <SETINTERSECT>, mk_AS`SetEnumerationExpr([expr], ecid), iscid);
                sep = mk_AS`SetEnumPattern([pat], pcid)
            in
              lvd_l := lvd_l ^ [mk_AS`ValueDef(sep, nil, iset, <NOT_INITIALISED_AS>, false, cid)],
      others -> lvd_l := lvd_l ^ [mk_AS`ValueDef(patb, nil, expr, <NOT_INITIALISED_AS>, false, patb.cid)]
    end;
  rb_l := rb_l ^ VD`GenLocalValDef(lvd_l);
  rb_l := rb_l ^  CGExpr(body, resVar_v);
  FD`PopEnv();
  CGAUX`PopEnv();
  VD`DeleteLoc();
  return [BC`GenBlock(rb_l)]
);
\end{vdm_al}


\subsection{Bracketed Expression}

An example of a  bracketed expression is shown below:

\begin{verbatim}
( f(3) )
\end{verbatim}

The corresponding pseudo code is listed below, assuming that the
result of the evaluation of the expression is to be stored in the
variable $resVar$ which is declared as the type $resVarType$.

\begin{verbatim}
...CGMAIN`Expr( "f(3)", mk_CGMAIN`VT( resVar, resVarType ) )
\end{verbatim}

\begin{vdm_al}
CGBracketedExpr: AS`BracketedExpr * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGBracketedExpr(mk_AS`BracketedExpr(expr, -), vt) ==
  CGExpr'(expr, vt);
\end{vdm_al}


\subsection{If expression}

Consider the VDM if expression below:

\begin{verbatim}
if b= 5
then f(a)
elseif c= 6
  then g(a)
  else h(a)
\end{verbatim}

The $elseif then$ branch can be omitted or it can be repeated
several times.


The corresponding pseudo code is very much alike the pseudo code of
the the if statement:

\begin{verbatim}
  Bool cond;
  ...CGExpr( "b=5", mk_CGMAIN`VT( cond, "Bool" );
  if ( cond.GetValue() )
     ...CGExpr( "f(a)", mk_CGMAIN`VT( resVar_v, resVarType ) )
  else
     {
       ...CGExpr( "c=6", mk_CGMAIN`VT( cond, "Bool" ) )
       if ( cond.GetValue() )
          ...CGExpr( "g(a)", mk_CGMAIN`VT( resVar_v, resVarType) )
       else
          ...CGExpr( "h(a)", mk_CGMAIN`VT( resVar_v, resVarType) )
     }

\end{verbatim}

\begin{vdm_al}
CGIfExpr: AS`IfExpr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGIfExpr( mk_AS`IfExpr( test, cons, elif, altn, - ), mk_CGMAIN`VT( resVar_v, resVarType) ) ==
  def condType = CGAUX`FindType(test);
      mk_(res1, cond_stmt) = CGExprExcl(test, "cond", nil);
      mk_(cons_expr, cons_stmt) = CGExprExcl(cons, "cons", resVarType);
      mk_(altn_expr, altn_stmt) = CGExprExcl(altn, "altn", resVarType);
  in
   (dcl getval : CPP`Expr := res1,
        cond : CPP`Expr,
        tmpb : seq of CPP`Stmt := altn_stmt ^ [BC`GenAsgnStmt(resVar_v, altn_expr)];

    if not CGAUX`IsBoolType(condType)
    then getval := BC`GenCastExpr( DS`GenBoolType(), res1 );
    if CPP`isCPP()
    then cond := DS`GenGetValue( getval, condType )
    else cond := DS`GenGetValue( getval, mk_REP`BooleanTypeRep() );

    if elif = [] and cons_stmt = [] and altn_stmt = []
    then
      def cons_type = CGAUX`FindType(cons);
          altn_type = CGAUX`FindType(altn)
      in
        if cons_type <> nil and altn_type <> nil
        then
          if cons_type = altn_type
             or (CGAUX`IsIntType(cons_type) and CGAUX`IsIntType(altn_type))
             or (CPP`isCPP() and is_AS`QuoteLit(cons) and is_AS`QuoteLit(altn))
             or (CPP`isJAVA() and CGAUX`IsQuoteType(cons_type) and CGAUX`IsQuoteType(altn_type))
          then
            let expr = BC`GenCondExpr(cond, cons_expr, altn_expr)
            --in return cond_stmt ^ [BC`GenAsgnStmt(resVar_v, BC`GenBracketedExpr(expr))]
            in 
              if cond_stmt = []
              then return BC`GenBracketedExpr(expr)
              else return cond_stmt ^ [BC`GenAsgnStmt(resVar_v, BC`GenBracketedExpr(expr))]
          elseif CPP`isJAVA()
          then
           (dcl cast_cons : CPP`Expr := cons_expr,
                cast_altn : CPP`Expr := altn_expr;
            if cons_type <> resVarType
            then cast_cons := BC`GenCastExpr( DS`GenType(resVarType), cons_expr );
            if altn_type <> resVarType
            then cast_altn := BC`GenCastExpr( DS`GenType(resVarType), altn_expr );
            let expr = BC`GenCondExpr(cond, cast_cons, cast_altn)
            --in return cond_stmt ^ [BC`GenAsgnStmt(resVar_v, BC`GenBracketedExpr(expr))];
            in 
              if cond_stmt = []
              then return BC`GenBracketedExpr(expr)
              else return cond_stmt ^ [BC`GenAsgnStmt(resVar_v, BC`GenBracketedExpr(expr))];
           );

    for mk_AS`ElseifExpr(elif_test, elif_cons, -) in reverse elif do
      def mk_(res2, res2_stmt) = CGExprExcl(elif_test, "cond", nil)
      in
        def elif_alt2 = CGAUX`GenCPPStmt(tmpb);
            elif_alt1 = def alt1_stmts = CGExpr(elif_cons, mk_CGMAIN`VT(resVar_v, resVarType))
                        in CGAUX`GenCPPStmt(alt1_stmts);
            testType = CGAUX`FindType(elif_test);
        in
         (dcl nres2 : CPP`Expr := res2,
              elif_cond : CPP`Expr;
          if not CGAUX`IsBoolType(testType)
          then nres2 := BC`GenCastExpr(DS`GenBoolType(), res2);
          if CPP`isCPP()
          then elif_cond := DS`GenGetValue( nres2, testType )
          else elif_cond := DS`GenGetValue( nres2, mk_REP`BooleanTypeRep() );
          tmpb := res2_stmt ^ [ BC`GenIfStmt( elif_cond, elif_alt1, elif_alt2) ];
         );

    def alt1 = CGAUX`GenCPPStmt(cons_stmt ^ [BC`GenAsgnStmt(resVar_v, cons_expr)]);
        alt2 = CGAUX`GenCPPStmt(tmpb);
    in return cond_stmt ^ [ BC`GenIfStmt(cond, alt1, alt2) ];
   );
\end{vdm_al}

\subsection{Sequence Modify Map Override Expression}

This expression covers two kind of expressions which syntactically are
equal, namely, a sequence modification and a map override.

An example of a map override is shown below:

\begin{verbatim}
{1 |-> 3, 3 |-> 4} ++ { 3 |-> 5}
\end{verbatim}

The corresponding pseudo code is shown below:
\begin{verbatim}
Map tmpMap;
...CGExpr("{1 |-> 3, 3 |-> 4}", mk_CGMAIN`VT( tmpMap, "Map" ) );
Map modMap;
...CGExpr("{3 |-> 5}", mk_CGMAIN`VT( modMap, "Map" ) );
tmpMap.ImpOverrid( modMap );
resVar = tmpMap;
\end{verbatim}


and an example of a sequence modification is shown below:

\begin{verbatim}
[ 1, 2, 3, 4] ++ { 2 |-> 1, 4 |-> 1}
\end{verbatim}

The corresponding pseudo code is shown below:

\begin{verbatim}
Sequence tmpSeq;
...CGExpr( "[ 1, 2, 3, 4]", mk_CGMAIN`VT( tmpSeq, "Sequence" ) );
Map modMap;
...CGExpr( "{2 |-> 1, 4 |-> 1 }", mk_CGMAIN`VT( modMap, "Map" ) );
// Transverse through modMap and modify the elements in the sequence
// which is contained in the domain of the map modMap
Generic edom;
for ( int bb = modMap.First( edom ); bb; bb = modMap.Next( edom ) )
 {
    Int e = edom;
    if ( e.GetValue() > tmpSeq.Lenght() )
        RunTimeError( " Illegal index " )
    else
        tmpSeq.ImpModify( e.GetValue(), modMap[ e ] )
 }
resVar = tmpSeq;
\end{verbatim}


In case of sequence modification the domain of the map should be
integers, however, in some cases it should be decided at run-time if
this is the case. Consider the following example:

\begin{verbatim}
let mymap = if b
            then { "no_integer" |-> 34}
            else { 2 |-> 31}
in [ 2, 3] ++ mymap
\end{verbatim}

In this case the pseudo code should look like:

\begin{verbatim}
Sequence tmpSeq;
...CGExpr( "[ 2,3 ]", mk_CGMAIN`VT( tmpSeq, "Sequence" ) );
Map modMap;
...CGExpr( "mymap", mk_CGMAIN`VT( modMap, "Map" ) );
// Transverse through modMap and modify the elements in the sequence
// which is contained in the domain of the map modMap
Generic edom;
for ( int bb = modMap.First( edom ); bb; bb = modMap.Next( edom ) )
 {
    if (! edom.IsInt())
        CGAUX`RunTime("An Integer was expected in map in sequence modify");
    Int e = edom;
    if ( e.GetValue() > tmpSeq.Lenght() ||
         e.GetValue() <= 1)
        RunTimeError( " Illegal index " )
    else
        tmpSeq.ImpModify( e.GetValue(), modMap[ e ] )
 }
resVar = tmpSeq;
\end{verbatim}

In some cases, it might be even statically impossible to decide which
kind of expression we are dealing with. Consider the example below:

\begin{verbatim}
let a = if b
        then { 1 |-> 3}
        else [1, 3]
in a ++ { 1 |-> 4}
\end{verbatim}

In this case we have to dynamically to check which kind of expression
we are dealing with. The corresponding pseudo code is listed below:

\begin{verbatim}
Generic seqmap;
...CGExpr( "a", mk_CGMAIN`VT( seqmap, "Generic" ) );
Map modMap;
...CGExpr( "{1 |-> 4}", mk_CGMAIN`VT( modMap, "Map" ) );
if ( seqmap.IsMap() )
    ( Map ) seqmap.ImpOverride( modMap );
else if ( seqmap.IsSequence () )
     { // Transverse through seqmap and modify the elements in the sequence
       // which is contained in the domain of the map modMap
       Generic edom;
       for ( int bb = modMap.First( edom ); bb; bb = modMap.Next( edom ) )
        { Int e = edom;
          if ( e.GetValue() > (Sequence) tmpSeq.Lenght() )
             RunTimeError( "Illegal index" );
          else
             (Sequence) modseq.ImpModify( e.GetValue(), modMap[ e ] );
        }
     }
     else
        RunTimeError( "A map or sequence was expected" );
resVar = seqmap;
\end{verbatim}

The type of the right hand expression in a Sequence Modify Map
Override Expression can be a union type. Consider, e.g.\ the VDM
example below:

\begin{verbatim}
let a = if b
        then { 1 |-> 3}
        else { 1, 3}
in { 2 |-> 3} ++ a
\end{verbatim}

In this case the corresponding C++ variable of the VDM identifier {\em a}
will be declared as a {\em Generic} or the equivalent type of a union
type.  In this case it is necessary to cast the corresponding variable
whenever necessary, or to declare the temporary variable which is to
contain the result of evaluating the expression $a$ in the modify
expression.  The corresponding pseudo code of the expression is listed
below:

\begin{verbatim}
Sequence seqmap;
...CGExpr( "{2 |-> 3}", mk_CGMAIN`VT( seqmap, "Sequence" ) );
Generic  tmpMap;
...CGExpr( a, mk_CGMAIN`VT( tmpMap, "Generic" ) );
if ( ! IsMap( tmpMap )
  RunTimeError( "A map was expected" );
Map modMap = tmpMap;
seqMap.ImpOverride( modMap );
\end{verbatim}


\begin{vdm_al}
CGSeqModifyMapOverrideExpr: AS`SeqModifyMapOverrideExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGSeqModifyMapOverrideExpr( mk_AS`SeqModifyMapOverrideExpr( seqmap, mapexp, -),
                            mk_CGMAIN`VT( resVar_v, restp) ) ==
  def seqmapType1 = CGAUX`FindType(seqmap);
      modmapType = CGAUX`FindType( mapexp );
      tmpmapType = CGAUX`FindPossibleMapType( modmapType );
      mk_(seqmap_v, seqmap_stmt) = CGExprExcl(seqmap, "seqmap", nil)
  in
   (dcl rb : seq of CPP`Stmt := seqmap_stmt,
        modmap_v : CPP`Expr := BC`GiveName( "modmap" );
    if (is_AS`Name(mapexp))
    then modmap_v := BC`Rename(mapexp)
    else
      if CGAUX`IsMapType( modmapType )
      then
        def mk_(m_v, m_stmt) = CGExprExcl(mapexp, "modmap", modmapType)
        in (rb := rb ^ m_stmt ^ DS`GenDeclInit(modmapType, modmap_v, m_v))
      else
        def tmpmap_v = BC`GiveName( "tmpmap" );
            mk_(m_v, m_stmt) = CGExprExcl(mapexp, "tmpmap", modmapType)
        in
         (rb := rb ^ m_stmt ^ DS`GenDeclInit(modmapType, tmpmap_v, m_v);
          rb := rb ^ [BC`GenIfStmt(BC`GenNot (DS`GenIsMap (tmpmap_v)), CGAUX`RunTime ("A map was expected"), nil)];
          rb := rb ^ DS`GenDeclInit(tmpmapType, modmap_v, DS`GenCastMap(tmpmap_v)));
          
    let rre = BC`GenBlock([CGAUX`RunTime("An integer was expected in domain of map in sequence modifier")])
    in
      if CGAUX`IsPosMapType(seqmapType1) and not CGAUX`IsPosSeqType(seqmapType1)
      then
        def mapover = GenMapOvwr(mk_CGMAIN`VT( seqmap_v, seqmapType1 ),
                                 mk_CGMAIN`VT( modmap_v, modmapType),
                                 mk_CGMAIN`VT( resVar_v, restp),
                                 not CGAUX`IsMapType(seqmapType1) or not CGAUX`IsMapType(restp))
        in
          if CGAUX`IsMapType(seqmapType1)
          then rb := rb ^ mapover
          else rb := rb ^ [BC`GenIfStmt(DS`GenIsMap(seqmap_v), BC`GenBlock(mapover), rre)]
      elseif CGAUX`IsPosSeqType(seqmapType1) and not CGAUX`IsPosMapType(seqmapType1)
      then
        def seqover = GenSeqOvwr(mk_CGMAIN`VT( seqmap_v, seqmapType1 ),
                                 mk_CGMAIN`VT( modmap_v, modmapType),
                                 mk_CGMAIN`VT( resVar_v, restp),
                                 not CGAUX`IsSeqType(seqmapType1) or not CGAUX`IsSeqType(restp))
        in
          if CGAUX`IsSeqType(seqmapType1)
          then rb := rb ^ seqover
          else
            if CPP`isCPP()
            then rb := rb ^ [BC`GenIfStmt(DS`GenIsSeq(seqmap_v), BC`GenBlock(seqover), rre)]
            else
              if CGAUX`IsPossibleStringType(seqmapType1)
              then rb := rb ^ [BC`GenIfStmt(DS`GenIsString(seqmap_v), BC`GenBlock(seqover), rre)]
              else rb := rb ^ [BC`GenIfStmt(DS`GenIsSeq(seqmap_v), BC`GenBlock(seqover), rre)]
      else -- TODO:
        def mapover = GenMapOvwr(mk_CGMAIN`VT( seqmap_v, seqmapType1 ),
                                 mk_CGMAIN`VT( modmap_v, modmapType),
                                 mk_CGMAIN`VT( resVar_v, restp),
                                 true);
            seqover = GenSeqOvwr(mk_CGMAIN`VT( seqmap_v, seqmapType1 ),
                                 mk_CGMAIN`VT( modmap_v, modmapType),
                                 mk_CGMAIN`VT( resVar_v, restp),
                                 true)
        in
          if CPP`isCPP()
          then rb := rb ^ [BC`GenIfStmt(DS`GenIsMap(seqmap_v),
                                        BC`GenBlock(mapover),
                                        BC`GenIfStmt(DS`GenIsSeq(seqmap_v), BC`GenBlock(seqover), rre))]
          else
            if CGAUX`IsPossibleStringType(seqmapType1)
            then rb := rb ^ [BC`GenIfStmt(DS`GenIsMap(seqmap_v),
                                          BC`GenBlock(mapover),
                                          BC`GenIfStmt(DS`GenIsString(seqmap_v), BC`GenBlock(seqover), rre))]
            else rb := rb ^ [BC`GenIfStmt(DS`GenIsMap(seqmap_v),
                                          BC`GenBlock(mapover),
                                          BC`GenIfStmt(DS`GenIsSeq(seqmap_v), BC`GenBlock(seqover), rre))];
    return rb);
\end{vdm_al}


\begin{vdm_al}
  FindPosApplyTypes: REP`TypeRep ==> REP`TypeRep
  FindPosApplyTypes(tp) ==
  cases tp:
    mk_REP`SeqTypeRep(-) -> return tp,
    mk_REP`GeneralMapTypeRep(-,-),
    mk_REP`GeneralMapTypeRep(-,-) -> return tp,
    mk_REP`UnionTypeRep(tps) ->
      return mk_REP`UnionTypeRep({ FindPosApplyTypes(t) |
                                  t in set tps &
                                  is_REP`SeqTypeRep(t) or
                                  (CGAUX`IsMapType(t) and
                                   not is_REP`EmptyMapTypeRep(t)) }),
    others -> return undefined
  end;
\end{vdm_al}


\begin{vdm_al}
GenSeqOvwr: CGMAIN`VT * CGMAIN`VT * CGMAIN`VT * bool ==> seq of CPP`Stmt | CPP`Expr
GenSeqOvwr( mk_CGMAIN`VT(seq_v, seqtype), mk_CGMAIN`VT(map_v, mapType), mk_CGMAIN`VT(resVar_v, restp), cast ) ==
  def edom = BC`GiveName("edom");
      erng = BC`GiveName("erng");
      nattp = mk_REP`NumericTypeRep(<NAT>);
      mk_(domtype, -) = DS`FindMapDomRng(mapType);
  in
   (dcl s_v : CPP`Expr := resVar_v,
        e_v : CPP`Expr := edom,
        seq_len : CPP`Expr,
        isint_part : seq of CPP`Stmt;
    if cast
    then s_v := BC`GiveName("s_v");
    if not CGAUX`IsIntType(domtype)
    then e_v := BC`GiveName("e_v");
    if CPP`isCPP()
    then seq_len := DS`GenLen(s_v)
    else seq_len := DS`GenLen_int(s_v);
    if CGAUX`IsIntType(domtype)
    then isint_part := []
    else
      def rre = BC`GenBlock([CGAUX`RunTime("An integer was expected in domain of map in sequence modifier")]);
          int_cond = BC`GenNot( DS`GenIsInt(edom) );
          ifisint = BC`GenIfStmt(int_cond, rre, nil);
      in
       (dcl e_decl : seq of CPP`Stmt;
        if CPP`isCPP()
        then e_decl := DS`GenDeclInit(nattp, e_v, edom)
        else e_decl := DS`GenDeclInit(nattp, e_v, BC`GenCastExpr(DS`GenNatType(),edom));
        isint_part := [ifisint] ^ e_decl;
       );
    def e_int = DS`GenGetValue(e_v, nattp);
       cond = BC`GenLogOr(BC`GenGt(e_int, seq_len), BC`GenLt(e_int, BC`GenIntegerLit(1)));
       rre = BC`GenBlock([CGAUX`RunTime( "Illegal index in sequence modifier")]);
       alt2 = DS`GenSeqModify(s_v, e_int, erng);
    in
     (dcl if_body : CPP`Stmt := alt2;
      if CPP`isJAVA()
      then if_body := BC`GenIfStmt(cond, rre, alt2);
      def body = let stmts = isint_part ^ [if_body]
              in CGAUX`GenCPPStmt(stmts);
          seqtp = mk_REP`SeqTypeRep(CGAUX`FindSeqElemType(seqtype));
      in
       (dcl rb : seq of CPP`Stmt;
        if CPP`isCPP()
        then if cast
             then rb := DS`GenDeclInit( seqtp, s_v, seq_v)
             else rb := [ BC`GenAsgnStmt(resVar_v, seq_v) ]
        else
          if CGAUX`IsStringType(seqtype) or CGAUX`IsPossibleStringType(seqtype)
          then rb := DS`GenDeclInit(seqtp, s_v, DS`GenExplicitCast(seqtp, seq_v, nil))
          else
           (dcl seq_v' : CPP`Expr := seq_v;
            if cast 
            then seq_v' := DS`GenCastSeq(seq_v, nil);
            def seq_v_c = DS`GenSeqExpr(seq_v')
            in
              if cast
              then rb := DS`GenDeclInit(seqtp, s_v, seq_v_c)
              else rb := [ BC`GenAsgnStmt(resVar_v, seq_v_c) ];
           );
      rb := rb ^ DS`GenIterMap(mk_CGMAIN`VT(map_v, mapType), nil, edom, erng, body);
      if CPP`isCPP()
      then
        if cast
        then rb := rb ^ [BC`GenAsgnStmt(resVar_v, s_v)]
        else skip
      else
        if CGAUX`IsStringType(restp) or CGAUX`IsPossibleStringType(restp)
        then rb := rb ^ [BC`GenAsgnStmt(resVar_v,
                            DS`GenExplicitCast(mk_REP`SeqTypeRep(mk_REP`CharTypeRep()), s_v, nil))]
        else
          if cast
          then rb := rb ^ [BC`GenAsgnStmt(resVar_v, s_v)]
          else skip;
      return rb)
     );
   );
\end{vdm_al}

\begin{vdm_al}
GenMapOvwr: CGMAIN`VT * CGMAIN`VT * CGMAIN`VT * bool ==> seq of CPP`Stmt
GenMapOvwr( mk_CGMAIN`VT( seqmap_v, seqmapType), mk_CGMAIN`VT( modmap_v, modmapType ),
            mk_CGMAIN`VT( resVar_v, resType), cast ) ==
  if CPP`isCPP()
  then
    if cast
    then
      def mapType = CGAUX`FindPossibleMapType( seqmapType);
          tmpMap_v = BC`GiveName("tmpMap")
      in return DS`GenDecl( mapType, tmpMap_v, BC`GenAsgnInit( seqmap_v ) ) ^
                [ DS`GenMapOverride( tmpMap_v, modmap_v ),
                  BC`GenAsgnStmt( resVar_v, tmpMap_v ) ]
    else
      return [ BC`GenAsgnStmt(resVar_v, seqmap_v), DS`GenMapOverride(resVar_v, modmap_v) ]
  else
   (dcl castmap1 : CPP`Expr := seqmap_v,
        castmap2 : CPP`Expr := modmap_v,
        resmap : CPP`Expr := resVar_v;
        if not CGAUX`IsMapType(seqmapType)
        then castmap1 := DS`GenCastMap(seqmap_v);
        if not CGAUX`IsMapType(modmapType)
        then castmap2 := DS`GenCastMap(modmap_v);
        if not CGAUX`IsMapType(resType)
        then resmap := DS`GenCastMap(resVar_v);
    return [BC`GenAsgnStmt(resVar_v, DS`GenMapExpr(castmap1)),
            DS`GenMapOverride(resmap, castmap2)];
   );
\end{vdm_al}

\begin{vdm_al}
GenSeqMapDynOvwr: CGMAIN`VT * CGMAIN`VT * CGMAIN`VT ==> seq of CPP`Stmt
GenSeqMapDynOvwr( mk_CGMAIN`VT( seqmap_v, seqmapType), mk_CGMAIN`VT( modmap_v, modmapType),
                  mk_CGMAIN`VT( resVar_v, restp)  ) ==
  def condseq = DS`GenIsSeq( seqmap_v );
      condmap = DS`GenIsMap( seqmap_v );
      condstring = DS`GenIsString (seqmap_v);
      altseq1 = GenSeqOvwr(mk_CGMAIN`VT( seqmap_v, seqmapType),
                           mk_CGMAIN`VT( modmap_v, modmapType ),
                           mk_CGMAIN`VT( resVar_v, restp), true );
      altmap1 = GenMapOvwr(mk_CGMAIN`VT( seqmap_v, seqmapType),
                           mk_CGMAIN`VT( modmap_v, modmapType ),
                           mk_CGMAIN`VT( resVar_v, restp), true );
      altseq = BC`GenBlock(altseq1);
      altmap = BC`GenBlock(altmap1);
  in
   (dcl rerr : CPP`Stmt,
        rb : seq of CPP`Stmt;
    if CPP`isCPP()
    then rerr := CGAUX`RunTime("A map or sequence was expected in sequence or map override expression" )
    else rerr := CGAUX`RunTime("Wrong arguments for '++'");
    cases seqmapType:
      mk_REP`UnionTypeRep({tp}) -> if is_REP`SeqTypeRep(tp)
                                   then
                                     if CPP`isCPP()
                                     then rb := [ BC`GenIfStmt( condseq, altseq, rerr) ]
                                     else rb := altseq1
                                   else
                                     if CPP`isCPP()
                                     then rb := [ BC`GenIfStmt( condmap, altmap, rerr ) ]
                                     else rb := altmap1,
      others ->
        if CPP`isCPP()
        then rb := [ BC`GenIfStmt( condmap, altmap, BC`GenIfStmt( condseq, altseq, rerr ) ) ]
        else
          if CGAUX`IsPossibleStringType(seqmapType)
          then rb := [ BC`GenIfStmt( condmap, altmap, BC`GenIfStmt( condstring, altseq, rerr ) ) ]
          else rb := [ BC`GenIfStmt( condmap, altmap, BC`GenIfStmt( condseq, altseq, rerr ) ) ]

    end;
    return rb;
   );
\end{vdm_al}

\subsection{Field Select Expression}

Consider the field select expression below:

\begin{verbatim}
mk_A( 1, 3).b
\end{verbatim}

The corresponding pseudo code is listed below:

\begin{verbatim}
Record tmprec;
...CGExpr("mk_A(1, 3)", mk_CGMAIN`VT( tmprec, "Record" ) );
tmprec.GetField(2);  // it is assumed that the field selector "b"
                     // is the second field in the record.
\end{verbatim}

In this example the requirement that all specifications are free for
possible type errors in terms of the type checker is used: From this
we know that the record of with tag $A$ has a field $b$. However, in
some situations the type checker cannot state that a field dynamically
exists in a field select expression. Consider for example the
expression below:

\begin{verbatim}
let a = if b
        then mk_A(1, 2)
        else mk_B(1, 3)
in a.c
\end{verbatim}

and assume that following type definitions are valid within the scope of this example:

\begin{verbatim}
types
  A ::
   a : nat
   b : nat;

  B ::
   c : nat
   d : nat
\end{verbatim}

In this case we are forced to dynamically to check if the field
selector is valid for record in question.  In a similar way, in some
situations we need not investigate if the record in the field select
expression dynamically has the value of a record:

\begin{verbatim}
let a in set { mk_A(1, 2), mk_B(1, 3), { 1, 2,} }
in a.b
\end{verbatim}

and assume that the following type definitions are valid within the
VDM expression:

\begin{verbatim}
A ::
  a : nat
  b : nat;

B ::
  b : nat
  a : nat
\end{verbatim}

The corresponding pseudo code of the field select expression is listed
below:

\begin{verbatim}
Generic tmpRec;
...CGExpr( "a", mk_CGMAIN`VT( tmpRec, "Generic" ) );
if ( tmpRec.IsRecord() )
  if ( tmpRec.Is("A") )
    resVar_v = tmpRec.GetField(2);
  else if ( tmpRec.Is("B") )
       resVar_v = tmpRec.GetField(1);
       else
        RunTime( "Unknown record field selector" )
else
  RunTimeError("A record was expected" );
\end{verbatim}


Beside generating code for field select expressions the operation {\em
CGApplyExpr} also generates code for parts of state designators.
The generated pseudo code for state designators for the assign statement:

\begin{verbatim}
m(1)(2).b(3) := 49;
\end{verbatim}

The corresponding pseudo code is (see also Section \ref{sec:asgnstmt}):

\begin{verbatim}
Sequence level2 := m(1);
Record level3 := level2(2);
Map    level4 :=level3.GetField("b");
....
\end{verbatim}

The {\em CGFieldSelectExpr} generates code for
\verb+level3.GetField("b")+. In this case the expression that should
be applied (\verb+level3+) is a temporary variable.



The operation {\em CGFieldSelectExpr} takes following parameters:
\begin{description}
\item[ae:] The field select expressions

\item[resVar\_v:] The variable and type of the variable that the
result of the apply expression should be assigned.

\item[expr1:] In the case that the operation {\em CGFieldSelectExpr}
generates code for the state designator it takes the name of the
temporary variable.

\item[type1:] This is the type of the temporary variable {\em expr1}.
\end{description}

\begin{vdm_al}
CGFieldSelectExpr: AS`FieldSelectExpr * CGMAIN`VT * [CPP`Name] * [REP`TypeRep] ==> seq of CPP`Stmt
CGFieldSelectExpr( fexpr,mk_CGMAIN`VT( resVar_v, type ), expr1, type1 ) ==
  def mk_AS`FieldSelectExpr(rec, nm, -) = fexpr;
  in
#ifdef VDMSL
    if is_AS`Name(rec) and def tp = ENV`LookUpStateEnv(rec)
                           in
                             --is_REP`CompositeTypeRep(tp) and tp.nm = CGAUX`Combine2Names(CGAUX`GiveCurCASName(), rec)
                             is_REP`CompositeTypeRep(tp) and tp.nm = rec
    then return CGExpr(nm, mk_CGMAIN`VT( resVar_v, type ))
    else
#endif VDMSL
#ifdef VDMPP
    def ti = CGAUX`FindType (fexpr)
    in
      if is_REP`PartialFnTypeRep(ti) or is_REP`TotalFnTypeRep(ti) or is_REP`OpTypeRep (ti)
      then
       (CGAUX`SetNotSupportedException(true);
        return [CGAUX`NotSupported("Function value")])
      else
#endif VDMPP
       (dcl tmpRec : [CPP`Expr] := expr1,
            rec_stmt : seq of CPP`Stmt := [],
            tmpRecType : [REP`TypeRep] := type1,
            rb : seq of CPP`Stmt := rec_stmt;
        if expr1 = nil
        then 
          def mk_(e, stmts) = CGExprExcl(rec, "tmpRec", nil)
          in
           (tmpRec := e;
            rec_stmt := stmts;
            tmpRecType := TPGEN`RemoveInvType(CGAUX`FindType( rec ));
            rb := rec_stmt);
        
        def rectypes = FindAllRecTypes( tmpRecType );
#ifdef VDMPP
            oreftypes = FindAllObjRefTypes(tmpRecType);
#endif VDMPP
            posTypes = FindPossibleRecTypes( rectypes, nm )
#ifdef VDMPP
                       union FindPossibleObjRefTypes(oreftypes, nm)
#endif VDMPP
        in
          if posTypes <> {}
          then 
            rb := rb ^ FindFieldSelApply(nm, mk_CGMAIN`VT( resVar_v, type ),mk_CGMAIN`VT(tmpRec, tmpRecType) );
#ifdef VDMPP
        if CGAUX`IsUnionFunctionType (ti)
        then CGAUX`SetNotSupportedException(true);
        if CGAUX`IsUnionFunctionType (ti)
        then
          if CPP`isCPP()
          then
            if not is_REP`OverTypeRep(ti)
            then rb := rb ^ [BC`GenIfStmt(DS`GenIsClass (tmpRec), CGAUX`NotSupported("Function value"),nil)]
            else skip
          else
            def mk_REP`UnionTypeRep(t_s) = tmpRecType;
                ti_s = { ti | ti in set t_s & is_REP`ObjRefTypeRep(ti) };
                nm_s = { CGAUX`UnQClassType(objnm).nm | objnm in set ti_s &
                                          ENV`LookUpOpOrFnName(CGAUX`UnQClassType(objnm).nm,nm) <> nil }
            in rb := rb ^ [BC`GenIfStmt(DS`GenIsClasses (nm_s,tmpRec),
                                        CGAUX`NotSupported("Function value"),nil)]
        else skip;
#endif VDMPP
     return rb;
   );

\end{vdm_al}

The operation $FindAllRecTypes$ is an auxiliary operation to
$CGFieldSelectExpr$. It generates the set of all composite types which
is contained in a union type or a composite type itself.

\begin{vdm_al}
FindAllRecTypes: REP`TypeRep ==> set of REP`CompositeTypeRep
FindAllRecTypes(type) ==
cases type :
  mk_REP`TypeNameRep(-) -> return FindAllRecTypes(CGAUX`ExpandTypeRep(type,{})),
  mk_REP`CompositeTypeRep(-, -) -> return {type},
  mk_REP`UnionTypeRep(tps) -> (dcl recs : set of REP`CompositeTypeRep := {};
                               for all t in set tps do
                                 recs := recs union FindAllRecTypes( t );
                               return recs),
  mk_REP`InvTypeRep(-,shape,-) -> return FindAllRecTypes(shape),
  others -> return {}
end;

#ifdef VDMPP
FindAllObjRefTypes: REP`TypeRep ==> set of REP`ObjRefTypeRep
FindAllObjRefTypes(type) ==
cases type :
  mk_REP`ObjRefTypeRep(-) -> return {type},
  mk_REP`UnionTypeRep(tps) ->
    ( dcl refs : set of REP`ObjRefTypeRep := {};
      for all t in set tps do
        refs := refs union FindAllObjRefTypes( t );
      return refs ),
  others -> return {}
end;

FindPossibleObjRefTypes: set of REP`ObjRefTypeRep * AS`Name ==> set of REP`ObjRefTypeRep
FindPossibleObjRefTypes(tps, fsnm) ==
  return { mk_REP`ObjRefTypeRep(clnm) | mk_REP`ObjRefTypeRep(clnm) in set tps &
             ENV`IsInstanceVar(CGAUX`Combine2Names(clnm, fsnm)) };
#endif VDMPP

\end{vdm_al}

The next operation $FindFieldSelApply$ is an auxiliary operation to
the operation $CGFieldSelectExpr$. It generates the nested
if-then-else statement investigating which of the possible record type
$rectypes$ that the field selector $nm$ is to be applied dynamically
(see also the latter example of the corresponding pseudo code of a
field select).

\begin{vdm_al}
FindFieldSelApply: AS`Name * CGMAIN`VT * CGMAIN`VT ==> seq of CPP`Stmt
FindFieldSelApply( fsnm, mk_CGMAIN`VT( resVar_v, resTp ), mk_CGMAIN`VT( tmpRec, tmpRecType') ) ==
  def tmpRecType = CGAUX`RemoveNil(tmpRecType');
      rectypes = FindAllRecTypes( tmpRecType );
      posRecTypes = FindPossibleRecTypes( rectypes, fsnm );
#ifdef VDMPP
      oreftypes = FindAllObjRefTypes(tmpRecType);
      posORefTypes = FindPossibleObjRefTypes(oreftypes, fsnm);
#endif VDMPP
#ifdef VDMSL
      rti = BC`GenBlock([CGAUX`RunTime("A record was expected")])
#endif VDMSL
#ifdef VDMPP
      rti = BC`GenBlock([CGAUX`RunTime("An object or record was expected")])
#endif VDMPP
  in
   (dcl alt : [CPP`Stmt] := if is_REP`UnionTypeRep(tmpRecType) and
                               let tps = tmpRecType.tps
                               in
#ifdef VDMSL
                                (tps = posRecTypes)
#endif VDMSL
#ifdef VDMPP
                                (tps = posRecTypes union posORefTypes)
#endif VDMPP
                            then nil
                            else rti;
    if CPP`isCPP()
    then
     (if posRecTypes <> {}
      then
        if is_REP`CompositeTypeRep(tmpRecType) and card posRecTypes = 1
        then
          def {e} = posRecTypes;
              getfield = DS`GenRecGetFieldNm (tmpRec, e, fsnm);
          in return [BC`GenAsgnStmt(resVar_v, getfield)]
        else
          for all t in set posRecTypes do
           (dcl castrec : CPP`Expr := tmpRec;
            if not CGAUX`IsCompositeType(tmpRecType)
            then castrec := DS`GenCastType(t, tmpRec);
            def getfield = DS`GenRecGetFieldNm (castrec, t, fsnm);
                asgn = BC`GenBlock([BC`GenAsgnStmt (resVar_v, getfield)]);
                isRecord = DS`GenIsThisRecord(t, tmpRec)
            in
              if alt = nil
              then alt := asgn
              else alt := BC`GenIfStmt(isRecord, asgn, alt)
           );
#ifdef VDMPP
      if posORefTypes <> {}
      then
        if is_REP`ObjRefTypeRep(tmpRecType) and card posORefTypes = 1
        then
          def mk_REP`ObjRefTypeRep(clnm) = tmpRecType;
              objptr = DS`CastToClassPtr(clnm, tmpRec);
              getfield = BC`GenPointerToObjectMemberAccess( objptr, BC`Rename(fsnm) )
          in
            return [BC`GenAsgnStmt(resVar_v, getfield)]
        else
          for all otr in set posORefTypes do
            def clnm = otr.nm;
                objptr = DS`CastToClassPtr(clnm, tmpRec);
                getfield = BC`GenPointerToObjectMemberAccess( objptr, BC`Rename(fsnm) );
                l_asgn = BC`GenBlock([BC`GenAsgnStmt(resVar_v, getfield)]);
                if_cond = DS`GenAuxType(tmpRec, otr)
            in
              if alt = nil
              then alt := l_asgn
              else alt := BC`GenIfStmt(if_cond, l_asgn, alt);
#endif VDMPP
     )
    else -- java
      if is_REP`CompositeTypeRep(tmpRecType) and card posRecTypes = 1
      then
        def mk_REP`CompositeTypeRep(-, fields) = tmpRecType;
            i = FindField(fields,fsnm);
            mk_REP`FieldRep(-,type,-) = fields(i);
        in
         (dcl rec : CPP`Expr := tmpRec;
          --if not is_CPP`CastExpr(tmpRec)
          if is_CPP`CastExpr(tmpRec)
          then rec := BC`GenBracketedExpr(tmpRec);
          def getfield = BC`GenQualifiedName(rec, BC`Rename2(fsnm));
          in
           (dcl cast : CPP`Expr := getfield;
            if not CGAUX`IsSubType(type, resTp)
            then cast := DS`GenExplicitCast(resTp, getfield, type);
            return [BC`GenAsgnStmt(resVar_v, cast)]))
      else
       (for all ctr in set posRecTypes do
          def rec = BC`GenBracketedExpr(DS`GenCastType( ctr, tmpRec ));
              mk_REP`CompositeTypeRep(-, fields) = ctr;
              i = FindField(fields, fsnm);
              mk_REP`FieldRep(-, type, -) = fields(i);
              getfield = BC`GenQualifiedName(rec, BC`Rename2(fsnm));
          in
           (dcl cast : CPP`Expr := getfield;
            if not CGAUX`IsSubType(type, resTp)
            then cast := DS`GenExplicitCast(resTp, getfield, type);
            def l_asgn = BC`GenBlock([BC`GenAsgnStmt(resVar_v, cast)])
            in
              if alt = nil
              then alt := l_asgn
              else alt := BC`GenIfStmt(DS`GenIsThisRecord(ctr, tmpRec), l_asgn, alt)
           );
#ifdef VDMPP
         if posORefTypes <> {}
         then
          if is_REP`ObjRefTypeRep(tmpRecType) and card posORefTypes = 1
          then
            def rec = if is_CPP`CastExpr(tmpRec)
                      then BC`GenBracketedExpr(tmpRec)
                      else tmpRec;
                getfield = BC`GenQualifiedName(rec, BC`Rename2(fsnm))
            in
              return [BC`GenAsgnStmt(resVar_v, getfield)]
          else
            for all otr in set posORefTypes do
              def clnm = otr.nm;
                  rec = BC`GenBracketedExpr(DS`GenCastType( otr, tmpRec ));
                  getfield = BC`GenQualifiedName(rec, BC`Rename2(fsnm));
                  l_asgn = BC`GenBlock([BC`GenAsgnStmt(resVar_v, getfield)]);
                  if_cond = BC`GenTypeComp(BC`Rename(clnm), tmpRec)
              in
                if alt = nil
                then alt := l_asgn
                else alt := BC`GenIfStmt(if_cond, l_asgn, alt);
#endif VDMPP            
       ); -- end of for loop
    return CGAUX`StripCompoundStmt(alt);
   );
\end{vdm_al}

The next operation $FindPossibleRecTypes$ is an auxiliary function to
$FindFieldSelapply$. The operation takes two input parameters:

\begin{description}
\item{tps:} A set of CompositeTypeRep and,
\item{fsnm:} A field selector name.
\end{description}

The function computes the set of CompositeTypeRep which all have the
field selector name $fsnm$ in its list of field selector names.

\begin{vdm_al}
FindPossibleRecTypes: set of REP`CompositeTypeRep * AS`Name ==> set of REP`CompositeTypeRep
FindPossibleRecTypes( tps, fsnm) ==
  (dcl restps : set of REP`CompositeTypeRep := {};
   for all mk_REP`CompositeTypeRep(tagname, fields) in set tps do
     if exists mk_REP`FieldRep(name,-,-) in set elems fields & name = fsnm
     then restps := restps union { mk_REP`CompositeTypeRep(tagname, fields) };
   return restps);
\end{vdm_al}


\subsection{Record Modifier Expression}

This section describes the code generation of {\em record modifier
  expression}. Consider the expression below:

\begin{verbatim}
let a in set {mk_A(1,2), mk_B('a',5,7), mk_C(1), mk_(1,2)
  be st is_A(a) or is_B(a)  in
    mu(a, i |-> 10, j |-> 20)
\end{verbatim}

and assume that the following type definitions are valid within the
expression:

\begin{verbatim}
A:: i : nat
    j : nat;

B:: x : char
    j : int
    i : real;

C:: j : nat
\end{verbatim}

The pseudo code of the record modifier expression is listed below:

\begin{verbatim}
Generic tmpRE;
...CGExpr("a", CGMAIN`VT(tmpRec, "Generic"));
if (tmpRE.IsRecord()) {
  Record tmpRec = tmpRE;
  int mu1, mu2;
  if (tmpRec.Is("A")) {
    mu1 = 1;
    mu2 = 2;
  }
  else if (tmpRec.Is("B")) {
    mu1 = 3;
    mu2 = 2;
  }
  else
    RunTimeError("Unknown field selector in record modifier expression");
  Int val1;
  ...CGExpr("10", CGMAIN`VT(val1, "Int"));
  tmpRec.SetField(mu1, val1);
  Int val2;
  ...CGExpr("20", CGMAIN`VT(val1, "Int"));
  tmpRec.SetField(mu2, val2);
  resVar_v = tmpRec;
}
else
  RunTimeError("A record was expected in record modifier expression");
\end{verbatim}


The operation $CGRecordModifierExpr$ generates the code correspondin
to record modifier expressions.

\begin{vdm_al}
CGRecordModifierExpr: AS`RecordModifierExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGRecordModifierExpr(mk_AS`RecordModifierExpr(rec, mu_l, -),vt) ==
  def mk_(tmpRE, rec_stmt) = CGExprExcl(rec, "tmpRE", nil);
      tmpTp = CGAUX`FindType(rec)
  in
   (dcl rb_l : seq of CPP`Stmt,
        REVar : CPP`Name;
    if rec_stmt = []
    then (REVar := BC`GiveName("tmpRE");
      if CPP`isCPP()
      then rb_l := DS`GenDeclInit(tmpTp, REVar, tmpRE)
      else if CGAUX`IsCompositeType(tmpTp)
           then rb_l := DS`GenDeclInit(tmpTp, REVar,
                  DS`GenExplicitCast(tmpTp,BC`GenFctCall(BC`GenIdentifier("UTIL.clone"),[tmpRE]),nil))
           else rb_l := DS`GenDeclInit(tmpTp, REVar, tmpRE);)
    else (REVar := tmpRE;
          rb_l := rec_stmt);
    if CGAUX`IsCompositeType(tmpTp)
    then rb_l := rb_l ^ GenModifyFields(REVar, tmpTp, mu_l, vt)
    else
      def cond = DS`GenIsRecord(tmpRE);
          stmt_l = GenModifyFields(REVar, tmpTp, mu_l, vt );
          rti = BC`GenBlock([CGAUX`RunTime("A record was expected in record modifier expression")])
      in
        rb_l := rb_l ^ [BC`GenIfStmt(cond, BC`GenBlock(stmt_l), rti)];
    return rb_l);
\end{vdm_al}

The operation $GenModifyFields$ is an auxiliary operation to
$CGRecordModifierExpr$, which generates a sequence of C++ statements,
modifying the fields in $rec$.

\begin{vdm_al}
GenModifyFields: CPP`Name * REP`TypeRep * seq1 of AS`RecordModification * CGMAIN`VT ==> seq1 of CPP`Stmt
GenModifyFields(rec, recTp, mu_l, vt) ==
  let  mk_CGMAIN`VT(resVar,resTp) = vt
  in
   (dcl rb_l : seq of CPP`Stmt := [],
        tmpRec : CPP`Name := rec;
    if not CGAUX`IsCompositeType(recTp)
    then
     (tmpRec := BC`GiveName("tmpRec");
      if CPP`isCPP()
      then rb_l := rb_l ^ [BC`GenDecl(DS`GenRecordType(nil), tmpRec, BC`GenAsgnInit(rec))]
      else
        def cast = DS`GenCastRecord(BC`GenFctCall(BC`GenIdentifier("UTIL.clone"),[rec]), nil)
        in rb_l := rb_l ^ [BC`GenDecl(DS`GenRecordType(nil), tmpRec, BC`GenAsgnInit(cast))];);
    def fi = GenFieldInds(tmpRec, recTp, mu_l)
    in rb_l := rb_l ^ CGAUX`StripCompoundStmt(fi);
    if CPP`isCPP()
    then rb_l := rb_l ^ [BC`GenAsgnStmt(resVar, tmpRec)]
     else rb_l := rb_l ^ [BC`GenAsgnStmt(resVar, DS`GenExplicitCast(resTp,tmpRec,recTp))];
    return rb_l;);

\end{vdm_al}

The operation $GenFieldInds$ is an auxiliary operation to
$GenModifyFields$. $GenFieldInds$ generates the if-statemets, which
initializes the index variables, $mu_1, mu_1, \ldots, mu_n$.

\begin{vdm_al}
GenFieldInds: CPP`Name *  REP`TypeRep * seq1 of AS`RecordModification ==> CPP`Stmt
GenFieldInds(rec, recTp, mu_l) ==
  let errstmt = CGAUX`RunTime("Unknown record field selector in record modifier expression")
  in
   (dcl rectp_s : set of REP`CompositeTypeRep := FindAllRecTypes(recTp),
        postp_s : set of REP`CompositeTypeRep := rectp_s;
    for mk_AS`RecordModification(field, -, -) in mu_l do
      postp_s := postp_s inter FindPossibleRecTypes(rectp_s, field);

    cases postp_s: 
      {}     -> return errstmt,
      {t}    -> if CPP`isCPP()
                then 
                  (dcl stmt_l : seq of CPP`Stmt := [];
                   for mk_AS`RecordModification(field, newval, -) in mu_l do
                     def fieldno = DS`GenRecGetFieldNo(t, field);
                         mk_(val, val_stmt) = CGExprExcl(newval, "val", nil) 
                     in
                       stmt_l := stmt_l ^ val_stmt ^ [ DS`GenRecSetField(rec, fieldno, val) ];
                     return CGAUX`GenCPPStmt(stmt_l);)
                else
                  (dcl stmt_l : seq of CPP`Stmt := [];
                   let mk_REP`CompositeTypeRep(tagnm, fields) = t
                   in
                     for mk_AS`RecordModification(nm, newval,-) in mu_l do
                       def j = FindField(fields,nm);
                           mk_REP`FieldRep(-,type,-) = fields(j);
                           mk_(val, val_stmt) = CGExprExcl(newval, "val", nil);
                       in
                        (dcl cast : CPP`Expr := rec;
                         if not CGAUX`IsCompositeType(recTp)
                         then cast := BC`GenBracketedExpr(DS`GenCastRecord(rec,tagnm));
                         stmt_l := stmt_l ^ val_stmt;
                         stmt_l := stmt_l ^ [BC`GenAsgnStmt(BC`GenQualifiedName(cast,BC`Rename2(nm)),
                                                 DS`GenExplicitCast(type,val,CGAUX`FindType(newval)))];);
                   return CGAUX`GenCPPStmt(stmt_l);),
      others -> if CPP`isCPP()
                then
                  (dcl case_l : seq of (CPP`CaseStmt | CPP`DefaultStmt) := [];
                   for all t in set postp_s do
                     (dcl stmt_l : seq of CPP`Stmt := [];
                      for mk_AS`RecordModification(field, newval, -) in mu_l do
                        def fieldno = DS`GenRecGetFieldNo(t, field);
                            mk_(val, val_stmt) = CGExprExcl(newval, "val", nil)
                        in
                          stmt_l := stmt_l ^ val_stmt ^ [ DS`GenRecSetField(rec, fieldno, val) ];
                        case_l := case_l ^ [ BC`GenCaseStmt(BC`Rename(t.nm),
                                                            BC`GenBlock( stmt_l ^ [ BC`GenBreakStmt(nil) ] )) ];);
                   case_l := case_l ^ [ BC`GenDefaultStmt( BC`GenBlock( [errstmt, BC`GenBreakStmt(nil) ])) ];
                   --let tmpRec = if CGAUX`IsCompositeType(recTp)
                   --             then rec
                   --             else BC`GenCastExpr(DS`GenRecordType(nil), rec)
                   --in
                     return BC`GenSwitchStmt(DS`GenGetTag(rec), case_l);)
                else
                  (dcl ifs : CPP`Stmt := errstmt;
                   for all t in set postp_s do
                     def isRecord = DS`GenIsThisRecord(t, rec);
                         mk_REP`CompositeTypeRep(tagnm, fields) = t
                     in
                       (dcl stmt_l : seq of CPP`Stmt := [];
                        for mk_AS`RecordModification(nm, newval,-) in mu_l do
                          def j = FindField(fields, nm);
                              mk_REP`FieldRep(-,type,-) = fields(j);
                              mk_(val, val_stmt) = CGExprExcl(newval, "val", nil);
                              cast = BC`GenBracketedExpr(DS`GenCastRecord(rec,tagnm))
                          in
                            (stmt_l := stmt_l ^ val_stmt;
                             stmt_l := stmt_l ^ [BC`GenAsgnStmt(BC`GenQualifiedName(cast,BC`Rename2(nm)),
                                                           DS`GenExplicitCast(type,val,CGAUX`FindType(newval)))];);
                        ifs := BC`GenIfStmt(isRecord, CGAUX`GenCPPStmt(stmt_l), ifs););
                   return ifs;)
    end);

FindField: seq of REP`FieldRep * AS`Name ==> nat
FindField(fieldreps, nm) ==
  (for i = 1 to len fieldreps do
     if nm = fieldreps(i).sel
     then return i;
   return len fieldreps + 1);
\end{vdm_al}

\subsection{Quantified Expressions}

Consider the following quantified expressions:

\begin{verbatim}
forall x in set {1, 2}, y in set {2, 3} & x < y +1
exists x in set {1, 2, 3} & x rem 2 <> 0
exists1 x in set {1, 2, 3, 56} & x rem 2 = 0
\end{verbatim}

Within this version of the code generator {\em unique existential
quantification\/} is not supported.

The code generation of quantified expressions uses the auxiliary
function $CGComprehension$. The pseudo code corresponding to the
universal quantification example above is listed below:

\begin{verbatim}
bool tmpQuant = true;
...CGComprehension( "x in set {1, 2}, y in set {2, 3}",
                    "x < y + 1",
                    "{}",  // Empty block statement
                    "tmpQuant",
                    "tmpQuant = false" );
resVar_v = (Bool) tmpQuant;
\end{verbatim}

The pseudo code corresponding to the existential quantification example
above is listed below:

\begin{verbatim}
bool tmpQuant = false;
...CGComprehension( "x in set {1, 2, 3}",
                    "x rem 2 <> 0",
                    tmpQuant = true,
                    "!tmpQuant",
                    nil );
resVar_v = (Bool) tmpQuant;
\end{verbatim}

The pseudo code corresponding to the unique existential quantification
example above is listed below:

\begin{verbatim}
bool tmpQuant = 0;
...CGComprehension( "x in set {1, 2, 3, 56}",
                    "x rem 2 = 0",
                    "tmpQuant++",
                    "tmpQuant <= 2",
                    nil );
resVar_v = (Bool) tmpQuant == 1;
\end{verbatim}

\begin{vdm_al}
CGAllOrExistsExpr: AS`QuantExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGAllOrExistsExpr(quant, mk_CGMAIN`VT(resVar_v, -)) ==
  def tmpQuant_v = BC`GiveName("tmpQuant");
      pid_m = CGAUX`FindPatIdMap(quant)
  in
   (dcl rb : seq of CPP`Stmt := [],
        res : CPP`Expr;
        --bval : CPP`Expr;
    CGAUX`PushEnv();
    def - = CGAUX`InsertNamesinEnv(dom pid_m) in skip;
    cases quant:
      mk_AS`AllOrExistsExpr(<ALL>, bind_l, pred, -) ->
         let qinit = BC`GenAsgnInit(BC`GenBoolLit(true)),
             --np = BC`GenAsgnStmt(tmpQuant_v, BC`GenBoolLit(false))
             np = BC`GenBlock([BC`GenAsgnStmt(tmpQuant_v, BC`GenBoolLit(false))])
         in
          (rb := [ BC`GenDecl(DS`GenSmallBoolType(), tmpQuant_v, qinit),
                   CGComprehension(bind_l, pred, [], tmpQuant_v, np, pid_m, true) ];
           res := tmpQuant_v),
      mk_AS`AllOrExistsExpr(<EXISTS>, bind_l, pred, -) ->
         let qinit = BC`GenAsgnInit(BC`GenBoolLit(false)),
             stmt = BC`GenAsgnStmt(tmpQuant_v, BC`GenBoolLit(true)),
             contexpr = BC`GenNot(tmpQuant_v)
         in
           (rb := [ BC`GenDecl(DS`GenSmallBoolType(), tmpQuant_v, qinit),
                    CGComprehension(bind_l, pred, [stmt], contexpr, nil, pid_m, true) ];
            res := tmpQuant_v),
      mk_AS`ExistsUniqueExpr(mk_AS`SetBind(pat, expr, cid), pred, -) ->
         let qinit = BC`GenAsgnInit(BC`GenIntegerLit(0)),
             bind_l = [mk_AS`MultSetBind([pat], expr,cid)],
             stmt = BC`GenExpressionStmt(BC`GenPostPlusPlus(tmpQuant_v)),
             --contexpr = BC`GenBracketedExpr(BC`GenLeq(tmpQuant_v, BC`GenIntegerLit(2)))
             contexpr = BC`GenBracketedExpr(BC`GenLt(tmpQuant_v, BC`GenIntegerLit(2)))
         in
          (rb := [ BC`GenDecl(DS`GenSmallIntType(), tmpQuant_v, qinit),
                   CGComprehension(bind_l, pred, [stmt], contexpr, nil, pid_m, true) ];
           res := BC`GenEq(tmpQuant_v, BC`GenIntegerLit(1))),
      others -> (CGAUX`PopEnv();
                CGAUX`SetNotSupportedException(true);
                return [CGAUX`NotSupported("type bind")])
    end;
    rb := rb ^ [ BC`GenAsgnStmt(resVar_v, DS`GenBoolExpr(res)) ];
    CGAUX`PopEnv();
    return rb);
\end{vdm_al}


\subsection{Iota Expression}

In this section the specification of code generation of iota
expression is described. Consider the iota expression:

\begin{verbatim}
iota x in set {1, 2, 3} & x rem 2 = 0
\end{verbatim}

The corresopnding pseudo code is listed below:

\begin{verbatim}
int count = 0;
bool succ = true;
Set tmpSet;
Bool tmpB;
...CGEXPR{1, 2, 3}", mk_CGMAIN`VT(tmpVar, "Set"));
Int x;
...DS`GenIterSet(mk_CGMAIN`VT(tmpSet, "Set"),
                 count <= 2,
                 mk_CGMAIN`VT(e, "Int"),
                 "{ bool succ true;
                    ...PM`CGPatternMatch("x", mk_CGMAIN`VT(e, "Int"));
                    if (succ) {
                      ...CGExpr("x rem 2 = 0", mk_CGMAIN`VT(tmpB, "Bool"))
                      if (tmpB.GetValue()) {
                        count++;
                        resVar_v = e;
                      }
                    }
                  }");
if (count != 1)
  RunTimeError("No unique element in 'iota'");
\end{verbatim}

The operation $CGIotaExpr$ generates the code corresponding to a iota %% type error
expression.


\begin{vdm_al}
CGIotaExpr: AS`IotaExpr * CGMAIN`VT ==> seq of CPP`Stmt
CGIotaExpr(mk_AS`IotaExpr(bind, pred, -), mk_CGMAIN`VT(resVar, resTp)) ==
if is_AS`TypeBind(bind)
then
  (CGAUX`SetNotSupportedException(true);
  return [CGAUX`NotSupported("type bind")])
else
  def mk_AS`SetBind(pat, expr,-) = bind;
      count = BC`GiveName("count");
      setType = CGAUX`FindType(expr);
      pid_pat_s = dom CGEXPR`FindPatternId(pat);
      pid_expr_s = CGAUX`FindAllNamesInExpr(expr);
      mk_(tmpSet1, set_stmt) = CGEXPR`CGExprExcl(expr, "tmpSet", nil); -- first
      decl = DeclarePatVars(pat); -- second -- must be after CGExprExcl and before CGExprExcl and CGPatternMatchExcl
  in
   (dcl rb_l : seq of CPP`Stmt := set_stmt,
        tmpSet : CPP`Expr := BC`GiveName("tmpSet");
    if (pid_pat_s inter pid_expr_s) <> {} or not is_AS`Name(expr)
    then rb_l := rb_l ^ DS`GenConstDeclInit(setType, tmpSet, tmpSet1)
    else tmpSet := tmpSet1;
    if not CGAUX`IsSetType(setType)
    then
      def tmpSet' = BC`GiveName("tmpSet");
          cond = DS`GenIsSet(tmpSet);
          rti =BC`GenBlock([CGAUX`RunTime("A set was expected")])
      in
       (rb_l := rb_l ^ [BC`GenIfStmt(BC`GenNot(cond), rti, nil)];
        if CPP`isCPP()
        then rb_l := rb_l ^ [BC`GenDecl(DS`GenSetType(), tmpSet', BC`GenAsgnInit(tmpSet))]
        else rb_l := rb_l ^ [BC`GenDecl(DS`GenSetType(), tmpSet', BC`GenAsgnInit(DS`GenCastSetType(tmpSet)))];
        tmpSet := tmpSet');

    def tmpElem = BC`GiveName("tmpElem");
        succ = BC`GiveName("succ");
        settp = CGAUX`FindSetElemType(setType);
        elemVT = mk_CGMAIN`VT(tmpElem, settp);
        bt = mk_REP`BooleanTypeRep();
        mk_(tmpB, pr_stmt) = CGExprExcl(pred, "tmpB", nil); -- third
        pred_type = CGAUX`FindType(pred);
        --if_then = [BC`GenExpressionStmt(BC`GenPostPlusPlus(count)),
        --           BC`GenAsgnStmt(resVar, tmpElem)]
    in
     (dcl if_then : seq of CPP`Stmt := [BC`GenExpressionStmt(BC`GenPostPlusPlus(count))],
          stmts : seq of CPP`Stmt := pr_stmt,
          pred_v : CPP`Expr := tmpB;
      if CPP`isCPP()
      then if_then := if_then ^ [BC`GenAsgnStmt(resVar, tmpElem)]
      else
         if CGAUX`IsSubType(settp, resTp)
         then if_then := if_then ^ [BC`GenAsgnStmt(resVar, tmpElem)]
         else if_then := if_then ^ [BC`GenAsgnStmt(resVar, DS`GenCastType(resTp, tmpElem))];
 
      if CGAUX`IsBoolType(pred_type)
      then stmts := stmts ^ [BC`GenIfStmt(DS`GenGetValue(pred_v, bt), BC`GenBlock(if_then), nil)]
      else
       (if not is_CPP`Identifier(tmpB)
        then
         (pred_v := BC`GiveName("pred");
          stmts := stmts ^ DS`GenDecl (pred_type, pred_v, BC`GenAsgnInit(tmpB)));
        stmts := stmts ^ [BC`GenIfStmt(BC`GenNot(DS`GenIsBool(pred_v)),
                                       BC`GenBlock([CGAUX`RunTime("A boolean was expected")]), nil),
                          BC`GenIfStmt(DS`GenGetValue(BC`GenCastExpr(DS`GenBoolType(), pred_v), bt),
                                       BC`GenBlock(if_then), nil)]);
      def mk_(pm, Is_excl) = PM`CGPatternMatchExcl(pat, elemVT, {}, succ, nil, stmts, false); -- fourth
          pm1 = if Is_excl
                then pm
                else [BC`GenDecl(DS`GenSmallBoolType(), succ, BC`GenAsgnInit(BC`GenBoolLit(false)))]
                     ^ pm;
          cexpr = BC`GenBracketedExpr(BC`GenLt(count, BC`GenIntegerLit(2)));
          setVT = mk_CGMAIN`VT(tmpSet, mk_REP`SetTypeRep(settp));
          body_l = MergeStmts( decl, pm1 );
          cond = BC`GenNeq(count, BC`GenIntegerLit(1));
          rti = BC`GenBlock([CGAUX`RunTime("No unique element in 'iota'")]);
  
      in 
       (rb_l := rb_l ^ [BC`GenDecl(DS`GenSmallIntType(), count, BC`GenAsgnInit(BC`GenIntegerLit(0)))];
        rb_l := rb_l ^ DS`GenIterSet(setVT, cexpr, elemVT, body_l);
        rb_l := rb_l ^ [BC`GenIfStmt(cond, rti, nil)];
       );
       return [ BC`GenBlock(rb_l) ];
     );
  );
\end{vdm_al}


\subsection{Is Expression}

Consider the VDM examples of is expressions below:

\begin{verbatim}
  is_A( mk_A( a, b) )
  is_bool( 5 )
  is_nat( 0 )
\end{verbatim}


\begin{vdm_al}
CGIsExpr: AS`IsExpr * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGIsExpr( mk_AS`IsExpr( type, arg, - ), mk_CGMAIN`VT( resVar_v, - ) ) ==
  def argTmpType = CGAUX`FindType( arg );
      mk_(argTmp_v, arg_stmt) = CGExprExcl(arg, "argTmp", nil)
  in
    (dcl rb : seq of CPP`Stmt := arg_stmt;
     if is_AS`BooleanType( type ) or
        is_AS`NumericType( type ) or
        is_AS`TokenType( type ) or
        is_AS`CharType( type )
     then
       def typerep = CGAUX`FromAS2RepType( type )
       in if CPP`isCPP()
          then if rb = []
               then return DS`GenIsType(argTmp_v, typerep)
               else def asgn = BC`GenAsgnStmt( resVar_v, DS`GenIsType( argTmp_v, typerep))
                    in rb := rb ^ [asgn]
          else
           (dcl argTmpCast : CPP`Expr := argTmp_v;
            if not (CGAUX`IsSubType(argTmpType, typerep) or
                                   DS`GenType(argTmpType).tp = BC`GenIdentifier("Object"))
            then argTmpCast := BC`GenCastExpr(BC`GenTypeSpecifier(BC`GenIdentifier("Object")), argTmp_v);
            if rb = []
            then return DS`GenIsType(argTmpCast, typerep)
            else def asgn = BC`GenAsgnStmt( resVar_v, DS`GenIsType( argTmpCast, typerep))
                 in rb := rb ^ [asgn];
           )
     else
       if CPP`isCPP()
       then
         def expr_c = DS`GenAuxType(argTmp_v, CGAUX`LOT(mk_REP`TypeNameRep(type)))
         in rb := rb ^ [ BC`GenAsgnStmt( resVar_v, BC`GenCastExpr(DS`GenBoolType(), expr_c)) ]
       else
        (dcl argTmpCast : CPP`Expr := argTmp_v;
         if not CGAUX`IsCompositeType(argTmpType)
         then argTmpCast := BC`GenCastExpr(BC`GenTypeSpecifier(BC`GenIdentifier("Object")), argTmp_v);
         if CGAUX`IsCompositeType(argTmpType)
         then
           rb := rb ^ [ BC`GenAsgnStmt( resVar_v, DS`GenBoolExpr(DS`GenEqTag( type, argTmpCast )))]
         else
           rb := rb ^ [ BC`GenIfStmt( DS`GenIsRecord( argTmpCast ), -- behoever man vel ikke
                    BC`GenAsgnStmt( resVar_v, DS`GenBoolExpr(DS`GenEqTag( type, argTmpCast ))),
                    BC`GenAsgnStmt( resVar_v, DS`GenBoolExpr(BC`GenBoolLit(false))) ) ];
        );
     return rb);
\end{vdm_al}

\subsection{Prefix Expression}

\begin{vdm_al}
CGPrefixExpr: AS`PrefixExpr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGPrefixExpr( mk_AS`PrefixExpr( opr, arg, - ), vt ) ==
  cases opr :
    <NUMMINUS>,
    <NUMPLUS>,
    <NUMABS>,
    <FLOOR>             -> return CGUnaryNum(opr, arg, vt ),
    <NOT>               -> return CGUnaryNot(arg, vt ),
    <SETCARD>,
    <SETDISTRUNION>,
    <SETDISTRINTERSECT>,
    <SETPOWER>          -> return CGUnarySet(opr, arg, vt ),
    <SEQLEN>,
    <SEQDISTRCONC>,
    <SEQELEMS>,
    <SEQINDICES>,
    <SEQTAIL>,
    <SEQHEAD>,
    <SEQREVERSE>        -> return CGUnarySeq(opr, arg, vt ),
    <MAPDOM>,
    <MAPRNG>,
    <MAPINVERSE>,
    <MAPDISTRMERGE>     -> return CGUnaryMap(opr, arg, vt ),
    others -> error
  end;
\end{vdm_al}

\subsubsection{Unary PrefixExpression on Numbers}

Consider the following VDM example:
\begin{verbatim}
let a = cases b:
         mk_A() -> 2,
         mk_B() -> 2.3,
         mk_C() -> false
        end
in -a
\end{verbatim}

The type of the identifier $a$ will be a union type of the basic types
of real, nat1 and boolean.

The corresponding pseudo code of the unary expression $-a$ is listed below:

\begin{verbatim}
Generic tmpArg;
...CGExpr( "-a", mk_CGMAIN`VT( tmpArg, "Generic" ) )
if ( !(tmpArg.IsReal() || tmpArg.IsInt() )
   RunTimeError("A number was expected");
else
  resVar_v = tmpArg.UnaryMinus();
\end{verbatim}

That is, we require that the implementation of basic data types
provides a function which takes a numerical and returns the negation
of the value in object. The object might be declared as the
correspondence of a union type, that is, in the \MCL{} as a $Generic$ type.


\begin{vdm_al}
CGUnaryNum: AS`UnaryOp * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGUnaryNum( opr, arg, vt ) ==
  def argTmpType = CGAUX`FindType(arg);
      mk_(argTmp, arg_stmt) = CGExprExcl(arg, "unArg", nil);
  in
   (dcl argTmp' : CPP`Expr := argTmp,
        rb_l : seq of CPP`Stmt := arg_stmt;
    if <NUMMINUS> = opr
    then
      if is_AS`BracketedExpr( arg ) and arg_stmt = []
      then argTmp' := BC`GenBracketedExpr(argTmp);

    let rc1 = mk_CGMAIN`VT( argTmp', argTmpType )
    in
     (dcl alt2 : CPP`Expr | seq of CPP`Stmt;
      if is_REP`UnionTypeRep( argTmpType ) and not CGAUX`IsNumType(argTmpType)
      then
        def cond = DS`GenIsReal( argTmp );
        in rb_l := rb_l ^ [BC`GenIfStmt( BC`GenNot( cond ),
                               BC`GenBlock([CGAUX`RunTime("A number was expected")]), nil ) ];
      
      cases opr:
        <NUMPLUS>  -> alt2 := DS`UnaryPlus( vt, rc1 ),
        <NUMMINUS> -> alt2 := DS`UnaryMinus( vt, rc1 ),
        <NUMABS>   -> alt2 := DS`UnaryAbs( vt, rc1 ),
        <FLOOR>    -> alt2 := DS`UnaryFloor( vt, rc1 ),
        others     -> error
      end;

      if CGAUX`IsSeqOfCPPStmt( alt2 )
      then return rb_l ^ alt2
      else
        if rb_l = []
        then return alt2
        else
          let mk_CGMAIN`VT( resVar_v, - ) = vt
          in return rb_l ^ [BC`GenAsgnStmt( resVar_v, alt2 )];
     );
   );
\end{vdm_al}

\subsubsection{Unary Boolean Operations}

Consider the following VDM example

\begin{verbatim}
let a = if b
        then false
        else { 1|->3}
in not a
\end{verbatim}

The corresponding pseudo code of the negation expression is listed below:

\begin{verbatim}
Generic arg;
...CGExpr( "a", mk_CGMAIN`VT( arg, "Generic" ) );
if ( arg.IsBool() )
  resVar_v = Bool ( ! Bool (arg).GetValue() );
else
  RunTime("A boolean was expected" );
\end{verbatim}

If the type of the argument in the negation expression is not a union
type the corresponding pseudo code is slightly more simple. Consider the example below:

\begin{verbatim}
if not ( a = 3 )
then ..
\end{verbatim}

In this case the corresponding pseudo code is:

\begin{verbatim}
Bool arg;
...CGExpr( "a = 3", mk_CGMAIN`VT( arg, "Bool" ) );
resVar_v = Bool( ! arg.GetValue() );
\end{verbatim}

\begin{vdm_al}
CGUnaryNot: AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGUnaryNot( arg, mk_CGMAIN`VT( resVar_v, - ) ) ==
  def argTmpType = CGAUX`FindType(arg);
      mk_(argTmp, arg_stmt) = CGExprExcl(arg, "unArg", nil);
  in
   (dcl rb_l : seq of CPP`Stmt := arg_stmt;
    if not CGAUX`IsBoolType( argTmpType )
    then rb_l := rb_l ^ [BC`GenIfStmt( BC`GenNot(DS`GenIsBool( argTmp )),
                                  BC`GenBlock([CGAUX`RunTime("A boolean was expected")]),
                                                 nil ) ];
    let bt = mk_REP`BooleanTypeRep()
    in
     (dcl cast : CPP`Expr := argTmp,
          expr : CPP`Expr;
      if not CGAUX`IsBoolType( argTmpType )
      then cast := DS`GenCastType( bt, argTmp);
      if CPP`isCPP()
      then
        if CGAUX`IsBoolType( argTmpType )
        then expr := BC`GenNot( BC`GenBracketedExpr( cast ) )
        else expr := BC`GenNot( cast )
      else
        def bv = BC`GenNot( DS`GenGetValue( cast, bt ));
        in expr := DS`GenBoolExpr(bv);
      if rb_l = []
      then return expr
      else return rb_l ^ [BC`GenAsgnStmt( resVar_v, expr )];
     );
   );
\end{vdm_al}

\subsubsection{Unary Set Operations}

It might be necessary to cast the argument expression $argTmp$ of
a unary set operation in case this has been declared as the
corresponding type of a union type. This can occur in an example as
shown below:

\begin{verbatim}
let a = if b
        then { 1, 3}
        else { 1 |-> 3}
in card a
\end{verbatim}

The corresponding pseudo code is listed below:

\begin{verbatim}
Generic tmpArg;
...CGExpr( "a", mk_CGMAIN`VT( tmpArg, "Generic" ) );
resVar_v = Int ( Set ( argTmp ).Card() );
\end{verbatim}

whereas if variable $argTmp$ has been declared as a set type the
corresponding pseudo code look like:

\begin{verbatim}
Set tmpArg;
...CGExpr( "a", mk_CGMAIN`VT( tmpArg, "Set" ) );
resVar_v = Int ( argTmp.Card() );
\end{verbatim}

\NYI Regarding casting appropriately.

\begin{vdm_al}
CGUnarySet: AS`UnaryOp * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGUnarySet( opr, arg, vt ) ==
  def argTmpType = CGAUX`FindType(arg);
      mk_(argTmp, arg_stmt) = CGExprExcl(arg, "unArg", nil);
  in
   (dcl rb_l : seq of CPP`Stmt := arg_stmt,
        alt2 : seq of CPP`Stmt | CPP`Expr;

    if not CGAUX`IsSetType(argTmpType)
    then rb_l := rb_l ^ [BC`GenIfStmt( BC`GenNot( DS`GenIsSet( argTmp )),
                                BC`GenBlock([CGAUX`RunTime("A set was expected" )]), nil ) ];
    cases opr:
      <SETCARD>           -> alt2 := CGSetCard(argTmp, argTmpType, vt ),
      <SETDISTRUNION>     -> alt2 := CGSetDistrUnion(argTmp, argTmpType, vt ),
      <SETDISTRINTERSECT> -> alt2 := CGSetDistrInterSect(argTmp, argTmpType, vt ),
      <SETPOWER>          -> alt2 := CGUnarySetPower(argTmp, argTmpType, vt ),
      others              -> error
    end;

    if CGAUX`IsSeqOfCPPStmt( alt2 )
    then return rb_l ^ alt2
    else
      if rb_l = []
      then return alt2
      else
        let mk_CGMAIN`VT( resVar_v, - ) = vt
        in return rb_l ^ [BC`GenAsgnStmt( resVar_v, alt2 )];
   );
\end{vdm_al}

\begin{vdm_al}
CGSetCard: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr
CGSetCard( argTmp, argTmpType, - ) ==
 (dcl argexpr : CPP`Expr := argTmp;
  if not CGAUX`IsSetType(argTmpType)
  then argexpr := DS`GenCastSetType(argTmp);
  return DS`GenCard( argexpr );
 );
\end{vdm_al}

Consider the VDM expression below:

\begin{verbatim}
dunion { {2}, {3}, {{3}} }
\end{verbatim}

The corresponding pseudo code is listed below:

\begin{verbatim}
Set tmpArg;
...CGExpr( "{ {2}, {3}, {{3}} }", mk_CGMAIN`VT( tmpArg, "Set" ) );
Set rduset; // Temporary variable to contain the result of the evalution
            // of distributed union operation.
Generic eg;
for ( int bb = tmpArg.First( eg ); bb; bb = tmpArg.Next( eg ) )
  {
    Set e = eg;
    rduset.ImpUnion( e );
  }
resVar_v = rduset;
\end{verbatim}

Consider the following VDM expression below:

\begin{verbatim}
dunion { {2}, {3}, if b
                   then 3
                   else {4} } \end{verbatim}

In this case the type of the argument of the the $dunion$ operator
is a set of the union type of set of nat and nat.

In this case wee need to investigate dynamically if the values in the
set is of set values. The corresponding pseudo code of this example is listed below:

\begin{verbatim}
Set tmpArg;
...CGExpr( "{ {2}, {3}, if b then 3 else {4} }", mk_CGMAIN`VT( tmpArg, "Set" ) );
Set rduset; // Temporary variable to contain the result of the evalution
            // of distributed union operation.
Generic eg;
for (int bb = tmpArg.First(eg); bb; bb = tmpArg.Next(eg)) {
  Generic e = eg; // The elements of the set are of type union.
  rduset.ImpUnion( Set (e) )
}
resVar_v = rduset;
\end{verbatim}


\begin{vdm_al}
CGSetDistrUnion: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSetDistrUnion( argexpr, argtype, mk_CGMAIN`VT( resVar_v, - ) ) ==
  if CPP`isJAVA()
  then
    def rduset_v = BC`GiveName("rduset");
        rdusetType = CGAUX`FindPosResSetTypeInSetDistrUnion( argtype );
        e_v = BC`GiveName( "e" );
    in
     (dcl castargexpr : CPP`Expr := argexpr,
          todo : CPP`Stmt,
          rb : seq of CPP`Stmt := DS`GenDeclEmptySet(rduset_v),
          argS : CPP`Expr := argexpr;
      if not CGAUX`IsSetType(argtype)
      then castargexpr := DS`GenCastSetType(argexpr);
      if CGAUX`IsSetType(rdusetType)
      then todo := DS`GenSetUnion(rduset_v, e_v)
      else todo := DS`GenSetUnion(rduset_v, DS`GenCastSetType(e_v));
      if not CGAUX`IsSetType (argtype) or not is_CPP`Identifier(argexpr)
      then
       (argS := BC`GiveName ("argS");
        rb:= rb ^ DS`GenDeclSet (argS, castargexpr);
       );
      rb := rb ^  DS`GenIterSet( mk_CGMAIN`VT(argS, mk_REP`SetTypeRep(rdusetType)), nil,
                                 mk_CGMAIN`VT(e_v, rdusetType), [todo] );
      rb := rb ^ [ BC`GenAsgnStmt(resVar_v, rduset_v) ];
      return rb;
     )
  else
   (dcl argexpr : CPP`Expr := argexpr;
    if not CGAUX`IsSetType(argtype)
    then argexpr := DS`GenCastSetType(argexpr);
    return DS`GenDUnion( argexpr );
   );
\end{vdm_al}

The code generation of a distributed intersection operation is almost
similiar to code generation of a distrisbuted union operation, the
annotations of the distributed intersection operation is therefore limited.

Consider the next VDM example of a distributed intersection operation:

\begin{verbatim}
dinter { {1}, {2,1}, {1,3} }
\end{verbatim}

The corresponding pseudo code of this example is listed below:

\begin{verbatim}
Set tmpArg;
...CGExpr("{ {1}, {2,1}, {1, 3} }", mk_CGMAIN`VT(tmpArg, "Set"));
Set rdiset = tmpArg.GetElem ();
            // Temporary variable to contain the result of the evaluaton
            // of a distributed intersection operation.
Generic eg;
for (int bb = tmpArg.First(eg); bb; bb = tmpArg.Next(eg))
  rdiset.Intersect(eg);
resVar_v = rduset;
\end{verbatim}


\begin{vdm_al}
CGSetDistrInterSect: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSetDistrInterSect(argexpr, argtype, mk_CGMAIN`VT(resVar_v, -)) ==
  if CPP`isJAVA()
  then
   (def rdiset_v = BC`GiveName("rdiset");
      rdisetType = CGAUX`FindPosResSetTypeInSetDistrUnion(argtype);
      e_v = BC`GiveName( "e" )
    in
     (dcl castargexpr : CPP`Expr := argexpr,
          todo : CPP`Stmt,
          rb : seq of CPP`Stmt := [],
          argS : CPP`Expr := argexpr;
      if not CGAUX`IsSetType(argtype)
      then castargexpr := DS`GenCastSetType(argexpr);
      if CPP`isCPP()
      then todo := DS`GenInterSectStmt(rdiset_v, e_v)
      else
        if CGAUX`IsSetType(rdisetType)
        then todo := DS`GenInterSectStmt(rdiset_v, e_v)
        else todo := DS`GenInterSectStmt(rdiset_v, DS`GenCastSetType(e_v));
      if not CGAUX`IsSetType (argtype) or not is_CPP`Identifier(argexpr)
      then
       (argS := BC`GiveName ("argS");
        rb:= rb ^ DS`GenDeclSet (argS, castargexpr);
       );
      def rdisetInit = DS`GenSetGetElemExpr(argS)
      in
        rb := rb ^ DS`GenDeclSet(rdiset_v, DS`GenCastSetType(rdisetInit));
      rb := rb ^ DS`GenIterSet(mk_CGMAIN`VT(argS, mk_REP`SetTypeRep(rdisetType)), nil,
                               mk_CGMAIN`VT(e_v, rdisetType), [todo] );
      rb := rb ^ [ BC`GenAsgnStmt(resVar_v, rdiset_v)];
      return rb;
     );
   )
  else
   (dcl argexpr : CPP`Expr := argexpr;
    if not CGAUX`IsSetType(argtype)
    then argexpr := DS`GenCastSetType(argexpr);
    return DS`GenDInter( argexpr );
   );
\end{vdm_al}


Consider the VDM expression below:

\begin{verbatim}
power { 2, 4}
\end{verbatim}

which is the set of all subsets of the set, that is,

\begin{verbatim}
power { 2, 4} = {{},{2},{4},{2, 4}}
\end{verbatim}

The corresponding pseudocode is listed below:

\begin{verbatim}
Set tmpArg;
...CGExpr( "{ 2, 4}", mk_CGMAIN`VT( tmpArg, "Set" ) );
Set rpowset; // Temporary variable to contain the result of the evalution
            // of the set power operation.
Generic eg;
long pow_card = (long) pow ( 2, tmpArg.Card() ); // The cardinality of
                                                 // rpowset.
for ( long ii = 0; ii < pow_card; ii++ )
  {
    Set tmp_s;
    for ( int jj = 0, bb = tmpArg.First( eg ); bb; bb =
                                  tmpArg.Next(eg), jj++  )
      if ( ii & ( 1 << jj ) )
        tmp_s.Insert( eg );
    rpowset.Insert( tmp_s );
  }
resVar_v = rpowset;
\end{verbatim}


\begin{vdm_al}

CGUnarySetPower: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGUnarySetPower(argTmp, argTp, mk_CGMAIN`VT(resVar_v, -)) ==
 (dcl argexpr : CPP`Expr := argTmp;
  if not CGAUX`IsSetType(argTp)
  then argexpr := DS`GenCastSetType(argTmp);
  if CPP`isCPP()
  then
     (dcl argexprTmp : CPP`Expr := argexpr;
      if not is_CPP`Identifier(argexpr)
      then argexprTmp := BC`GiveName("argS");
      def max = BC`GenIfStmt( BC`GenGt (DS`GenCard_int(argexprTmp), BC`GenIntegerLit( 25 ) ),
                    BC`GenBlock([CGAUX`RunTime("Set too big for 'power' - limit is 25")]),
                              nil )
      in
       (dcl rb : seq of CPP`Stmt := [];
        if not is_CPP`Identifier(argexpr)
        then rb := rb ^ DS`GenDeclSet(argexprTmp, argexpr);
        rb := rb ^ [max];
        rb := rb ^ [BC`GenAsgnStmt(resVar_v, DS`GenPower(argexprTmp))];
        return rb)
     )
  else -- Java
    def rpowset_v = BC`GiveName("rpowset");
        max = BC`GenIfStmt( BC`GenGt(DS`GenCard_int(argexpr), BC`GenIntegerLit( 25 )),
                    BC`GenBlock([CGAUX`RunTime("Set too big for 'power' - limit is 25")]),
                            nil );
        elem_v = BC`GiveName("elem");
        elemSet_v = BC`GiveName("elemSet");
        tmpSet_v = BC`GiveName("tmpSet");
        e_t = CGAUX`FindSetElemType(argTp);
        inner_inner_rb = DS`GenDeclSet(tmpSet_v, elemSet_v) ^
                         [DS`GenSetInsert(tmpSet_v, elem_v),
                          DS`GenSetInsert(rpowset_v, tmpSet_v)];
        inner_rb = DS`GenIterSet(mk_CGMAIN`VT(rpowset_v, mk_REP`SetTypeRep(argTp)), nil,
                                 mk_CGMAIN`VT(elemSet_v, argTp), inner_inner_rb);
        rb = [ max ] ^ DS`GenDeclSet(rpowset_v, nil)
             ^ [DS`GenSetInsert(rpowset_v, DS`GenEmptySetExpr()) ]
             ^ DS`GenIterSet(mk_CGMAIN`VT(argexpr, argTp), nil, mk_CGMAIN`VT(elem_v, e_t), inner_rb)
             --^ [BC`GenExpressionStmt(BC`GenAsgnExpr(resVar_v, rpowset_v))]
             ^ [BC`GenAsgnStmt(resVar_v, rpowset_v)]
    in
      return rb;
 );
\end{vdm_al}

\subsubsection{Unary Operations on Sequences}

The main operation $CGUnarySeq$ which generates code unary
operations on sequences has the same main structure as for the the
main operation $CGUnarySet$. For a more detailed description of
the idea of this operation see the description of $CGUnarySet$.

\begin{vdm_al}
CGUnarySeq: AS`UnaryOp * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGUnarySeq( opr, arg, vt ) ==
  def argTmpType = CGAUX`FindType(arg);
      mk_(argTmp, arg_stmt) = CGExprExcl(arg, "unArg", nil);
  in
   (dcl rb_l : seq of CPP`Stmt := arg_stmt,
        alt2 : seq of CPP`Stmt | CPP`Expr;
    if not CGAUX`IsSeqType( argTmpType )
    then
     (dcl cond : CPP`Expr;
      if CPP`isCPP()
      then cond := DS`GenIsSeq( argTmp )
      else cond := BC`GenLogOr(DS`GenIsSeq (argTmp), DS`GenIsString(argTmp));

      rb_l := rb_l ^ [BC`GenIfStmt( BC`GenNot( cond ),
                                    BC`GenBlock([CGAUX`RunTime("A sequence was expected" )]), nil ) ];
     );
    cases opr:
      <SEQLEN>       -> alt2 := CGSeqLen( argTmp, argTmpType, vt ),
      <SEQDISTRCONC> -> alt2 := CGSeqDistrConc( argTmp, argTmpType, vt ),
      <SEQELEMS>     -> alt2 := CGSeqElems( argTmp, argTmpType, vt ),
      <SEQINDICES>   -> alt2 := CGSeqIndices( argTmp , argTmpType, vt ),
      <SEQTAIL>      -> alt2 := CGSeqTail( argTmp, argTmpType, vt ),
      <SEQHEAD>      -> alt2 := CGSeqHead( argTmp, argTmpType, vt ),
      <SEQREVERSE>   -> alt2 := CGSeqReverse( argTmp, argTmpType, vt ),
      others         -> error
    end;

    if CGAUX`IsSeqOfCPPStmt( alt2 )
    then return rb_l ^ alt2
    else
      if rb_l = []
      then return alt2
      else
        let mk_CGMAIN`VT( resVar_v, - ) = vt
        in return rb_l ^ [ BC`GenAsgnStmt( resVar_v, alt2) ];
   );
\end{vdm_al}

The main structure of code generation of the distributed concatenation
operation is very similar to the code generation of distributed union
and intersection on sets. We refer to the annotations of the main
structure of this translation for a more detailed description.

Consider the VDM example below:
\begin{verbatim}
dconc [ [1, 3], [3,4] ]
\end{verbatim}

The corresponding pseudo code is listed below:

\begin{verbatim}
Sequence tmpArg;
...CGExpr( "[ [ 1, 3], [3, 4] ]", mk_CGMAIN`VT( tmpArg, "Sequence" ) );
Sequnce rdcseq; // Temporary variable to contain the evaluation of the distributed
                // concatenation operation on the sequence.
Generic e_g;
for ( int bb = tmpArg.First( e_g ); bb; bb = tmpArg.Next (e_g) )
 { Sequence e = e_g;
   rdcseq.ImpConc( e );
 }
resVar = rdcseq;
\end{verbatim}

\begin{vdm_al}
CGSeqDistrConc: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSeqDistrConc(argexpr, argtype, mk_CGMAIN`VT(resVar_v, -)) ==
  def rdcseq_v : CPP`Name = BC`GiveName("rdcseq");
      rdcseqType : REP`TypeRep = CGAUX`FindPosResSeqTypeInSeqDistr(argtype);
      e_v : CPP`Name = BC`GiveName("e");
  in
   (dcl todo : seq1 of CPP`Stmt,
        rb : seq of CPP`Stmt := [],
        argS : CPP`Expr := argexpr;
    if CPP`isCPP()
    then todo := [DS`GenSeqConcStmt(rdcseq_v, e_v)]
    else if CGAUX`IsSeqType(rdcseqType)
         then if CGAUX`IsPossibleStringType(rdcseqType)
              then todo := [BC`GenAsgnStmt(rdcseq_v, DS`GenConcString(rdcseq_v, e_v))]
              else todo := [DS`GenSeqConcStmt(rdcseq_v, e_v)]
         else todo := [DS`GenSeqConcStmt(rdcseq_v, DS`GenCastSeq(e_v,nil))];
    if CPP`isCPP()
    then rb := rb ^ DS`GenDeclEmptySeq(rdcseq_v)
    else if CGAUX`IsPossibleStringType(rdcseqType)
         then rb := rb ^ [ BC`GenDecl(DS`GenStringType(), rdcseq_v, BC`GenAsgnInit(DS`GenEmptyStringExpr()))]
         else rb := rb ^ DS`GenDeclEmptySeq(rdcseq_v);
    if not CGAUX`IsSeqType (argtype) or not is_CPP`Identifier(argexpr)
    then
      ( argS := BC`GiveName ("argS");
        rb:= rb ^ DS`GenDeclSeq (argS, DS`GenCastSeq(argexpr, nil))
      );
    rb := rb ^ DS`GenIterSeq(mk_CGMAIN`VT(argS, mk_REP`SeqTypeRep(rdcseqType)), nil,
                             mk_CGMAIN`VT(e_v, rdcseqType), todo) ;
    rb := rb ^ [ BC`GenAsgnStmt(resVar_v, rdcseq_v)];
    return rb;
   );
\end{vdm_al}

Consider the VDM example below:
\begin{verbatim}
elems [ 1, 3, 4]
end{verbatim}

The corresponding pseudo code is listed below:

\begin{verbatim}
Sequence tmpArg;
...CGExpr( "[1, 3, 4]", mk_CGMAIN`VT( tmpArg, "Sequence" ) );
resVar = tmpArg.Elems()
\end{verbatim}

\begin{vdm_al}
CGSeqElems:  CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSeqElems(argTmp, argTmpType, -) ==
  if CPP`isCPP()
  then
   (dcl argexpr : CPP`Expr := argTmp;
    if not CGAUX`IsSeqType(argTmpType)
    then argexpr := DS`GenCastSeq(argTmp, nil);
    return DS`GenSeqElems( argexpr )
   )
  else -- Java
   (dcl argexpr : CPP`Expr := argTmp;
    if CGAUX`IsStringType(argTmpType) or CGAUX`IsPossibleStringType(argTmpType)
    then argexpr := DS`GenExplicitCast(mk_REP`SeqTypeRep(mk_REP`NumericTypeRep(<NAT>)),
                                          argTmp,
                                          mk_REP`SeqTypeRep(mk_REP`CharTypeRep()))
    elseif not CGAUX`IsSeqType(argTmpType)
    then argexpr := BC`GenCondExpr(DS`GenIsString(argTmp), DS`GetListVal(argTmp), DS`GenCastSeq(argTmp, nil));
    return DS`GenSetExpr(argexpr);
   );
\end{vdm_al}

Consider the VDM example below:

\begin{verbatim}
inds [ 1, 3, 5]
\end{verbatim}

The corresponding pseudo code is listed below:

\begin{verbatim}
Sequence tmpArg;
...CGExpr( "[1, 3, 5]", mk_CGMAIN`VT( tmpArg, "Sequence" ) );
Set riseq;
int max = tmpArg.Length();
for ( int i = 1; i <= max; i++ )
  riseq.Insert( (Int) i );
resVar_v = riseq;
\end{verbatim}


\begin{vdm_al}
CGSeqIndices: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSeqIndices( argTmp, argTmpType, mk_CGMAIN`VT( resVar_v, - ) ) ==
  if CPP`isCPP()
  then
    return DS`GenInds(DS`GenCastSeq(argTmp, argTmpType))
  else
    def riseq_v = BC`GiveName("riseq");
        i_v = BC`GiveName( "i");
        insert = BC`GenBlock([DS`GenSetInsert(riseq_v, DS`GenIntExpr(i_v))])
    in
     (dcl argexpr : CPP`Expr := argTmp,
          length : CPP`Expr,
          rb : seq of CPP`Stmt := [];
      if not CGAUX`IsSeqType(argTmpType)
      then argexpr := DS`GenCastSeq(argTmp, nil);
      if CGAUX`IsStringType(argTmpType) or CGAUX`IsPossibleStringType(argTmpType)
      then length := DS`GenLenString(argexpr)
      else length := DS`GenLen_int(argexpr);
      rb := DS`GenDeclEmptySet(riseq_v) ^
            [ BC`GenForStmt(BC`GenDecl(DS`GenSmallIntType(), i_v, BC`GenAsgnInit( BC`GenIntegerLit ( 1 ) ) ),
                            BC`GenLeq( i_v, length ),
                            [BC`GenPostPlusPlus( i_v )],
                            insert),
              BC`GenAsgnStmt( resVar_v, riseq_v ) ];
      return rb
     );

CGSeqLen: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSeqLen( argTmp, argTmpType, - ) ==
 (dcl argexpr : CPP`Expr;
  if CGAUX`IsSeqType(argTmpType)
  then argexpr := argTmp
  else argexpr := DS`GenCastSeq(argTmp, nil);

  if CPP`isCPP()
  then return DS`GenLen(argexpr)
  else
    if CGAUX`IsStringType(argTmpType)
    then return DS`GenLenString (argexpr)
    else
      if CGAUX`IsSeqType(argTmpType)
      then return DS`GenLen (argexpr)
      else return BC`GenCondExpr(DS`GenIsString(argTmp),
                                  DS`GenLenString (DS`GenCastString(argTmp)),
                                  DS`GenLen (DS`GenCastSeq (argTmp, nil)));
 );

CGSeqTail: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSeqTail( argTmp, argTmpType, - ) ==
 (dcl argexpr : CPP`Expr;
  if CGAUX`IsSeqType(argTmpType)
  then argexpr := argTmp
  else argexpr := DS`GenCastSeq(argTmp, nil);

  if CPP`isCPP()
  then return DS`GenTl (argexpr)
  else
    if CGAUX`IsStringType(argTmpType) or CGAUX`IsPossibleStringType(argTmpType)
    then return DS`GenTlString (argexpr)
    else return DS`GenTl (argexpr);
 );

CGSeqHead: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSeqHead( argTmp, argTmpType, mk_CGMAIN`VT( -, type ) ) ==
 (dcl argexpr : CPP`Expr;
  if CGAUX`IsSeqType(argTmpType)
  then argexpr := argTmp
  else argexpr := DS`GenCastSeq(argTmp, nil);

  if CPP`isCPP()
  then return DS`GenHd (type, argexpr)
  else
    if CGAUX`IsStringType(argTmpType) or CGAUX`IsPossibleStringType(argTmpType)
    then return DS`GenHdString (argexpr)
    else return DS`GenHd (type, argexpr);
 );

CGSeqReverse: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSeqReverse( argTmp, argTmpType, - ) ==
 (dcl argexpr : CPP`Expr;
  if CGAUX`IsSeqType(argTmpType)
  then argexpr := argTmp
  else argexpr := DS`GenCastSeq(argTmp, nil);

  if CPP`isCPP()
  then return DS`GenReverse (argexpr)
  else
    if CGAUX`IsStringType(argTmpType) or CGAUX`IsPossibleStringType(argTmpType)
    then return DS`GenReverseString (argexpr)
    else return DS`GenReverse (argexpr);
 );
\end{vdm_al}

\subsubsection{Unary Map operations}

The main structure of the code generation of the unary map operations
is almost similar to the main structure of the unary set and sequence
operations. Therefore the annotations of the specifications in this
section is very limited, and we refer to the other sections for a more
detailed description of the main structure of the specifications.

\NYI. If the $argTmpType$ is not a map type, we are casting to a
map with no deeper type information.

\begin{vdm_al}
CGUnaryMap: AS`UnaryOp * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGUnaryMap( opr, arg, vt ) ==
  def argTmpType = CGAUX`FindType(arg);
      mk_(argTmp, arg_stmt) = CGExprExcl(arg, "unArg", nil);
  in
   (dcl rb_l : seq of CPP`Stmt := arg_stmt,
        argexprmap : CPP`Expr := argTmp,
        alt2 : seq of CPP`Stmt | CPP`Expr;
    cases opr:
      <MAPDOM>,
      <MAPRNG>,
      <MAPINVERSE>    -> if not CGAUX`IsMapType( argTmpType )
                         then rb_l := rb_l ^
                                    [BC`GenIfStmt( BC`GenNot( DS`GenIsMap( argTmp ) ),
                                                   CGAUX`RunTime("A map was expected"),
                                                   nil ) ],
      <MAPDISTRMERGE> -> if not CGAUX`IsSetType( argTmpType )
                         then rb_l := rb_l ^
                                    [BC`GenIfStmt( BC`GenNot( DS`GenIsSet( argTmp ) ),
                                                   CGAUX`RunTime("A set was expected"),
                                                   nil ) ],
      others -> error
    end;

    if not CGAUX`IsMapType( argTmpType )
    then argexprmap := DS`GenCastMap(argTmp);

    cases opr:
      <MAPDOM>        -> alt2 := CGMapDom(argexprmap, argTmpType, vt),
      <MAPRNG>        -> alt2 := CGMapRng(argexprmap, argTmpType, vt),
      <MAPDISTRMERGE> -> alt2 := CGMapDistrMerge(argTmp, argTmpType, vt),
      <MAPINVERSE>    -> alt2 := CGMapInverse(argexprmap, argTmpType, vt),
      others -> error
    end;
    if CGAUX`IsSeqOfCPPStmt( alt2 )
    then return rb_l ^ alt2
    else
      if rb_l = []
      then return alt2
      else
        let mk_CGMAIN`VT( resVar_v, - ) = vt
        in return rb_l ^ [ BC`GenAsgnStmt( resVar_v, alt2 ) ];
   );
\end{vdm_al}

\begin{vdm_al}
CGMapDom: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr
CGMapDom( argexpr, -, -) ==
  if CPP`isJAVA()
  then return DS`GenSetExpr(DS`GenDom(argexpr))
  else return DS`GenDom (argexpr);
\end{vdm_al}

\begin{vdm_al}
CGMapRng: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr
CGMapRng( argexpr, -, -) ==
  if CPP`isJAVA()
  then return DS`GenSetExpr(DS`GenRng(argexpr))
  else return DS`GenRng (argexpr);
\end{vdm_al}

Consider the VDM example below of a distributed merge operation:

\begin{verbatim}
merge { {1 |-> 3}, { 4 |-> 4} }
\end{verbatim}

The corresponding pseudo code is listed below:

\begin{verbatim}
Set argTmp;
...CGExpr( "{ { 1|-> 3}, {4|->5} }", mk_CGMAIN`VT( argTmp, "Set" ) );
Map rdmmap; // Temporary variable to store the result of the evaluation of
            // the distributed merge operation.
// Traversal through the set argTmp;
Generic e_g;
for ( int bb = argTmp.First( e_g ); bb; bb = argTmp.Next( e_g ) )
  { Map e = e_g;
    Set eq_dom = rdmap.Dom();
    eq_dom.ImpIntersect( e.Dom () );
    bool all_dup_eq = true;
    Generic d_g;
    for ( int cc = eq_dom.First( d_g ); cc && all_dup_eq; cc = eq_dom.Next( d_g ) )
        { Int d = d_g;
          all_dup_eq = rdmmap [ d ] == e[ d ];
          if ! ( all_dup_eq )
          then
            RunTimeError( "Duplicate entries for 'merge' had different values" );
          rdmmap.ImpOverride( e );
        }
  }
resVar_v = rdmmap;
\end{verbatim}

Consider the case where the argument set of the operation is of type
set of some union type, like for instance in the example below:

\begin{verbatim}
merge { {1 |-> 3}, if b
                   then { 2 |-> 4}
                   else 3 }
\end{verbatim}

In this case we have to investigate dynamically if all elements in the
set is maps. The corresponding code is listed below:

\begin{verbatim}
Set argTmp;
...CGExpr( "{ { 1|-> 3}, {4|->5} }", mk_CGMAIN`VT( argTmp, "Set" ) );
Map rdmmap; // Temporary variable to store the result of the evaluation of
            // the distributed merge operation.
// Traversal through the set argTmp;
Generic e_g;
for ( int bb = argTmp.First( e_g ); bb; bb = argTmp.Next( e_g ) )
  { Generic tmp = e_g; // This seems to an odd assignment, however
                       // it is due to the "GenIterSet" operation
                       // provided by the DS module
    if !( tmp.IsMap )
    then
      RunTimeError( "A map was expected" );
    Map e = tmp;
    Set eq_dom = rdmap.Dom();
    eq_dom.ImpIntersect( e.Dom () );
    bool all_dup_eq = true;
    Generic d_g;
    for ( int cc = eq_dom.First( d_g ); cc && all_dup_eq; cc = eq_dom.Next( d_g ) )
        { Int d = d_g;
          all_dup_eq = rdmmap [ d ] == e[ d ];
        }
    if ! ( all_dup_eq )
    then
      RunTimeError( "Duplicate entries for 'merge' had different values" );
    rdmmap.ImpOverride( e );
  }
resVar_v = rdmmap;
\end{verbatim}

\begin{vdm_al}
CGMapDistrMerge: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> seq of CPP`Stmt | CPP`Expr
CGMapDistrMerge( argtmp, argType, mk_CGMAIN`VT( resVar_v, - ) ) ==
  def rdmmap_v = BC`GiveName("rdmmap");
      e_v = BC`GiveName( "e" );
      tmp_v = BC`GiveName( "tmp" );
      maptype = FindMapTypeInMapDistrMerge( argType );
      stp  = FindSetTypeInMapDistrMerge(argType);
      elemtype = let mk_REP`SetTypeRep(t) = stp in CGAUX`CleanFlatType(t);
      mk_(dyncheck, e) = GenDynCheckOnSetsValues(tmp_v, e_v, argType, maptype);
      todo_inner = GenMapDistrMergeInner( e, rdmmap_v, maptype )
  in
   (dcl rb : seq of CPP`Stmt := [],
        argS : CPP`Expr := argtmp;
    rb := rb ^ DS`GenDeclEmptyMap(maptype, rdmmap_v);
    if not CGAUX`IsSetType (argType) or not is_CPP`Identifier(argtmp)
    then (argS := BC`GiveName ("argS");
          rb := rb ^ DS`GenDeclSet (argS, DS`GenCastSetType(argtmp)));
    rb := rb ^ DS`GenIterSet(mk_CGMAIN`VT(argS, mk_REP`SetTypeRep(elemtype)), nil,
                             mk_CGMAIN`VT( e_v, elemtype ), dyncheck ^ todo_inner);
    rb := rb ^ [ BC`GenAsgnStmt(resVar_v, rdmmap_v) ];
    return rb);
\end{vdm_al}

The next operation $GenMapDistrMergeInner$ generates the part of
the statements in the body of the loop:

\begin{verbatim}
    Set eq_dom = rdmap.Dom();
    eq_dom.ImpIntersect( e.Dom () );
    bool all_dup_eq = true;
    Generic d_g;
    for ( int cc = eq_dom.First( d_g ); cc && all_dup_eq; cc = eq_dom.Next( d_g ) )
        { Int d = d_g;
          all_dup_eq = rdmmap [ d ] == e[ d ] }
    if ! ( all_dup_eq )
    then
        RunTimeError( "Duplicate entries for 'merge' had different values" );
    rdmmap.ImpOverride( e );

\end{verbatim}


\begin{vdm_al}
GenMapDistrMergeInner: CPP`Expr * CPP`Expr * REP`TypeRep ==> seq of CPP`Stmt
GenMapDistrMergeInner( e, rdmmap_v, maptype ) ==
  if CPP`isCPP()
  then let eq = BC`GenFctCallObjMemAcc(rdmmap_v, "IsCompatible", [e]),
           rt = CGAUX`RunTime("Duplicate entries for 'merge' had different values")
       in return [BC`GenIfStmt(BC`GenNot(eq), rt, nil), DS`GenMapOverride(rdmmap_v, e)]
  else
    def eqDom_v = BC`GiveName( "eq_dom" );
        allDupEq_v = BC`GiveName( "all_dup_eq" );
        d_v = BC`GiveName( "d" );
    in
     (dcl mdType : REP`TypeRep;
      cases maptype:
        mk_REP`GeneralMapTypeRep( md, - )   -> mdType := CGAUX`CleanFlatType(md),
        mk_REP`InjectiveMapTypeRep( md, - ) -> mdType := CGAUX`CleanFlatType(md),
        others -> error
      end;
      def eqtest = DS`GenEqVal(DS`GenMapApply(mk_CGMAIN`VT(rdmmap_v, maptype), d_v),
                             DS`GenMapApply(mk_CGMAIN`VT(e, maptype), d_v));
          inner = [ BC`GenAsgnStmt( allDupEq_v, eqtest) ]
      in
       (dcl rb : seq of CPP`Stmt := DS`GenDeclSet(eqDom_v, DS`GenDom(rdmmap_v));
        rb := rb ^ [ DS`GenInterSectStmt( eqDom_v, DS`GenDom( e ) ) ];
        rb := rb ^ [ BC`GenDecl(DS`GenSmallBoolType(), allDupEq_v, BC`GenAsgnInit( BC`GenBoolLit(true) ) ) ];
        rb := rb ^ DS`GenIterSet(mk_CGMAIN`VT( eqDom_v, mk_REP`SetTypeRep( mdType ) ), allDupEq_v,
                                 mk_CGMAIN`VT( d_v, mdType ), inner );
        rb := rb ^ [ BC`GenIfStmt( BC`GenNot( allDupEq_v ),
                                     CGAUX`RunTime( "Duplicate entries for 'merge' had different values" ),
                                     nil )];
        rb := rb ^ [ DS`GenMapOverride( rdmmap_v, e ) ];
        return rb)
     );
\end{vdm_al}

The next operation $GenDynCheckOnSetsValues$ is an auxiliary operation
to the operation $CGMapDistrMerge$. The operations computes the code
corresponding to the dynamic check if the set consists only of maps.

\begin{vdm_al}
GenDynCheckOnSetsValues: CPP`Expr * CPP`Expr * REP`TypeRep * REP`TypeRep ==> seq of CPP`Stmt * CPP`Expr
GenDynCheckOnSetsValues( tmp_v, e_v, type, maptype ) ==
  if DoSetConsistsOnlyOfMaps( type )
  then return mk_( [], e_v )
  else
   (dcl decl : seq of CPP`Stmt;
    if CPP`isCPP()
    then decl := DS`GenDecl( maptype, tmp_v, BC`GenAsgnInit( e_v ) )
    else decl := DS`GenDecl( maptype, tmp_v, BC`GenAsgnInit( DS`GenCastMap(e_v) ) );
    return mk_( [ BC`GenIfStmt( BC`GenNot( DS`GenIsMap( e_v ) ), CGAUX`RunTime("A map was expected"), nil) ] ^
                                decl, tmp_v );
   );
\end{vdm_al}

\begin{vdm_al}
DoSetConsistsOnlyOfMaps: REP`TypeRep ==> bool
DoSetConsistsOnlyOfMaps( type ) ==
cases type:
  mk_REP`SetTypeRep( tp ) -> return CGAUX`IsMapType(CGAUX`CleanFlatType(tp)),
  mk_REP`UnionTypeRep( tps ) -> let tp in set CGAUX`LOTset (tps) be st is_REP`SetTypeRep(tp)
                                in DoSetConsistsOnlyOfMaps(tp),
  others -> error
end;
\end{vdm_al}

\begin{vdm_al}
FindSetTypeInMapDistrMerge: REP`TypeRep ==> REP`TypeRep
FindSetTypeInMapDistrMerge( argtype ) ==
cases argtype:
  mk_REP`SetTypeRep(-) -> return argtype,
  mk_REP`UnionTypeRep(tps) -> let tp in set CGAUX`LOTset (tps) be st is_REP`SetTypeRep(tp) in
                              return tp,
  others -> error
end;
\end{vdm_al}

\begin{vdm_al}
FindMapTypeInMapDistrMerge: REP`TypeRep ==> REP`TypeRep
FindMapTypeInMapDistrMerge( argtype ) ==
  cases argtype:
    mk_REP`SetTypeRep(tp) -> def tp' = CGAUX`CleanFlatType(tp) in
                             cases true:
                               (CGAUX`IsMapType(tp'))     -> return tp',
                               (is_REP`UnionTypeRep(tp')) -> let mk_REP`UnionTypeRep( tps ) = tp'
                                                             in let t in set tps be st CGAUX`IsMapType( t )
                                                             in return t,
                               others -> error
                             end,
    mk_REP`UnionTypeRep( tps ) -> let tp in set CGAUX`LOTset (tps) be st is_REP`SetTypeRep( tp )
                                  in FindMapTypeInMapDistrMerge( tp ),
    others -> error
  end;
\end{vdm_al}

\subsection{Map Inverse Expression}


Consider the VDM expression below:

\begin{verbatim}
inverse { 'a' |-> 3, 'b' |-> 4}
\end{verbatim}

The corresponding pseudo code.
\begin{verbatim}
Map mapTmp;
...CGExpr( "{ 'a' |-> 3, 'b' |-> 4}", mk_CGMAIN`VT( mapTmp, "Map"));
Generic id_d, id_r;
for ( int bb = mapTmp.First(id_d, id_r); bb; bb = mampTmp.Next(id_d, id_r)) {
if ( resVar_v.DomExists(id_r))
  CGAUX`RunTime("Map is not injective - 'inverse' fails")
else
  resVar_v.Insert(id_r, id_d);
}
\end{verbatim}


\begin{vdm_al}
CGMapInverse: CPP`Expr * REP`TypeRep * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGMapInverse( argexpr, argType, mk_CGMAIN`VT(resVar_v,-)) ==
  def id_r = BC`GiveName("id_r");
      id_d = BC`GiveName("id_d");
      maptmp_cg_vt = mk_CGMAIN`VT(argexpr, argType);
      cond_expr = DS`GenDomExists(resVar_v, id_r);
      alt1 = CGAUX`RunTime("Map is not injective - 'inverse' fails");
      alt2 = DS`GenMapInsert(resVar_v, id_r, id_d);
      body = BC`GenIfStmt(cond_expr, BC`GenBlock([alt1]), BC`GenBlock([alt2]));
      itermap = DS`GenIterMap(maptmp_cg_vt, nil, id_d, id_r, body)
  in
   (dcl initvarres : seq of CPP`Stmt := [];
    if CPP`isJAVA()
    then initvarres := [BC`GenAsgnStmt(resVar_v, DS`GenEmptyMapExpr())];
    return initvarres ^ itermap;
   );
\end{vdm_al}

\subsection{Name}

The code to be generated corresponding to evaluation of a name is
described in the operation $CGName$.

\begin{vdm_al}

CGName: AS`Name ==> seq of CPP`Stmt | CPP`Expr
CGName(asname) ==
  (def ti = CGAUX`FindType(asname)
   in
     if is_REP`PartialFnTypeRep(ti) or is_REP`TotalFnTypeRep(ti)
     then
       (CGAUX`SetNotSupportedException(true);
        return [CGAUX`NotSupported("function value")]);
   (dcl asname' : AS`Name := asname;
#ifdef VDMPP
    if (len asname.ids > 1)
    then
      (dcl argname : AS`Name := mu(asname, ids |-> [hd asname.ids]);
       def mk_(ok, cl) = CGAUX`ExpandClassName(argname, CGAUX`GiveCurCASName(), {})
       in
         if ok
         then
          (argname := cl;
           asname' := CGAUX`Combine2Names(argname, asname));
       CGAUX`IncludeClass(mu(asname, ids |-> [hd asname.ids])));
#endif VDMPP
    CGAUX`InsertVariable(asname');
#ifdef VDMSL
    return BC`Rename(asname');
#endif VDMSL
#ifdef VDMPP
    def e = BC`Rename(asname')
    in
      if CPP`isJAVA()
      then
        cases e:
          mk_CPP`QualifiedName(mk_CPP`Identifier(cnm, -), mk_CPP`Identifier(mnm, -), -)
            -> CGAUX`CheckJavaPrimitiveType(e, cnm, mnm),
          others -> return e
        end
      else return e;
#endif VDMPP
   ));

\end{vdm_al}


\subsection{Old Name}

An old name is code generated by prefixing the corresponding C++ name
with a `\_'.  In this way, the old name \verb+a~+ will be represented
by the C++ identifier {\tt \_vdm\_A\_a}, if is is assumed that the
identifier is declared in module A.

\begin{vdm_al}
CGOldName: AS`OldName  ==> seq of CPP`Stmt | CPP`Expr
CGOldName(oldnm) ==
  def ti = CGAUX`FindType(oldnm)
  in
    if is_REP`PartialFnTypeRep(ti) or is_REP`TotalFnTypeRep(ti)
    then
      (CGAUX`SetNotSupportedException(true);
       return [CGAUX`NotSupported("function value")])
    else
      return BC`RenameOld(oldnm);
\end{vdm_al}

\subsection{Literal}

The operation $CGLiteral$ describes the code to be generated
corresponding to the evaluation of a literal.

\begin{vdm_al}

CGLiteral: AS`Literal * CGMAIN`VT ==> CPP`Expr
CGLiteral(lit, resVar) ==
  return DS`GenValue(lit, resVar);

\end{vdm_al}

\subsection{Undefined  Expression}

The code corresponding to an undefined expression simply causes a
run-time error:

\begin{verbatim}
RunTimeError("Can not evaluate 'undefined' expression")
\end{verbatim}

The operation $CGUndefinedExpr$ generates the code corresponding to an
undefined expression.

\begin{vdm_al}
CGUndefinedExpr: () ==> seq of CPP`Stmt
CGUndefinedExpr() ==
  return [CGAUX`RunTime("Can not evaluate 'undefined' expression")];
\end{vdm_al}

\subsection{Binary Expression}

Consider the binary expression below:

\begin{verbatim}
let a = (dom { 1 |-> 3 } ) union { 3 }
in a
\end{verbatim}

The corresponding pseudo code of the union expression is listed below.
It is assumed that the result of the evaluation of the expression is
to be stored in the temporary variable $resVar$. The declaration of
the temporary variable is furthermore assumed to be defined as a set
of nat.

\begin{verbatim}
Set var1;   // Declaration of temporary variable which is to contain
            // the result of evaluating the right hand expression in
            // the binary expression.
...CGExpr( "dom { 1 |-> 3}", var1 );
Set var2    // Declaration of temporary variable which is to contain the result
            // of the left hand expression in the binary expression.
...CGExpr( "{ 3 }", var2 );
resVar.ImpUnion( var1 );
resVar.ImpUnion( var2 );
\end{verbatim}

Consider the VDM expression below where
\begin{verbatim}
let a = cases e:
            pat1 -> dom { 1|-> 2} union {3}
            pat2 -> false
        end
in a
\end{verbatim}

In this case corresponding temporary variable in which the result of
the evaluation of the cases expression is of the type: ( set of nat |
bool ). In that case the corresponding pseudo code of the binary
expression is listed below:

\begin{verbatim}
{ Set var1;   // Declaration of temporary variable which is to contain
              // the result of evaluating the right hand expression in
              // the binary expression.
  ...CGExpr( "dom { 1 |-> 3}", var1 );
  Set var2    // Declaration of temporary variable which is to contain the result
              // of the left hand expression in the binary expression.
  ...CGExpr( "{ 3 }", var2 );
  Set tmpresVar;
  tmpresVar.ImpUnion( var1 );
  tmpresVar.ImpUnion( var2 );
  resVar := tmpresVar;
}
\end{verbatim}


The operation of $CGBinaryExpr$ takes two input paramters:

\begin{vdm_al}
CGBinaryExpr: AS`BinaryExpr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGBinaryExpr( mk_AS`BinaryExpr(le, opr, re, -), vt ) ==
  if CPP`isJAVA() and opr = <INSET> and is_AS`PrefixExpr(re) and re.opr in set {<MAPDOM>, <MAPRNG>}
  then return OptimizeMapExpr(le, re, vt)
  else
    cases opr:
      <AND>,
      <OR>,
      <IMPLY>,
      <EQUIV>,
      <EQ>,
      <NE>            -> return CGLogBinaryExpr(le, opr, re, vt),
      <NUMMINUS>,
      <NUMPLUS>,
      <NUMMULT>,
      <NUMDIV>,
      <NUMREM>,
      <INTDIV>,
      <NUMLT>,
      <NUMLE>,
      <NUMGT>,
      <NUMGE>,
      <NUMMOD>        -> return CGNumBinaryExpr(le, opr, re, vt),
      <INSET>,
      <NOTINSET>,
      <SETUNION>,
      <SETINTERSECT>,
      <SETMINUS>,
      <PROPERSUBSET>,
      <SUBSET>        -> return CGSetBinaryExpr(le, opr, re, vt),
      <SEQCONC>       -> return CGSeqConc(le, re, vt),
      <MAPMERGE>,
      <MAPDOMRESTTO>,
      <MAPDOMRESTBY>,
      <MAPRNGRESTTO>,
      <MAPRNGRESTBY>  -> return CGMapBinaryExpr(le, opr, re, vt),
      <COMPOSE>       -> return CGComposeExpr(le, re, vt),
      <NUMEXP>        -> return CGIterateExpr(le, re, vt),
      others          -> error
    end;
\end{vdm_al}

The evaluation of some of the logical expressions are conditional.
Thus, the evaluation of the left hand of the expression has to be done
before the evaluation of the left hand side. Consider the VDM example below:

\begin{verbatim}
let a = 0,
    b = 15
in  (a = 3) and ( b/a) = 5
\end{verbatim}

The corresponding pseudo code of the evaluation of the binary
expression is listed below:

\begin{verbatim}
Bool var1;
{ var1 = ( vdm_var_a == 3 ); }
if var1.GetValue()
   {
     {
       Bool var2;
       { var2 = ( vdm_var_b / vdm_var_a ) == 5; }
     }
     resVar = var2;
   }
else
   resVar = var1;
\end{verbatim}


\begin{vdm_al}
CGLogBinaryExpr: AS`Expr * AS`BinaryOp * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGLogBinaryExpr( le, opr, re, mk_CGMAIN`VT( resVar_v, -) ) ==
  cases opr:
    <EQUIV>,
    <EQ>,
    <NE>    -> def type1  = CGAUX`FindType( le );
                   type2  = CGAUX`FindType( re );
                   mk_(var1, stmt1) = CGExprExcl(le, "var1", type1);
                   mk_(var2, stmt2) = CGExprExcl(re, "var2", type2)
               in
                (dcl expr : CPP`Expr;
                 if <NE> = opr
                 then expr := DS`GenNeq(mk_CGMAIN`VT(var1, type1), mk_CGMAIN`VT(var2, type2))
                 else expr := DS`GenEq(mk_CGMAIN`VT(var1, type1), mk_CGMAIN`VT(var2, type2));
                 if stmt1 = [] and stmt2 = []
                 then return expr
                 else return stmt1 ^ stmt2 ^ [BC`GenAsgnStmt(resVar_v, expr)]
                ),
    others  -> def type1  = CGAUX`FindType( le );
                   type2  = CGAUX`FindType( re );
                   mk_(var1, stmt1) = CGExprExcl(le, "var1", type1);
                   mk_(var2, stmt2) = CGExprExcl(re, "var2", type2);
                   errmess = BC`GenBlock([CGAUX`RunTime("A boolean was expected" )]);
               in
                (dcl expr1 : CPP`Expr := var1,
                     expr2 : CPP`Expr := var2,
                     rb1new : seq of CPP`Stmt := stmt1,
                     rb2new : seq of CPP`Stmt := stmt2;

                 if not CGAUX`IsBoolType( type1 )
                 then
                  (if not is_CPP`Identifier(var1)
                   then
                     def v1 = BC`GiveName("ver1")
                     in
                      (rb1new := rb1new ^ DS`GenDecl(type1, v1, BC`GenAsgnInit(var1));
                       expr1 := v1;);
                   rb1new := rb1new ^ [ BC`GenIfStmt( BC`GenNot( DS`GenIsBool( expr1 ) ),
                                                      errmess, nil ) ];
                   expr1 := DS`GenCastType( mk_REP`BooleanTypeRep(), expr1 );
                  );

                 if not CGAUX`IsBoolType( type2 )
                 then
                  (if not is_CPP`Identifier(var2)
                   then
                     def v2 = BC`GiveName("ver2")
                     in
                      (rb2new := rb2new ^ DS`GenDecl(type2, v2, BC`GenAsgnInit(var2));
                       expr2 := v2;);
                   rb2new := rb2new ^ [ BC`GenIfStmt( BC`GenNot( DS`GenIsBool( expr2 ) ),
                                                      errmess, nil ) ];
                   expr2 := DS`GenCastType( mk_REP`BooleanTypeRep(), expr2 );
                  );

                 if rb2new <> []
                 then
                  (def cond = DS`GenGetValue(expr1, mk_REP`BooleanTypeRep());
                       asgnstmt = BC`GenAsgnStmt(resVar_v, expr2);
                       alt1 = BC`GenBlock(rb2new ^ [asgnstmt]);
                   in
                     cases opr :
                       <AND>   -> return rb1new ^ [BC`GenIfStmt(cond, alt1,
                              BC`GenBlock([BC`GenAsgnStmt(resVar_v, DS`GenBoolLit(false))]))],
                       <OR>    -> return rb1new ^ [BC`GenIfStmt(BC`GenNot(cond), alt1,
                              BC`GenBlock([BC`GenAsgnStmt(resVar_v, DS`GenBoolLit(true))]))],
                       <IMPLY> -> return rb1new ^ [BC`GenIfStmt(cond, alt1,
                              BC`GenBlock([BC`GenAsgnStmt(resVar_v, DS`GenBoolLit(true))]))],
                       others  -> return rb1new ^ stmt2
                     end;
                  )
                 else
                  (def cond = DS`GenGetValue(expr1, mk_REP`BooleanTypeRep());
                       alt1 = DS`GenGetValue(expr2, mk_REP`BooleanTypeRep());
                   in
                     cases opr :
                       <AND>   -> def e = DS`GenBoolExpr(BC`GenCondExpr(cond, alt1, BC`GenBoolLit(false)))
                                  in
                                    if rb1new = []
                                    then return e
                                    else return rb1new ^ [BC`GenAsgnStmt(resVar_v, e)],
                       <OR>    -> def e = DS`GenBoolExpr(BC`GenCondExpr(cond, BC`GenBoolLit(true), alt1))
                                  in
                                    if rb1new = []
                                    then return e
                                    else return rb1new ^ [BC`GenAsgnStmt(resVar_v, e)],
                       <IMPLY> -> def e = DS`GenBoolExpr(BC`GenCondExpr(cond, alt1, BC`GenBoolLit(true)))
                                  in
                                    if rb1new = []
                                    then return e
                                    else return rb1new ^ [BC`GenAsgnStmt(resVar_v, e)],
                       others  -> return rb1new
                     end;
                  )
                )
  end;

CGNumBinaryExpr: AS`Expr * AS`BinaryOp * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGNumBinaryExpr(le, opr, re, vtres ) ==
  def type1  = CGAUX`FindType( le );
      type2  = CGAUX`FindType( re );
      mk_(var1_v, stmt1) = CGExprExcl(le, "var1", type1);
      mk_(var2_v, stmt2) = CGExprExcl(re, "var2", type2)
  in
    let var2_v' = if is_AS`BracketedExpr(re) and stmt2 = []
                  then BC`GenBracketedExpr(var2_v)
                  else var2_v,
        vt1 = mk_CGMAIN`VT(var1_v, type1),
        vt2 = mk_CGMAIN`VT(var2_v', type2)
    in
     (dcl rb_l : seq of CPP`Stmt := stmt1 ^ stmt2,
          expr : CPP`Expr;

      if not (CGAUX`IsNumType(type1) and CGAUX`IsNumType(type2))
      then
       (dcl cond : CPP`Expr;
        cases opr:
          <NUMPLUS>,
          <NUMMINUS>,
          <NUMMULT>,
          <NUMDIV>,
          <NUMLT>,
          <NUMLE>,
          <NUMGT>,
          <NUMGE> ->(dcl v1_v : CPP`Expr := var1_v,
                         v2_v : CPP`Expr := var2_v;
                     if not is_CPP`Identifier(var1_v)
                     then
                       def e1_v = BC`GiveName("e1")
                       in
                        (v1_v := e1_v;
                         rb_l := rb_l ^ DS`GenConstDeclInit(type1, e1_v, var1_v) );
                     if not is_CPP`Identifier(var2_v)
                     then
                       def e2_v = BC`GiveName("e2")
                       in
                        (v2_v := e2_v;
                         rb_l := rb_l ^ DS`GenConstDeclInit(type2, e2_v, var2_v) );
                     if not CGAUX`IsNumType(type1) and not CGAUX`IsNumType(type2)
                     then cond := BC`GenLogOr(BC`GenNot(DS`GenIsReal(v1_v)), BC`GenNot(DS`GenIsReal(v2_v)))
                     elseif not CGAUX`IsNumType(type1)
                     then cond := BC`GenNot(DS`GenIsReal(v1_v))
                     else cond := BC`GenNot(DS`GenIsReal(v2_v));
                     rb_l := rb_l ^ [BC`GenIfStmt(cond,
                                   BC`GenBlock([CGAUX`RunTime("A number was expected")]), nil)];
                    ),
          <NUMREM>,
          <NUMMOD>,
          <INTDIV> ->(dcl v1_v : CPP`Expr := var1_v,
                          v2_v : CPP`Expr := var2_v;
                      if not is_CPP`Identifier(var1_v)
                      then
                        def e1_v = BC`GiveName("e1")
                        in
                         (v1_v := e1_v;
                          rb_l := rb_l ^ DS`GenConstDeclInit(type1, e1_v, var1_v) );
                      if not is_CPP`Identifier(var2_v)
                      then
                        def e2_v = BC`GiveName("e2")
                        in
                         (v2_v := e2_v;
                          rb_l := rb_l ^ DS`GenConstDeclInit(type2, e2_v, var2_v) );
                      if not CGAUX`IsNumType(type1) and not CGAUX`IsNumType(type2)
                      then cond := BC`GenLogOr(BC`GenNot(DS`GenIsInt(v1_v)), BC`GenNot(DS`GenIsInt(v2_v)))
                      elseif not CGAUX`IsNumType(type1)
                      then cond := BC`GenNot(DS`GenIsInt(v1_v))
                      else cond := BC`GenNot(DS`GenIsInt(v2_v));
                      rb_l := rb_l ^ [BC`GenIfStmt(cond, CGAUX`RunTime("A integer was expected"), nil)];
                      ),
          others     -> error
        end;
       );
      cases opr:
        <NUMPLUS>  -> expr := DS`GenPlus(vt1, vt2, vtres),
        <NUMMINUS> -> expr := DS`GenMinus(vt1, vt2, vtres) ,
        <NUMMULT>  -> expr := DS`GenMult(vt1, vt2, vtres) ,
        <NUMDIV>   -> expr := DS`GenNumDiv(vt1, vt2, vtres),
        <NUMREM>   -> expr := DS`GenNumRem(vt1, vt2),
        <NUMMOD>   -> expr := DS`GenNumMod(vt1, vt2, vtres),
        <INTDIV>   -> expr := DS`GenIntDiv(vt1, vt2, vtres),
        <NUMLT>    -> expr := DS`GenNumLT(vt1, vt2),
        <NUMLE>    -> expr := DS`GenNumLE(vt1, vt2),
        <NUMGT>    -> expr := DS`GenNumGT(vt1, vt2),
        <NUMGE>    -> expr := DS`GenNumGE(vt1, vt2),
        others     -> error
      end;
      if rb_l = []
      then return expr
      else
        let mk_CGMAIN`VT(resVar_v, -) = vtres
        in return rb_l ^ [ BC`GenAsgnStmt(resVar_v, expr) ];
     );

CGSetBinaryExpr: AS`Expr * AS`BinaryOp * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSetBinaryExpr( le, opr, re, vt ) ==
  cases opr:
    <INSET>        -> return CGInSet( le, re, vt ),
    <NOTINSET>     -> return CGNotInSet( le, re, vt ),
    <SETUNION>     -> return CGSetUnion( le, re, vt ),
    <SETINTERSECT> -> return CGSetInterSect( le, re, vt ),
    <SETMINUS>     -> return CGSetMinus( le, re, vt ),
    <SUBSET>       -> return CGSubset( le, re, vt ),
    <PROPERSUBSET> -> return CGProperSubset( le, re, vt ),
    others         -> error
  end;

CGInSet: AS`Expr * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGInSet( le, re,  mk_CGMAIN`VT(resVar_v, -) ) ==
  def type1  = CGAUX`FindType( le );
      type2  = CGAUX`FindType( re );
      mk_(var1_v, stmt1) = CGExprExcl(le, "var1", type1);
      mk_(var2_v, stmt2) = CGExprExcl(re, "var2", type2);
  in
   (dcl var2_v' : CPP`Expr := var2_v,
        rb_l : seq of CPP`Stmt := stmt1 ^ stmt2;
    if not CGAUX`IsSetType(type2)
    then var2_v' := DS`GenCastSetType(var2_v);
    if not CGAUX`IsSetType(type2)
    then rb_l := rb_l ^ [ BC`GenIfStmt(BC`GenNot(DS`GenIsSet(var2_v)),
                                       BC`GenBlock([CGAUX`RunTime("A set was expected")]), nil ) ];
    def expr = DS`GenInSet(mk_CGMAIN`VT(var1_v, type1), mk_CGMAIN`VT(var2_v', type2))
    in
      if rb_l = []
      then return expr
      else return rb_l ^ [ BC`GenAsgnStmt(resVar_v, expr) ];
   );

CGNotInSet: AS`Expr * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGNotInSet( le, re,  mk_CGMAIN`VT(resVar_v, -) ) ==
  def type1  = CGAUX`FindType( le );
      type2  = CGAUX`FindType( re );
      mk_(var1_v, stmt1) = CGExprExcl(le, "var1", type1);
      mk_(var2_v, stmt2) = CGExprExcl(re, "var2", type2);
  in
   (dcl var2_v' : CPP`Expr := var2_v,
        rb_l : seq of CPP`Stmt := stmt1 ^ stmt2;
    if not CGAUX`IsSetType(type2)
    then var2_v' := DS`GenCastSetType(var2_v);
    if not CGAUX`IsSetType(type2)
    then rb_l := rb_l ^ [ BC`GenIfStmt(BC`GenNot(DS`GenIsSet(var2_v)),
                                       BC`GenBlock([CGAUX`RunTime("A set was expected")]), nil ) ];
    def expr = DS`GenNotInSet(mk_CGMAIN`VT(var1_v, type1), mk_CGMAIN`VT(var2_v', type2))
    in
      if rb_l = []
      then return expr
      else return rb_l ^ [ BC`GenAsgnStmt(resVar_v, expr) ];
   );

CGProperSubset: AS`Expr * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGProperSubset( le, re,  mk_CGMAIN`VT( resVar_v, -) ) ==
  def type1  = CGAUX`FindType( le );
      type2  = CGAUX`FindType( re );
      mk_(var1_v, stmt1) = CGExprExcl(le, "var1", type1);
      mk_(var2_v, stmt2) = CGExprExcl(re, "var2", type2);
  in
   (dcl var1' : CPP`Expr := var1_v,
        var2' : CPP`Expr := var2_v;
    if not CGAUX`IsSetType(type1)
    then var1' := DS`GenCastSetType(var1_v);
    if not CGAUX`IsSetType(type2)
    then var2' := DS`GenCastSetType(var2_v);
    def subs = DS`GenSubSet(var1', var2');
        cond1 = BC`GenNot( DS`GenIsSet( var1_v ) );
        cond2 = BC`GenNot( DS`GenIsSet( var2_v ) );
        errmess = BC`GenBlock([CGAUX`RunTime("A set was expected" )])
    in
     (dcl rb_l : seq of CPP`Stmt := stmt1 ^ stmt2;
      cases true:
        (CGAUX`IsSetType(type1) and not CGAUX`IsSetType(type2)) ->
             rb_l := rb_l ^ [BC`GenIfStmt( cond2, errmess, nil )], 
        (not CGAUX`IsSetType(type1) and CGAUX`IsSetType(type2)) ->
             rb_l := rb_l ^ [BC`GenIfStmt( cond1, errmess, nil )], 
        (not (CGAUX`IsSetType(type1) or CGAUX`IsSetType(type2))) ->
             rb_l := rb_l ^ [BC`GenIfStmt( BC`GenLogOr( cond1, cond2), errmess, nil )]
      end;
      if CPP`isCPP()
      then
        def neq = DS`GenNeqVal(DS`GenCard_int(var1'), DS`GenCard_int(var2'));
            expr = BC`GenCastExpr(DS`GenBoolType(), BC`GenLogAnd(subs, BC`GenBracketedExpr(neq)));
        in
          if rb_l = []
          then return expr
          else return rb_l ^ [ BC`GenAsgnStmt(resVar_v, expr) ]
      else
        def neq = DS`GenNeqVal(DS`GenCard(var1'), DS`GenCard(var2'));
            expr = DS`GenBoolExpr(BC`GenLogAnd(subs, neq));
        in
          if rb_l = []
          then return expr
          else return rb_l ^ [ BC`GenAsgnStmt(resVar_v, expr) ]; 
     );
 );

CGSubset: AS`Expr * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSubset( le, re, mk_CGMAIN`VT( resVar_v, -) ) ==
  def type1  = CGAUX`FindType( le );
      type2  = CGAUX`FindType( re );
      mk_(var1_v, stmt1) = CGExprExcl(le, "var1", type1);
      mk_(var2_v, stmt2) = CGExprExcl(re, "var2", type2);
  in
   (dcl var1' : CPP`Expr := var1_v,
        var2' : CPP`Expr := var2_v;
    if not CGAUX`IsSetType(type1)
    then var1' := DS`GenCastSetType(var1_v);
    if not CGAUX`IsSetType(type2)
    then var2' := DS`GenCastSetType(var2_v);
    def cond1 = BC`GenNot( DS`GenIsSet( var1_v ) );
        cond2 = BC`GenNot( DS`GenIsSet( var2_v ) );
        errmess = BC`GenBlock([CGAUX`RunTime("A set was expected" )])
    in
     (dcl rb_l : seq of CPP`Stmt := stmt1 ^ stmt2;
      cases true:
        (CGAUX`IsSetType(type1) and not CGAUX`IsSetType(type2)) ->
             rb_l := rb_l ^ [BC`GenIfStmt( cond2, errmess, nil )], 
        (not CGAUX`IsSetType(type1) and CGAUX`IsSetType(type2)) ->
             rb_l := rb_l ^ [BC`GenIfStmt( cond1, errmess, nil )], 
        (not (CGAUX`IsSetType(type1) or CGAUX`IsSetType(type2))) ->
             rb_l := rb_l ^ [BC`GenIfStmt( BC`GenLogOr( cond1, cond2), errmess, nil )]
      end;
      def expr = DS`GenSubSet_Bool(var1', var2')
      in
        if rb_l = []
        then return expr
        else return rb_l ^ [ BC`GenAsgnStmt(resVar_v, expr) ];
     );
 );

CGSetMinus: AS`Expr * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSetMinus(le, re, mk_CGMAIN`VT(resVar_v,rType)) ==
  def type1  = CGAUX`FindType( le );
      type2  = CGAUX`FindType( re );
      mk_(var1_v, stmt1) = CGExprExcl(le, "var1", type1);
      mk_(var2_v, stmt2) = CGExprExcl(re, "var2", type2);
  in
   (dcl var1' : CPP`Expr := var1_v,
        var2' : CPP`Expr := var2_v,
        rb_l : seq of CPP`Stmt := stmt1 ^ stmt2;
    if not CGAUX`IsSetType(type1)
    then var1' := DS`GenCastSetType(var1_v);
    if not CGAUX`IsSetType(type2)
    then var2' := DS`GenCastSetType(var2_v);
    if CPP`isCPP()
    then
      if CGAUX`IsSetType(rType) and rb_l = []
      then return BC`GenFctCallObjMemAcc(var1', "Diff", [var2'])
      else
       (dcl resVar_v' : CPP`Expr := resVar_v;
        if not CGAUX`IsSetType(rType)
        then resVar_v' := DS`GenCastSetTypeForModify(resVar_v);
        return rb_l ^ [ BC`GenAsgnStmt( resVar_v, var1'), DS`GenSetMinusStmt(resVar_v', var2') ]
       )
    else
     (dcl resVar_v' : CPP`Expr := resVar_v;
      if not CGAUX`IsSetType(rType)
      then resVar_v' := DS`GenCastSetType(resVar_v);
      return rb_l ^ [BC`GenAsgnStmt(resVar_v, DS`GenSetExpr(var1')),
            DS`GenSetMinusStmt(resVar_v', var2')];
     );
 );

CGSetInterSect: AS`Expr * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSetInterSect(le, re, mk_CGMAIN`VT(resVar_v, rType)) ==
  def type1  = CGAUX`FindType( le );
      type2  = CGAUX`FindType( re );
      mk_(var1_v, stmt1) = CGExprExcl(le, "var1", type1);
      mk_(var2_v, stmt2) = CGExprExcl(re, "var2", type2);
  in
   (dcl var1' : CPP`Expr := var1_v,
        var2' : CPP`Expr := var2_v,
        rb_l : seq of CPP`Stmt := stmt1 ^ stmt2;
    if not CGAUX`IsSetType(type1)
    then var1' := DS`GenCastSetType(var1_v);
    if not CGAUX`IsSetType(type2)
    then var2' := DS`GenCastSetType(var2_v);
    if CPP`isCPP()
    then
      if CGAUX`IsSetType(rType) and rb_l = []
      then return BC`GenFctCallObjMemAcc(var1', "Intersect", [var2'])
      else
       (dcl resVar_v' : CPP`Expr := resVar_v;
        if not CGAUX`IsSetType(rType)
        then resVar_v' := DS`GenCastSetTypeForModify(resVar_v);
        return rb_l ^ [ BC`GenAsgnStmt( resVar_v, var1'), DS`GenInterSectStmt(resVar_v', var2') ]
       )
    else
     (dcl resVar_v' : CPP`Expr := resVar_v;
      if not CGAUX`IsSetType(rType)
      then resVar_v' := DS`GenCastSetType(resVar_v);
      return rb_l ^ [BC`GenAsgnStmt(resVar_v, DS`GenSetExpr(var1')),
                     DS`GenInterSectStmt(resVar_v', var2')];
     );
   );

CGSetUnion: AS`Expr * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGSetUnion(le, re, mk_CGMAIN`VT(resVar_v,rType)) ==
  def type1  = CGAUX`FindType( le );
      type2  = CGAUX`FindType( re );
      mk_(var1_v, stmt1) = CGExprExcl(le, "var1", type1);
      mk_(var2_v, stmt2) = CGExprExcl(re, "var2", type2);
  in
   (dcl var1' : CPP`Expr := var1_v,
        var2' : CPP`Expr := var2_v,
        rb_l : seq of CPP`Stmt := stmt1 ^ stmt2;
    if not CGAUX`IsSetType(type1)
    then var1' := DS`GenCastSetType(var1_v);
    if not CGAUX`IsSetType(type2)
    then var2' := DS`GenCastSetType(var2_v);
    if CPP`isCPP()
    then
      if CGAUX`IsSetType(rType) and rb_l = []
      then return BC`GenFctCallObjMemAcc(var1', "Union", [var2'])
      else
       (dcl resVar_v' : CPP`Expr := resVar_v;
        if not CGAUX`IsSetType(rType)
        then resVar_v' := DS`GenCastSetTypeForModify(resVar_v);
        return rb_l ^ [ BC`GenAsgnStmt( resVar_v, var1'), DS`GenSetUnion(resVar_v', var2') ]
       )
    else
     (dcl resVar_v' : CPP`Expr := resVar_v;
      if not CGAUX`IsSetType(rType)
      then resVar_v' := DS`GenCastSetType(resVar_v);
      return rb_l ^ [BC`GenAsgnStmt(resVar_v, DS`GenSetExpr(var1')),
                     DS`GenSetUnion(resVar_v', var2')];
     );
   );

  CGSeqConc: AS`Expr * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
  CGSeqConc(le, re, mk_CGMAIN`VT(resVar_v, rType)) ==
    def type1  = CGAUX`FindType( le );
        type2  = CGAUX`FindType( re );
        mk_(var1, stmt1) = CGExprExcl(le, "var1", type1);
        mk_(var2, stmt2) = CGExprExcl(re, "var2", type2)
    in
      if CPP`isCPP()
      then
       (dcl var1_q : CPP`Expr := var1;
        if not CGAUX`IsSeqType(type1)
        then var1_q := DS`GenCastSeq(var1, nil);
        def expr = BC`GenFctCallObjMemAcc(var1_q, "Conc", [var2] )
        in
          if stmt1 = [] and stmt2 = []
          then return expr
          else return stmt1 ^ stmt2 ^ [BC`GenAsgnStmt( resVar_v, expr )];
       )
      else
        if rType <> nil and CGAUX`IsStringType(rType)
        then
          def l_charrep = mk_REP`SeqTypeRep(mk_REP`CharTypeRep());
          in
           (dcl var1' : CPP`Expr := var1,
                var2' : CPP`Expr := var2;
            if not CGAUX`IsStringType(CGAUX`RemoveNil(type1))
            then var1' := DS`GenExplicitCast(l_charrep, var1, nil);
            if not CGAUX`IsStringType(CGAUX`RemoveNil(type2))
            then var2' := DS`GenExplicitCast(l_charrep, var2, nil);
            def cast = DS`GenExplicitCast(rType, DS`GenConcString(var1', var2' ), l_charrep)
            in
              if stmt1 = [] and stmt2 = []
              then return cast
              else return stmt1 ^ stmt2 ^ [BC`GenAsgnStmt( resVar_v, cast )];
           )
        else
          def l_natrep = mk_REP`SeqTypeRep(mk_REP`NumericTypeRep(<NAT>));
              l_charrep = mk_REP`SeqTypeRep(mk_REP`CharTypeRep());
          in
           (dcl var1' : CPP`Expr,
                var2' : CPP`Expr,
                resVar_v' : CPP`Expr := resVar_v;
            if not CGAUX`IsPossibleStringType(CGAUX`RemoveNil(type1))
            then var1' := DS`GenCastSeq(var1,type1)
            else var1' := DS`GenExplicitCast(l_natrep, var1, l_charrep);
            if not CGAUX`IsPossibleStringType(CGAUX`RemoveNil(type2))
            then var2' := DS`GenCastSeq(var2,type2)
            else var2' := DS`GenExplicitCast(l_natrep, var2, l_charrep);
            if not CGAUX`IsSeqType(rType)
            then resVar_v' := DS`GenCastSeq(resVar_v,nil);
            def l_clone = DS`GenSeqExpr(var1')
            in return stmt1 ^ stmt2 ^
             [ BC`GenAsgnStmt(resVar_v, l_clone), BC`GenExpressionStmt(DS`GenConc(resVar_v', var2'))];
           );

  CGMapBinaryExpr: AS`Expr * AS`BinaryOp * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
  CGMapBinaryExpr(le, opr, re, resVT) ==
    def type1  = CGAUX`FindType( le );
        type2  = CGAUX`FindType( re );
        mk_(var1_v, stmt1) = CGExprExcl(le, "var1", type1);
        mk_(var2_v, stmt2) = CGExprExcl(re, "var2", type2);
        vt1 = mk_CGMAIN`VT(var1_v, type1);
        vt2 = mk_CGMAIN`VT(var2_v, type2);
    in
     (dcl rb_l : seq of CPP`Stmt  := stmt1 ^ stmt2;
      cases opr:
        <MAPMERGE>     -> rb_l := rb_l ^ DS`GenMapMerge(vt1, vt2, resVT),
        <MAPDOMRESTTO>,
        <MAPDOMRESTBY> -> def res_v = DS`GenMapRestToBy(vt1, vt2, resVT, opr)
                          in
                            if CGAUX`IsSeqOfCPPStmt(res_v)
                            then return rb_l ^ res_v
                            else
                              if rb_l = []
                              then return res_v
                              else
                                let mk_CGMAIN`VT(resVar_v, -) = resVT
                                in return rb_l ^ [BC`GenAsgnStmt(resVar_v, res_v)],
        <MAPRNGRESTTO>,
        <MAPRNGRESTBY> -> def res_v = DS`GenMapRestToBy(vt2, vt1, resVT, opr)
                          in
                            if CGAUX`IsSeqOfCPPStmt(res_v)
                            then return rb_l ^ res_v
                            else
                              if rb_l = []
                              then return res_v
                              else
                                let mk_CGMAIN`VT(resVar_v, -) = resVT
                                in return rb_l ^ [BC`GenAsgnStmt(resVar_v, res_v)],
        others -> error
      end;
      return rb_l;
     );

  OptimizeMapExpr : AS`Expr * AS`PrefixExpr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
  OptimizeMapExpr(le, re, mk_CGMAIN`VT(resVar_v, -)) ==
    def mk_(var1_v, stmt1) = CGExprExcl(le, "var1", nil);
        mk_(var2_v, stmt2) = CGExprExcl(re.arg, "var2", nil);
    in
     (dcl mapCall : CPP`Expr;
      if re.opr = <MAPDOM>
      then mapCall := DS`GenDomExists(var2_v, var1_v)
      else mapCall := DS`GenRngExists(var2_v, var1_v);
      def objCreate = DS`GenBoolExpr(mapCall);
      in
        if stmt1 = [] and stmt2 = []
        then return objCreate
        else return stmt1 ^ stmt2 ^ [BC`GenAsgnStmt(resVar_v, objCreate)];
     );
\end{vdm_al}

\subsubsection{Map Composition Expression}

This version of the code generator does not support function
compositions. The operation $CGComposeExpr$ generates the code
corresponding to map composition expressions.

\begin{vdm_al}
  CGComposeExpr: AS`Expr * AS`Expr * CGMAIN`VT ==> seq of CPP`Stmt
  CGComposeExpr(le, re, resVT) ==
    def type1  = CGAUX`FindType( le );
        type2  = CGAUX`FindType( re );
        mk_(var1_v, stmt1) = CGExprExcl(le, "var1", type1);
        mk_(var2_v, stmt2) = CGExprExcl(re, "var2", type2)
    in
     (dcl rb1_l : seq of CPP`Stmt := stmt1,
          rb2_l : seq of CPP`Stmt := stmt2,
          v1 : CPP`Expr := var1_v,
          v2 : CPP`Expr := var2_v;

      if stmt1 = []
      then
        if CPP`isCPP() or not is_AS`Name(le)
        then
         (v1 := BC`GiveName("v1");
          rb1_l := rb1_l ^ DS`GenDeclInit(type1, v1, var1_v));

      if stmt2 = []
      then
        if CPP`isCPP() or not is_AS`Name(re)
        then
         (v2 := BC`GiveName("v2");
          rb2_l := rb2_l ^ DS`GenDeclInit(type2, v2, var2_v));

      if is_REP`PartialFnTypeRep(type1) or is_REP`TotalFnTypeRep(type1) or
          is_REP`PartialFnTypeRep(type2) or is_REP`TotalFnTypeRep(type2)
      then return rb1_l -- composition of function
      else return rb1_l ^ rb2_l ^ DS`GenComposeExpr(mk_CGMAIN`VT(var1_v, type1), mk_CGMAIN`VT(var2_v, type2), resVT);
     );
\end{vdm_al}


\subsubsection{Map Iteration Expression and Numeric Power}

This version of the code generator does not support function
iterations. The operation $CGIterateExpr$ generates code corresponding
to map iterations and numeric power.

\begin{vdm_al}
CGIterateExpr: AS`Expr * AS`Expr * CGMAIN`VT ==> CPP`Expr | seq of CPP`Stmt
CGIterateExpr(le, re, resVT) ==
  def type1  = CGAUX`FindType( le );
      type2  = CGAUX`FindType( re );
      mk_(var1, stmt1) = CGExprExcl(le, "var1", type1);
      mk_(var2, stmt2) = CGExprExcl(re, "var2", type2);
      vt1 = mk_CGMAIN`VT(var1, type1);
      vt2 = mk_CGMAIN`VT(var2, type2);
      mk_CGMAIN`VT(-, rtype) = resVT;
  in
   (cases true:
      (CGAUX`IsNumType(type1) and CGAUX`IsNumType(type2)) ->
          return stmt1 ^ stmt2 ^ [ DS`GenExp(vt1, vt2, resVT) ],
      (CGAUX`IsMapType(type1) or CGAUX`IsMapType(rtype)) -> -- or CGAUX`IsMapType(rtype) tilfjet 27.7.98 (jojo)
          return stmt1 ^ stmt2 ^ DS`GenMapIteration(vt1, vt2, resVT),
      (CGAUX`IsFctType(type1)) ->
          (CGAUX`SetNotSupportedException(true);
          return [CGAUX`NotSupported("function iteration expression")]),
      others ->
        (dcl stmt : CPP`Stmt,
             cond : CPP`Expr;
         if CPP`isCPP()
         then cond := BC`GenLogOr(DS`GenIsReal(var1), DS`GenIsReal(var2)) --!!!!! skulle vre GenLogAnd
         else cond := DS`GenIsReal(var1);
         def th = DS`GenExp(vt1, vt2, resVT);
             altn = CGAUX`RunTime("Wrong arguments for '**'")
         in stmt := BC`GenIfStmt(cond, th, altn);
         if is_REP`UnionTypeRep(type1)
         then
           let mk_REP`UnionTypeRep(tp_s) = type1 in
            if exists tp in set tp_s & CGAUX`IsMapType(tp) then
              def th = BC`GenBlock(DS`GenMapIteration(vt1, vt2, resVT)) in
                stmt := BC`GenIfStmt(DS`GenIsMap(var1), th, stmt);
         return stmt1 ^ stmt2 ^ [stmt]
        )
    end
   );
\end{vdm_al}

#ifdef VDMPP

\subsection{New Expression}


The code generator does not support arguments to the new expression,
but the empty argument. That is:
\begin{verbatim}
   new A ( a |-> 3, b|-> 4)
\end{verbatim}
is not supported, where as:
\begin{verbatim}
   new A()
\end{verbatim}
Is supported.

\begin{vdm_al}
  CGNewExpr: AS`NewExpr * CGMAIN`VT ==> (seq of CPP`Stmt) | CPP`Expr
  CGNewExpr (mk_AS`NewExpr(nm',exprs,-),mk_CGMAIN`VT(resVar,-)) ==
      def mk_(ok, cl) = CGAUX`ExpandClassName(nm', CGAUX`GiveCurCASName(), {});
          nm = if ok then cl else nm'
      in
--    if CGMAIN`get_j2v_option() and
--       ( CGAUX`IsAbstractClass(nm) or CGMAIN`isInterface(nm))
--    then
--      return DS`GenNullExpr()
--    else
      def l_tmpVars   = [BC`GiveName("arg") | - in set inds exprs];
          l_tmpVarTps = [ CGAUX`FindType(exprs(i)) | i in set inds exprs];
          l_cppL      = [ CGExpr'(exprs(i), mk_CGMAIN`VT(l_tmpVars(i), l_tmpVarTps(i))) | i in set inds exprs];
          l_prepCode  = [ DS`GenDecl(l_tmpVarTps(i), l_tmpVars(i), nil) ^ l_cppL(i) | i in set inds l_cppL
                        & is_(l_cppL(i), seq of CPP`Stmt)];
          l_argL      = [ if is_(l_cppL(i), seq of CPP`Stmt)
                          then l_tmpVars(i)
                          else l_cppL(i) | i in set inds l_cppL];
          const       = DS`CallConstructor(nm, l_argL)
      in
      ( CGAUX`IncludeClass(nm);
        if not (CGMAIN`get_j2v_option() and nm = mk_AS`Name(["JavaLangClass"], -1))
        then CGAUX`SetException(true);
        if l_prepCode = []
        then
          return const
        else
          let constAsgn = BC`GenAsgnStmt(resVar, const)
          in
            return (conc l_prepCode) ^ [ constAsgn ]
      );

\end{vdm_al}

\subsection{Self Expression}

The operation $GenSelfExpr$ generates code corresponding to a self
expression. If $res$ holds the C++ identifier {\tt res} and the object
to be returned by the self expression is an instance of the VDM++
class {\tt A}, then the code corresponding to the self expression will
be the following statements:

\begin{quote}
{\tt res = self;}
\end{quote}

Item one corresponds to the case there the target identifier, $res$,
in an object reference, whereas item two corresponds to the case where
$res$ is of any other (union) type. Note, that the variable {\tt self}
is a member of class {\tt vdmBase}.


\begin{vdm_al}
  GenSelfExpr: CGMAIN`VT ==> CPP`Expr
  GenSelfExpr(-) ==
    if CPP`isCPP()
    then
      let self = BC`GenIdentifier("Self")
      in return BC`GenFctCall(self,[])
    else
      return DS`GenThis();
\end{vdm_al}

\subsection{Is-of-class Expression}
\label{isofclass}

Consider the VDM++ expression:

\begin{verbatim}
isofclass(A, a)
\end{verbatim}

\subsubsection{C++}

The corresponding pseudo code is listed below:

\begin{verbatim}
Generic obj;
...CGExpr(a, mk_CGMAIN`VT(obj, "Generic"));
if (obj.IsClass())
  ...DS`GenIsOfClass("A", obj)
else
  res = (Bool) false;
\end{verbatim}


\subsubsection{Java}

For Java the following code is generated:
\begin{verbatim}
a instanceof A
\end{verbatim}

The operation $CGIsOfClassExpr$ generates code corresponding to a
is-of-class expression.

\begin{vdm_al}
CGIsOfClassExpr: AS`IsOfClassExpr * CGMAIN`VT ==> (seq of CPP`Stmt) | CPP`Expr
CGIsOfClassExpr(mk_AS`IsOfClassExpr(class, arg, -), mk_CGMAIN`VT(res, -)) ==
  def objtp = CGAUX`FindType(arg);
      mk_(obj, rb_l) = CGExprExcl(arg, "obj", nil)
  in
   (dcl cast : CPP`Expr,
        expr : CPP`Expr,
        e : CPP`Expr;
    if CGAUX`IsObjRefType(objtp)
    then cast := obj
    else
      if CPP`isCPP()
      --then cast := BC`GenCastExpr(DS`GenObjRefType(nil), obj)
      then cast := BC`GenFctCall(DS`GenObjRefType(nil).tp, [obj])
      else cast := BC`GenCastExpr(DS`GenObjRefType(nil), obj);
    expr := DS`GenIsOfClassExpr(class, cast);
    if CPP`isCPP()
    then
      if CGAUX`IsObjRefType(objtp)
      then e := expr
      else e := BC`GenCondExpr(DS`GenIsClass(obj), expr, DS`GenBoolLit(false))
    else e := expr;
    if rb_l = []
    then return e
    else return rb_l ^ [ BC`GenAsgnStmt(res, e) ];
   );
\end{vdm_al}

\subsection{Is-of-base-class Expression}

The operation $CGIsOfBaseClassExpr$ generates code corresponding to a
is-of-base-class expression. The operation is similar to
$CGIsOfClassExpr$ (see section \ref{isofclass}).

\begin{vdm_al}
CGIsOfBaseClassExpr: AS`IsOfBaseClassExpr * CGMAIN`VT ==> (seq of CPP`Stmt) | CPP`Expr
CGIsOfBaseClassExpr(mk_AS`IsOfBaseClassExpr(class, arg, -), mk_CGMAIN`VT(res, -)) ==
  def objtp = CGAUX`FindType(arg);
      mk_(obj, rb_l) = CGExprExcl(arg, "obj", nil)
  in
   (dcl cast : CPP`Expr,
        expr : CPP`Expr,
        e : CPP`Expr;
    if CGAUX`IsObjRefType(objtp)
    then cast := obj
    else
      if CPP`isCPP()
      --then cast := BC`GenCastExpr(DS`GenObjRefType(nil), obj)
      then cast := BC`GenFctCall(DS`GenObjRefType(nil).tp, [obj])
      else cast := BC`GenCastExpr(DS`GenObjRefType(nil), obj);
    expr := DS`GenIsOfBaseClassExpr(class, cast);
    if CPP`isCPP()
    then
      if CGAUX`IsObjRefType(objtp)
      then e := expr
      else e := BC`GenCondExpr(DS`GenIsClass(obj), expr, DS`GenBoolLit(false))
    else e := expr;
    if rb_l = []
    then return e
    else return rb_l ^ [ BC`GenAsgnStmt(res, e) ];
   );
\end{vdm_al}

\subsection{Same-class Expression}

Consider the VDM++ expression:

\begin{verbatim}
sameclass(a, b)
\end{verbatim}

\subsubsection{C++}

The corresponding pseudo code is listed below. It is assumed that
{\tt b} is an object reference and {\tt a} is a union type (including
a standard VDM-SL type):

\begin{verbatim}
Generic obj1;
Class Obj2;
...CGExpr(a, mk_CGMAIN`VT(obj1, "Class"));
...CGExpr(b, mk_CGMAIN`VT(obj2, "Class"));
if (obj1.IsClass())
  res = (Bool) ((Class) obj1).MyClass() == obj2.MyClass();
else
   res = (Bool) false;
\end{verbatim}

\subsubsection{Java}

If both expressions are of type ObjectRef, the following code is generated:
\begin{verbatim}
...CGExpr(a, mk_CGMAIN`VT(obj1, "Class"));
...CGExpr(b, mk_CGMAIN`VT(obj2, "Class"));
obj1.getClass() == obj2.getClass()
\end{verbatim}

otherwise, if they are not both of type ObjectRef, the following alternative code is generated:

\begin{verbatim}
UTIL.SameClass(obj1,obj2)
\end{verbatim}

The operation $CGSameClassExpr$ generates code corresponding to a
sameclass expression.

\begin{vdm_al}
CGSameClassExpr: AS`SameClassExpr * CGMAIN`VT ==> (seq of CPP`Stmt) | CPP`Expr
CGSameClassExpr(mk_AS`SameClassExpr(e1, e2, -), mk_CGMAIN`VT(res, -)) ==
  def mk_(obj1, obj2, rb_l, areObjRefs, cond) = GenClassOrBase(e1, e2, false);
      my1 = DS`GenMyClass(obj1);
      my2 = DS`GenMyClass(obj2);
  in
   (dcl expr : CPP`Expr,
        e : CPP`Expr;
    if CPP`isCPP()
    then expr := DS`GenBoolExpr(BC`GenEq(my1, my2))
    else
      if areObjRefs
      then
        let fctcall = BC`GenFctCallObjMemAcc(my1, "equals", [my2])
        in expr := DS`GenBoolExpr(fctcall)
      else expr := DS`GenBoolExpr(BC`GenFctCall(BC`GenIdentifier("UTIL.sameclass"), [obj1, obj2]));
    if cond = nil
    then e := expr
    else e := BC`GenCondExpr(cond, expr, DS`GenBoolLit(false));

    if rb_l = []
    then return e
    else return rb_l ^ [ BC`GenAsgnStmt(res, e) ];
   );
\end{vdm_al}


\subsection{Same-base-class Expression}

Consider the VDM++ expression:

\begin{verbatim}
samebaseclass(a, b)
\end{verbatim}

\subsubsection{C++}

The corresponding pseudo code is listed below. It is assumed that
{\tt a} is an object reference and {\tt b} is a union type (including
a standard VDM-SL type):

\begin{verbatim}
Class obj1;
Generic obj2;
...CGExpr(a, mk_CGMAIN`VT(obj1, "Class"));
...CGExpr(b, mk_CGMAIN`VT(obj2, "Generic"));
if (obj2.IcClass())
  ...DS`GenSameBaseClass(obj1, obj2);
else
  res = (Bool) false;
\end{verbatim}


\subsubsection{Java}

If both expressions are of type ObjectRef, the following code is generated:
\begin{verbatim}
...CGExprExcl(a, "obj1", nil);
...CGExprExcl(b, "obj1", nil);
obj1.getBaseClass() == obj2.getBaseClass()
\end{verbatim}

otherwise, if they are not both of type ObjectRef, the following alternative code is generated:

\begin{verbatim}
UTIL.SameBaseClass(obj1,obj2)
\end{verbatim}

If a variable is a Union Type of two ObjectRef Types, the UTIL method is used,
because this variable will be declared to be of type Object (Union Type) and
it is imposssible to invoke the getBaseClass method on an Object.

The operation $CGSameBaseClassExpr$ generates code corresponding to a
samebaseclass expression.

\begin{vdm_al}
CGSameBaseClassExpr: AS`SameBaseClassExpr * CGMAIN`VT ==> (seq of CPP`Stmt) | CPP`Expr
CGSameBaseClassExpr(mk_AS`SameBaseClassExpr(e1, e2, -), mk_CGMAIN`VT(res, -)) ==
  def mk_(obj1, obj2, rb_l, areObjRefs, cond) = GenClassOrBase(e1, e2, true);
      expr = DS`GenSameBaseClassExpr(obj1, obj2, areObjRefs);
  in
   (dcl e : CPP`Expr;
    if cond = nil
    then e := expr
    else e := BC`GenCondExpr(cond, expr, DS`GenBoolLit(false));

    if rb_l = []
    then return e
    else return rb_l ^ [ BC`GenAsgnStmt(res, e) ];
   );
\end{vdm_al}

The operation $GenClassOrBase$ is an auxiliary operation to
$CGSameClassExpr$ and $CGSameBaseClassExpr$. This operation generates
code which is common to both same-base-class and same-class
expressions.

The parameter cast is true, when casting is necessary
(this is the case when GenClassOrBase is
invoked from CGSameBaseClassExpr. The Object class does has no method
"getBaseClass", but every Object has the method "getClass")

The boolean return parameter is true when both expressions are ObjectRefTypes
and the getBaseClass and getClass methods directly can be called on the objects
The use of the UTIL.SameBaseClass and UTIL.SameClass methods are not used in this case.

\begin{vdm_al}
GenClassOrBase: AS`Expr * AS`Expr * bool ==> CPP`Expr * CPP`Expr * seq of CPP`Stmt * bool * [CPP`Expr]
GenClassOrBase(e1, e2, cast) ==
  def obj1tp = CGAUX`FindType(e1);
      obj2tp = CGAUX`FindType(e2);
      oti    = DS`GenObjRefType(nil);
      mk_(obj1_v, obj1_stmt) = CGExprExcl(e1, "obj1", nil);
      mk_(obj2_v, obj2_stmt) = CGExprExcl(e2, "obj2", nil)
  in
   (dcl rb_l : seq of CPP`Stmt,
        cond : [CPP`Expr] := nil,
        is1  : bool := CGAUX`IsObjRefType(obj1tp),
        is2  : bool := CGAUX`IsObjRefType(obj2tp),
        obj1 : CPP`Expr := obj1_v,
        obj2 : CPP`Expr := obj2_v;
    rb_l := obj1_stmt ^ obj2_stmt;
    if CPP`isCPP()
    then
      cases true:
        (not is1 and not is2) -> (if obj1 = obj2
                                  then cond := DS`GenIsClass(obj1)
                                  else cond := BC`GenLogAnd(DS`GenIsClass(obj1), DS`GenIsClass(obj2));
                                  --obj1 := BC`GenCastExpr(oti, obj1);
                                  --obj2 := BC`GenCastExpr(oti, obj2)
                                  obj1 := BC`GenFctCall(oti.tp, [obj1]);
                                  obj2 := BC`GenFctCall(oti.tp, [obj2])
                                  ),
        (not is1)             -> (cond := DS`GenIsClass(obj1);
                                  --obj1 := BC`GenCastExpr(oti, obj1)
                                  obj1 := BC`GenFctCall(oti.tp, [obj1])
                                 ),
        (not is2)             -> (cond := DS`GenIsClass(obj2);
                                  --obj2 := BC`GenCastExpr(oti, obj2)
                                  obj2 := BC`GenFctCall(oti.tp, [obj2])
                                 )
      end
    else
      if cast
      then
       (if is1 then
          cases obj1tp:
           mk_REP`ObjRefTypeRep(-) -> obj1 := obj1, --obj1 := BC`GenCastExpr(DS`GenType(obj1tp),obj1),
           others -> is1 := false
          end;
        if is2 then
          cases obj2tp:
           mk_REP`ObjRefTypeRep(-) -> obj2 := obj2, -- BC`GenCastExpr(DS`GenType(obj2tp),obj2),
           others -> is2 := false
          end;);
   return mk_(obj1, obj2, rb_l, (is1 and is2), cond)
  );
\end{vdm_al}

#endif

\subsection{Auxiliary Operations}
\label{ExprAux}


The operation $CGComprehension$ is an auxiliary operation to the
operations generating code for map and set comprehension.

The operation takes six input paramters:

\begin{description}
\item{bind:} A bind list.

\item{pred:} An optional expression.

\item{stmt:} A C++ statement, which is to be executed in each of the
  iterations if the predicate, pred, is true.

\item{contexpr:} An optional C++ boolean expression which defines
  when to stop the iteration through the combinations of the values in
  the bind list (this is used in when the operation is called from
  the operation $CGAllOrExistsExpr$). The iteration stops when
  contexpr is false.

\item{notpred:} An optional C++ statement. The statement is inserted
  in the iteration of the combination of the values in the bind list
  if the optional predicate $pred$ evaluates to false.

\item{pid\_m:} A map of names to their type.

\end{description}

The operation generates code which for each possible binding of the
patterns in the bind list $bind$ which fulfills the expression
$pred$ executes the C++ statement $stmt$.

In the description of the pseudo code of the evaluation of a set
comprehension (section \ref{EXPRSetCompExpr}) the meta call of the
function:

\begin{verbatim}
...CGComprehension("a, b in set {1, 3}, c in set {4, 5}", "a+b=c",
                   "{ ...CGExpr("a+b", mk_CGMAIN`VT( elem, "Int" ) );
                      res_s.Insert(elem) }", nil, nil );
\end{verbatim}

The corresponding pseudo code of this call is listed below:

\begin{verbatim}
Set e_set (..CGExpr({1,3}) );
Set e_set_2 (e_set);
Set e_set_3 (..CGExpr({4,5}));
Int vdm_var_a;
Int vdm_var_b;
Int vdm_var_c; // Declaration of the corresponding pattern variables
               // included in the bind list.
Generic e_g;
for (int cc = e_set_3.First(e_g); cc; cc = e_set_3.Next(e_g)) {
  succ_v = true
  ..CGPatternMatch(c, e_g, succ_v);
  if (succ_v) {
  Generic e_g;
  for (int bb = e_set_2.First(e_g); bb; bb = e_set_2.Next(e_g)) {
  succ_v = true;
  if succ_v {
    Generic e_g;
    for (int aa = e_set.First(e_g); aa; aa = e_set_3.Next(e_g)) {
    succ_v = true;
    ..CGPatternMatch(a, e_g, succ_v);
    if (succ_v ) {
      .. CGExpr(a+g, elem);
      res_s.Insert(elem);
      }
    }
  }
}
\end{verbatim}

\begin{vdm_al}
CGComprehension: AS`BindList * [ AS`Expr ] * seq of CPP`Stmt * [ CPP`Expr ] *
                       [CPP`Stmt] * map AS`Name to REP`TypeRep * bool ==> [CPP`Stmt]
CGComprehension(bind, pred, stmt, contexpr, notpred, pid_m, nonstop ) ==
  if exists b in set elems bind & is_AS`MultTypeBind(b)
  then
   (CGAUX`SetNotSupportedException(true);
    return CGAUX`NotSupported("type bind"))
  else
    def bind_l = MergeMultSetBind(bind);
        mk_(stmts, msb) = FindMultSetBind2(bind_l); -- must be before DeclPatVars
    in
      if len msb = 1 and forall p in set elems msb(1).#1 & is_AS`PatternName(p)
      then
        let mk_(p_l,e_v,e_type) = msb(1),
            setexpr = (hd bind_l).Set
        in
          def e_t = CGAUX`FindSetElemType(e_type);
              seqindices = CGAUX`IsSeqIndicesSet(setexpr);
          in
           (dcl id_l : seq of CPP`Identifier := [],
                stmt_l : seq of CPP`Stmt,
                seqapply_s : set of (CPP`Expr * CPP`Expr) := {};
            for p in p_l do
              let mk_AS`PatternName(name,-,-) = p
              in
                if name = nil
                then id_l := id_l ^ [BC`GiveName("elem")]
                else
                  def - = CGAUX`InsertName(name); -- must be GenPredicateStmt
                  in
                   (id_l := id_l ^ [BC`Rename(name)];
                    if seqindices
                    then seqapply_s := seqapply_s union {mk_(BC`Rename(setexpr.arg), BC`Rename(name))};
                   );
            CGAUX`AddNoCheckSeqApply(seqapply_s);
            stmt_l := GenPredicateStmt(pred, stmt, notpred); 
            CGAUX`RemNoCheckSeqApply(seqapply_s);
            for id in id_l do
              stmt_l := DS`GenIterSet(mk_CGMAIN`VT(e_v, e_type), contexpr, mk_CGMAIN`VT(id, e_t), stmt_l);
            return CGAUX`GenCPPStmt(stmts ^ stmt_l)
          )
      else
        def succ_v = BC`GiveName("succ");
            asgn_succ_true = BC`GenAsgnStmt(succ_v, BC`GenBoolLit(true));
            rb_p = DeclPatVars(pid_m); -- must be after FindMultSetBind2 and must be before GenPredicateStmt
        in
         (dcl rb : seq of CPP`Stmt := stmts ^ (if nonstop then [] else rb_p),
              pn_l : seq of set of AS`Name := FindPatternIdInBindList(bind_l),
              need_succ : bool := false,
              inner : seq of CPP`Stmt := GenPredicateStmt(pred, stmt, notpred); -- must be after DeclPatVars
          for idx = 1 to len msb do
          let mk_(pat_l, e_v, e_type) = msb(idx)
          in
           (dcl e1_v : CPP`Expr := e_v;
            for i = 1 to len pat_l do
              let pn_s = hd pn_l
              in
               (pn_l := tl pn_l;
                if (i > 1)
                then
                  def e2_v = BC`GiveName("e_set")
                  in
                   (rb := rb ^ DS`GenDeclInit(e_type, e2_v, e_v);
                    e1_v := e2_v);
                def pat             = pat_l(i);
                    e_set_cg_vt     = mk_CGMAIN`VT(e1_v, e_type);
                    e_g_v           = BC`GiveName("elem");
                    e_t             = CGAUX`FindSetElemType(e_type);
                    p               = if inner = [] then nil else inner;
                    mk_(pm, Is_Excl) = PM`CGPatternMatchExcl(pat,mk_CGMAIN`VT(e_g_v, e_t), pn_s,
                                                             succ_v, pid_m, p, nonstop);
                    pm1             = (if Is_Excl and p = nil
                                       then [asgn_succ_true]
                                       else []) ^ pm;
                in
                 (dcl this_bl : seq of CPP`Stmt;
                  if nonstop and idx = len msb and i = len pat_l
                  then this_bl := MergeStmts(rb_p, pm1)
                  else this_bl := pm1;
                  inner := DS`GenIterSet(e_set_cg_vt, contexpr, mk_CGMAIN`VT(e_g_v, e_t), this_bl);
                  need_succ := not Is_Excl or need_succ)
               ) -- end of inner loop
           ); -- end of for outer loop
          rb := rb ^ inner;
          if need_succ
          then rb := [BC`GenDecl(DS`GenSmallBoolType(), succ_v,
                                 BC`GenAsgnInit( BC`GenBoolLit(false)))] ^ rb;
          return CGAUX`GenCPPStmt(rb);
         );
\end{vdm_al}

One line will never be covered. Indeed, the parser replaces every time
the predicate value which has to be here equal to nil to
true. Therefore the line will never be covered. Some changes will have
to be done on the parser.

\begin{vdm_al}
GenPredicateStmt: [ AS`Expr] * seq of CPP`Stmt * [CPP`Stmt] ==> seq of CPP`Stmt
GenPredicateStmt( pred, stmt, notpred ) ==
  if pred = nil
  then return stmt
  else
    def mk_(res, res_stmt) = CGExprExcl(pred, "pred", nil);
        predType = CGAUX`FindType(pred)
    in
     (dcl rb : seq of CPP`Stmt := res_stmt;
      if predType = mk_REP`BooleanTypeRep()
      then
        if stmt = []
        then if notpred <> nil
             --then rb := rb ^ [BC`GenIfStmt(BC`GenNot(DS`GenGetValue(res, predType)), notpred, nil)]
             then
               def e = DS`GenGetValue(res, predType)
               in
                 cases e:
                   mk_CPP`BracketedExpr(mk_CPP`UnaryOpExpr(mk_CPP`UnaryOp(<NEG>,-),cond,-),-),
                   mk_CPP`UnaryOpExpr(mk_CPP`UnaryOp(<NEG>,-),cond,-) -> 
                     rb := rb ^ [BC`GenIfStmt(cond, notpred, nil)],
                   others -> rb := rb ^ [BC`GenIfStmt(BC`GenNot(e), notpred, nil)]
                 end
             else skip
        else rb := rb ^ [BC`GenIfStmt(DS`GenGetValue(res, predType), BC`GenBlock(stmt), notpred)]
      else
       (dcl pred_v : CPP`Expr := res,
            cond : CPP`Expr;
        if not is_CPP`Identifier(res)
        then
          (pred_v := BC`GiveName("pred");
           rb := rb ^ DS`GenDecl(predType, pred_v, BC`GenAsgnInit(res)));
        if CPP`isCPP()
        then cond := DS`GenGetValue( BC`GenCastExpr(DS`GenBoolType(), pred_v), predType )
        else cond := DS`GenGetValue( BC`GenCastExpr(DS`GenBoolType(), pred_v), mk_REP`BooleanTypeRep());
        def ifpred = BC`GenIfStmt(cond, BC`GenBlock(stmt), notpred)
        in
          rb := rb ^ [ BC`GenIfStmt( DS`GenIsBool( pred_v ), ifpred,
                        BC`GenBlock([CGAUX`RunTime( "A boolean was expected" )]) ) ];
       );
      return rb;
     );
\end{vdm_al}


\begin{vdm_al}
DeclarePatVars: AS`Pattern ==> seq of CPP`Stmt
DeclarePatVars(pat) ==
  def mk_(-, pid_m) = SamePatternIds([pat])
          -- bool * map (AS`Name | AS`OldName) to set of REP`TypeRep
  in return DeclarePatterns(pid_m);

DeclPatVars: map AS`Name to REP`TypeRep ==> seq of CPP`Stmt
DeclPatVars( pid_m ) ==
 (dcl rb: seq of CPP`Stmt := [];
  for all var in set dom pid_m do
    def - = CGAUX`InsertName(var)
    in rb := rb ^ DS`GenDecl( pid_m(var), BC`Rename(var), nil );
  return rb
 );
\end{vdm_al}

\begin{vdm_al}
FindMultSetBind2: AS`BindList
         ==> seq of CPP`Stmt * seq of (seq of AS`Pattern * CPP`Expr * REP`TypeRep)
FindMultSetBind2(bind) ==
  def allpnms = dunion { dunion { dom FindPatternId(pat) | pat in set elems pat_l }
                                        | mk_AS`MultSetBind(pat_l,-,-) in set elems bind }
  in
   (dcl msb : seq of (seq of AS`Pattern * CPP`Expr * REP`TypeRep) := [],
        rb : seq of CPP`Stmt := [];
    for mk_AS`MultSetBind(pat_l, e_set,-) in bind do
      def lastEnv = CGAUX`CurrentEnv();
          - = CGAUX`PopLastEnv();
          mk_(e_v, e_stmt) = CGExprExcl(e_set, "e_set", nil);
          - = CGAUX`PushThisEnv(lastEnv);
          e_type = CGAUX`FindType(e_set);
          allnames = CGAUX`FindAllNamesInExpr(e_set)
      in
        if not CGAUX`IsSetType(e_type)
        then def e1_v = BC`GiveName("e1_set");
                 cond = DS`GenIsSet(e_v);
                 decl_e1_v = DS`GenDeclSet(e1_v, nil);
                 alt2 = BC`GenBlock([CGAUX`RunTime("A set was expected")])
             in (dcl alt1 : CPP`Stmt;
                 if CPP`isCPP()
                 then alt1 := BC`GenBlock([BC`GenAsgnStmt(e1_v, e_v)])
                 else alt1 := BC`GenBlock([BC`GenAsgnStmt(e1_v, DS`GenCastSetType(e_v))]);
                 rb := rb ^ e_stmt ^ decl_e1_v ^ [ BC`GenIfStmt( cond, alt1, alt2) ];
                 msb := msb ^ [ mk_(pat_l, e1_v, e_type)]; )
        elseif e_stmt = [] and ( (allpnms inter allnames <> {}) or (not is_AS`Name(e_set)))
        then def e1_v   = BC`GiveName("e1_set");
                 s_init = DS`GenConstDeclInit(e_type, e1_v, e_v)
             in (rb  := rb ^ e_stmt ^ s_init;
                 msb := msb ^ [ mk_(pat_l, e1_v, e_type)] )
        else ( rb := rb ^ e_stmt;
               msb := msb ^ [ mk_(pat_l, e_v, e_type)] );
    return mk_(rb, msb)
   );

FindPatternIdInBindList: AS`BindList ==> seq of set of AS`Name
FindPatternIdInBindList(bind) ==
  def p_l = conc [ bind(i).pat | i in set inds bind ];
      pn_l = [ dunion { dom FindPatternId(p_l(j)) | j in set {i+1, ..., len p_l} }
                                               | i in set inds p_l];
  in return pn_l;

MergeMultSetBind: AS`BindList ==> AS`BindList
MergeMultSetBind(bind) ==
 (dcl bind_l : seq of AS`MultSetBind := [],
      m : map AS`Expr to AS`MultSetBind := {|->};
  for mk_AS`MultSetBind(pat_l, e_set, cid) in bind do
    if e_set in set dom m
    then
      let mk_AS`MultSetBind(p_l, s, cid2) = m(e_set)
      in m := m ++ {e_set |-> mk_AS`MultSetBind(p_l ^ pat_l,s,cid2)}
    else m := m ++ {e_set |-> mk_AS`MultSetBind(pat_l, e_set, cid)};
  for all e in set dom m do
    bind_l := bind_l ^ [m(e)]; 
  return bind_l;
 );

end CGEXPR
\end{vdm_al}

\subsection{Test Coverage}

\begin{rtinfo}[CGEXPR`XXXXXXXXXFindMapTypeInMapDistrMerge]
{rtinfo.ast}[CGEXPR]
\end{rtinfo}
