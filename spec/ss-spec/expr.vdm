%--------------------------------------------------------------------------------
% WHAT
%    Well-formedness of Expressions for the Static Semantics of VDM++
% $Id: expr.vdm,v 1.134 2006/03/06 05:02:37 vdmtools Exp $
% Implemented in: expr.cc, expr2.cc, expr3.cc 
%--------------------------------------------------------------------------------

\section{Expressions}

This section contains all well-formedness formulae which deals with
the correctness of expressions. Currently only sequence modify and map
override expressions are not fully dealt with. More checking needs to
be done for this kind of expression, but otherwise the specification
of expressions should be complete.
The interface of the EXPR module can be seen from figure~\ref{expr}.

The EXPR module exports its main operation $wf-Expr$ (and
a few other minor constructs) to the DEF module and the STMT
module (a minor dependency is also present
because a pattern can contain an expression and thus one
operation in PAT uses $wf-Expr$). EXPR imports constructs from
PAT and all the third level modules (TYPE, AUX and ENV).

%\insertfig{expr.ps}{13cm}{Interface for the EXPR module}{\label{expr}} 

\begin{vdm_al}
module EXPR

imports
  from DEF operations
    wf_ImplFunction : TYPE`Ind * AS`ImplFnDef ==> bool;
    wf_ExplFunction : TYPE`Ind * AS`ExplFnDef ==> bool;
    wf_ExtExplFunction : TYPE`Ind * AS`ExtExplFnDef ==> bool;
    wf_TypeList: TYPE`Ind * seq of AS`Type ==> bool,

  from ERR all,

#ifdef VICE
  from VCM operations
    IsSysClass : AS`Name ==> bool,
#endif VICE

  from ENV operations
    EnterScope : map AS`Name to (REP`TypeRep * nat1) ==> ();
    LeaveScope : () ==> ();
    UpdateScope : map AS`Name to (REP`TypeRep * nat1) ==> ();
    TransType: [AS`Name] * AS`Type ==> REP`TypeRep;
    TransTypeList: [AS`Name] * seq of AS`Type ==> seq of REP`TypeRep;
#ifdef VDMSL
    LookUp: AS`Name * bool ==> [REP`TypeRep];
    LookUpTag : TYPE`Ind * AS`Name * set of AS`Name ==> [AS`Name * seq of REP`FieldRep];
    GetContext: () ==> <PURE>|<ALL>|<PRE>|<POST>|<PUREOP>|<IMPL>|<VALUE>;
    LookUpState: AS`Name * bool * (<OLD> | <CUR>) ==> [REP`TypeRep];
    LookUpPolyFn: AS`Name ==> [seq of REP`TypeVarRep * REP`FnTypeRep];
    LookUpTypeName : AS`Name ==> [REP`TypeRep];
#endif VDMSL
#ifdef VDMPP
    IsSubClass: AS`Name * AS`Name ==> bool;
    SetDefClass: [AS`Name] ==> ();
    LookUp: AS`Name * bool ==> [REP`TypeRep|ENV`AccessType  |
                                set of (ENV`AccessOpTypeRep |
                                        ENV`AccessFnTypeRep |
                                        ENV`AccessPolyTypeRep) |
                                set of REP`TypeRep];
    
    LookUpTag : TYPE`Ind * AS`Name * set of AS`Name ==> [AS`Name * (ENV`AccessFieldRep|ENV`TagRepElem)];
    GetContext: () ==> <PURE>|<IMPL>|<ALL>|<PRE>|<POST>|<PUREOP>|<VALUE>|<PERM>|<PTHREAD>;
    LookUpOperationName : [AS`Name] * AS`Name * [AS`Expr] ==> set of ENV`AccessType;
    LookUpInObject: AS`Name * AS`Name * bool * bool
                  ==> [ENV`AccessType| set of (ENV`AccessOpTypeRep | ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep)];
    IsAccessibleCurClass :  ENV`AccessType ==> bool;
    GetStatic : () ==> bool;
    SetStatic : bool ==> ();
    DefaultConstructorAccessible : AS`Name ==> bool;
    ConstructorExists : TYPE`Ind * AS`Name * seq of REP`TypeRep * AS`Expr ==> bool;
    CheckAccess: AS`Name * [ENV`AccessType     |
                            REP`TypeRep        |
                            ENV`TagRepElem     |
                            set of REP`TypeRep | 
                            set of (ENV`AccessOpTypeRep | ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep)] 
               ==> [REP`TypeRep     | 
                    ENV`TagRepElem  | 
                    set of (REP`FnTypeRep | REP`OpTypeRep | REP`PolyTypeRep) ];
    CheckSubRespIsImplemented : TYPE`Ind * AS`Name ==> bool;
    LookUpState: AS`Name * bool * (<OLD> | <CUR>) ==> [ENV`AccessType|REP`TypeRep];
    GetCurClass : () ==> AS`Name;
    CheckClassName: AS`Name ==> bool;
    ExpandClassName: AS`Name * set of AS`Name ==> bool * AS`Name;
    LookUpTypeName : AS`Name * bool ==> [ENV`AccessType | REP`TypeRep];
    CheckAccessCurClass: [ENV`AccessType |
                          REP`TypeRep    | 
                          ENV`TagRepElem |
                          set of REP`TypeRep| set of (ENV`AccessOpTypeRep | 
                                                      ENV`AccessFnTypeRep | 
                                                      ENV`AccessPolyTypeRep)]
               ==> [REP`TypeRep|ENV`TagRepElem  | 
                  set of (REP`FnTypeRep | REP`OpTypeRep | REP`PolyTypeRep) ];
#endif VDMPP
    UsedStateIds: set of AS`Name ==> set of AS`Name;
    ExtractPatterns: TYPE`Ind * seq of (AS`FnDef | AS`ValueDef) ==> bool * map AS`Name to (REP`TypeRep * bool);
    wf_ValueDef : TYPE`Ind * AS`ValueDef ==> bool * map AS`Name to (REP`TypeRep * nat1)
    functions
    GetMethDom : (REP`OpTypeRep | REP`FnTypeRep) -> seq of REP`TypeRep;
#ifdef VDMPP
    IsAccessType: [ENV`AccessType|REP`TypeRep|ENV`TagRepElem| 
                   set of (ENV`AccessOpTypeRep | ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep)|
                   set of (REP`FnTypeRep | REP`OpTypeRep)] -> bool;
#endif VDMPP
  
    PrintName : AS`Name -> seq of char

#ifdef VDMPP
  types

    AccessType = ENV`AccessTypeRep | ENV`AccessFnTypeRep  | ENV`AccessPolyTypeRep
                 | ENV`AccessOpTypeRep | ENV`AccessFieldRep;

    AccessTypeRep;
    AccessFnTypeRep;
    AccessPolyTypeRep;
    AccessOpTypeRep;
    AccessFieldRep;
    TagRepElem = seq of REP`FieldRep
#endif VDMPP
    ,

  from TYPE operations
    IsCompatible: TYPE`Ind * REP`TypeRep * REP`TypeRep ==> bool;
    IsUnionRecursive: REP`TypeRep ==> bool;
    types Ind = <POS> | <DEF>,

  from AS all,

  from CI all,

  from REP all,

  from UTIL
    functions
    itoa: nat-> seq of char,
    
  from AUX
    operations
      IntersectTypeReps : REP`TypeRep * REP`TypeRep ==> REP`TypeRep;
      ExtractIntNumType : REP`TypeRep ==> REP`TypeRep;
      ExtractNumericType : REP`TypeRep ==> REP`TypeRep;
      ExtractSetType : REP`TypeRep ==> REP`TypeRep;
      ExtractSeqType : REP`TypeRep ==> REP`TypeRep;
      SetTypeMinus: REP`TypeRep * REP`TypeRep ==> [REP`TypeRep];
      SetTypeInter: set of REP`TypeRep ==> REP`TypeRep;
      RngSubTypeDom: set of REP`TypeRep ==> bool;
      ExtractComposeType: TYPE`Ind * REP`TypeRep * REP`TypeRep ==> bool * REP`TypeRep * REP`TypeRep * REP`TypeRep;
      ExtractFunType : REP`TypeRep ==> [REP`TypeRep];
      ExtractMapType : REP`TypeRep ==> [REP`TypeRep];
      ExtractCompositeType : REP`TypeRep ==> [REP`TypeRep];
      ExtractProductType : REP`TypeRep * nat * (<EQ>|<GE>) ==> [REP`ProductTypeRep];
      MapTypeMerge: set of [REP`TypeRep] ==> REP`TypeRep;
      MapTypeDomRestrict: REP`TypeRep * [REP`TypeRep] ==> REP`TypeRep * (<OK> | <NOTOVERLAP> | <EMPTYMAP>);
      MapTypeRngRestrict: [REP`TypeRep] * REP`TypeRep ==> REP`TypeRep * (<OK> | <NOTOVERLAP> | <EMPTYMAP>);
      CanBeApplied: [REP`TypeRep] ==> bool * [REP`TypeRep];
#ifdef VDMPP
      ExtractObjRefType : REP`TypeRep ==> [REP`TypeRep];
#endif VDMPP
    functions
    InstFn: (<PAR> | <VAR> | <REN>) * REP`TypeRep * map AS`Name to REP`TypeRep -> REP`TypeRep;
    MergeNumericTypes : set of REP`TypeRep -> set of REP`TypeRep;
    MostGeneralNumericType : set of REP`TypeRep -> REP`TypeRep;
    MergeTypes : [REP`TypeRep | set of REP`TypeRep] * [REP`TypeRep | set of REP`TypeRep] -> REP`TypeRep;
    UnmaskSetType: TYPE`Ind * REP`TypeRep -> [REP`TypeRep];
    UnmaskSeqType: TYPE`Ind * REP`TypeRep -> [REP`TypeRep];
    SplitMapType: [REP`TypeRep] -> [REP`TypeRep] * [REP`TypeRep];
    SeqMapTypeModify: REP`TypeRep * REP`TypeRep * REP`TypeRep -> REP`TypeRep;
    Pre: AS`Name -> AS`Name;
    Post: AS`Name -> AS`Name;

    SetTypeUnion: set of REP`TypeRep -> REP`TypeRep;
    SeqTypeConc: set of REP`TypeRep -> REP`TypeRep;
    RemoveEmptySetType: REP`TypeRep -> REP`TypeRep;
    RemoveEmptySeqType: REP`TypeRep -> REP`TypeRep;
    RemoveEmptyMapType: REP`TypeRep -> REP`TypeRep;
    InverseMapType: [REP`TypeRep] -> REP`TypeRep,

  from PAT operations
    wf_Pattern: TYPE`Ind * AS`Pattern * REP`TypeRep ==> [bool] * map AS`Name to (REP`TypeRep * nat1);
    wf_PatternBind: TYPE`Ind * AS`PatternBind * REP`TypeRep ==> [bool] * map AS`Name to (REP`TypeRep * nat1);
    wf_Bind : TYPE`Ind * AS`Bind ==> [bool] * map AS`Name to (REP`TypeRep * nat1);
    wf_SetBind : TYPE`Ind * AS`SetBind ==> [bool] * map AS`Name to (REP`TypeRep * nat1);
    wf_SeqBind : TYPE`Ind * AS`SeqBind ==> [bool] * map AS`Name to (REP`TypeRep * nat1);
    wf_BindAndType : TYPE`Ind * AS`Bind ==> [bool] * (map AS`Name to (REP`TypeRep * nat1)) * REP`TypeRep;
    wf_TypeBindList : TYPE`Ind * seq of AS`TypeBind ==> [bool] * (map AS`Name to (REP`TypeRep * nat1)) * seq of REP`TypeRep;
    wf_MultiBindList: TYPE`Ind * seq of AS`MultBind * bool ==> [bool] * map AS`Name to (REP`TypeRep * nat1);
    PatternBind2TypeRep : AS`PatternBind ==> REP`TypeRep
      
exports operations
#ifdef VICE
  CpuOrBusOutSideSys: AS`Name ==> bool;
#endif VICE
  wf_Name : TYPE`Ind * AS`Name ==> bool * REP`TypeRep;
  wf_Expr : TYPE`Ind * AS`Expr * REP`TypeRep ==> bool * REP`TypeRep;
  wf_LocalDefs: TYPE`Ind * seq of AS`LocalDef ==> bool;
  CheckApply: TYPE`Ind * REP`TypeRep * seq of REP`TypeRep * (AS`ApplyExpr | AS`StateDesignator) * bool
            ==> bool * (REP`TypeRep | set of REP`TypeRep);
  CheckFieldSelect: TYPE`Ind * REP`TypeRep * (AS`Name|AS`FctTypeInstExpr) * bool ==> 
                    bool * (REP`TypeRep | set of REP`TypeRep);
  CheckBasicApply : TYPE`Ind * REP`TypeRep * seq of REP`TypeRep * (AS`ApplyExpr | AS`StateDesignator) * bool
                  ==> bool * REP`TypeRep;
  CheckOverloadedApply : TYPE`Ind * (set of REP`FnTypeRep | set of REP`OpTypeRep) 
                       *  seq of REP`TypeRep 
                       * (AS`Expr | AS`StateDesignator)
                       * bool 
                       * bool 
                       ==> bool * REP`TypeRep
  
definitions
  operations
    wf_Expr: TYPE`Ind * AS`Expr * REP`TypeRep ==> bool * REP`TypeRep
    wf_Expr (i, expr, exptp) ==
      cases true:
        (is_AS`Name(expr))                     -> return wf_Name(i,expr),
        (is_AS`DefExpr(expr))                  -> return wf_DefExpr(i,expr,exptp),
        (is_AS`LetExpr(expr))                  -> return wf_LetExpr(i,expr,exptp),
        (is_AS`LetBeSTExpr(expr))              -> return wf_LetBeSTExpr(i,expr,exptp),
        (is_AS`IfExpr(expr))                   -> return wf_IfExpr(i,expr,exptp),
        (is_AS`CasesExpr(expr))                -> return wf_CasesExpr(i,expr,exptp),
        (is_AS`PrefixExpr (expr))              -> return wf_PrefixExpr(i,expr,exptp),
        (is_AS`BinaryExpr(expr))               -> return wf_BinaryExpr(i,expr,exptp),
        (is_AS`AllOrExistsExpr(expr))          -> return wf_AllOrExistsExpr(i,expr,exptp),
        (is_AS`ExistsUniqueExpr(expr))         -> return wf_ExistsUniqueExpr(i,expr,exptp),
        (is_AS`SetEnumerationExpr(expr))       -> return wf_SetEnumerationExpr(i,expr,exptp),
        (is_AS`SetComprehensionExpr(expr))     -> return wf_SetComprehensionExpr(i,expr,exptp),
        (is_AS`SetRangeExpr(expr))             -> return wf_SetRangeExpr(i,expr,exptp),
        (is_AS`SeqEnumerationExpr(expr))       -> return wf_SeqEnumerationExpr(i,expr,exptp),
        (is_AS`SeqComprehensionExpr(expr))     -> return wf_SeqComprehensionExpr(i,expr,exptp),
        (is_AS`SubSequenceExpr(expr))          -> return wf_SubSequenceExpr(i,expr,exptp),
        (is_AS`SeqModifyMapOverrideExpr(expr)) -> return wf_SeqModifyMapOverrideExpr(i,expr,exptp),
        (is_AS`MapEnumerationExpr(expr))       -> return wf_MapEnumerationExpr(i,expr,exptp),
        (is_AS`MapComprehensionExpr(expr))     -> return wf_MapComprehensionExpr(i,expr,exptp),
        (is_AS`TupleConstructorExpr(expr))     -> return wf_TupleConstructorExpr(i,expr,exptp),
        (is_AS`TupleSelectExpr(expr))          -> return wf_TupleSelectExpr (i,expr,exptp),
        (is_AS`TypeJudgementExpr (expr))       -> return wf_TypeJudgementExpr (i,expr,exptp),
        (is_AS`PreConditionApplyExpr (expr))   -> return wf_PreConditionApplyExpr (i,expr,exptp),
        (is_AS`TokenConstructorExpr(expr))     -> return wf_TokenConstructorExpr(i,expr,exptp),
        (is_AS`RecordConstructorExpr (expr))   -> return wf_RecordConstructorExpr(i,expr,exptp),
        (is_AS`RecordModifierExpr (expr))      -> return wf_RecordModifierExpr (i,expr,exptp),
        (is_AS`ApplyExpr (expr))               -> return wf_ApplyExpr(i,expr,exptp),
        (is_AS`FieldSelectExpr(expr))          -> return wf_FieldSelectExpr(i,expr,exptp),
        (is_AS`LambdaExpr(expr))               -> return wf_LambdaExpr(i,expr,exptp),
        (is_AS`IsExpr (expr))                  -> return wf_IsExpr (i,expr,exptp),
        (is_AS`NarrowExpr(expr))               -> return wf_NarrowExpr (i,expr,exptp),
        (is_AS`BoolLit(expr)),
        (is_AS`RealLit(expr)),
        (is_AS`NumLit(expr)),
        (is_AS`CharLit(expr)),
        (is_AS`TextLit(expr)),
        (is_AS`QuoteLit(expr)),
        (is_AS`NilLit(expr))                   -> return wf_Literal(i,expr,exptp),
        --(is_AS`Name(expr))                     -> return wf_Name(i,expr),
        (is_AS`OldName(expr))                  -> return wf_OldName(i,expr),
        (is_AS`UndefinedExpr(expr))            -> (CI`SetTypeInfo(expr.cid, exptp);
                                                   return mk_(true, exptp)),
        (is_AS`IotaExpr(expr))                 -> return wf_IotaExpr(i,expr,exptp),
        (is_AS`FctTypeInstExpr(expr))          -> return wf_FctTypeInstExpr(i,expr,exptp),
        (is_AS`BracketedExpr(expr))            -> return wf_BracketedExpr(i,expr,exptp),
        (is_AS`Macro(expr))                    -> return wf_Macro(i,expr,exptp),
#ifdef VDMPP
        (is_AS`NewExpr(expr))                  -> return wf_NewExpr(i, expr, exptp),
        (is_AS`ThreadIdExpr(expr))             -> return wf_ThreadIdExpr(i,expr,exptp),
        (is_AS`SelfExpr(expr))                 -> return wf_SelfExpr(i,expr,exptp),
        (is_AS`SameClassExpr(expr)),
        (is_AS`SameBaseClassExpr(expr))        -> return wf_SameClassExpr(i, expr, exptp),
        (is_AS`IsOfClassExpr(expr)),
        (is_AS`IsOfBaseClassExpr(expr))        -> return wf_IsOfClassExpr(i, expr,exptp),
        (is_AS`ActExpr(expr))                  -> return wf_ActExpr (i, expr,exptp),  
        (is_AS`FinExpr(expr))                  -> return wf_FinExpr (i, expr,exptp),  
        (is_AS`ActiveExpr(expr))               -> return wf_ActiveExpr (i, expr,exptp),  
        (is_AS`WaitingExpr(expr))              -> return wf_WaitingExpr (i, expr,exptp),  
        (is_AS`ReqExpr(expr))                  -> return wf_ReqExpr (i, expr,exptp),  
#ifdef VICE
        (is_AS`CurTimeExpr(expr))              -> return wf_CurTimeExpr(i,expr,exptp),
#endif VICE
#endif VDMPP
        others -> error
      end;

\end{vdm_al}

\subsection{Local Binding Expressions}

\begin{vdm_al}
wf_DefExpr : TYPE`Ind * AS`DefExpr * REP`TypeRep ==> bool * REP`TypeRep 
wf_DefExpr (i, mk_AS`DefExpr(defs, in_e, cid), exptp) ==
 (dcl used : set of AS`Name := {};
  dcl reswf : bool := true;

  ENV`EnterScope({|->});
  for mk_(patbind,expr) in defs do
    --def mk_(wf_expr,tp) = wf_Expr(i,expr,mk_REP`AllTypeRep());
    def mk_(wf_expr,tp) = wf_Expr(i,expr,PAT`PatternBind2TypeRep(patbind));
  --  EXTENDED POS CHECK:
  --  Instead of REP`AllTypeRep one could look up the type of patbind and use this.
        mk_(wf_def,bd) = PAT`wf_PatternBind(i,patbind,tp)
    in
     (if wf_def <> true
      -----------------------------------
      -- Error message #111
      -- Pattern in Def-Expr cannot match
      -----------------------------------
      then (ERR`GenErr(in_e, <ERROR>,111,[]);
            reswf := false);
      let overlap = dom bd inter used
      in
        for all nm in set overlap do
          --------------------------------
          -- Error message #112
          -- "%1" is redefined in Def-Expr
          --------------------------------
          ERR`GenErr(nm, <WARNING>,112,[ENV`PrintName(nm)]);
      reswf := reswf and wf_expr;
      used := used union dom bd;
      ENV`UpdateScope(bd)); -- for loop ends here
  def mk_(wf_e,etp) = wf_Expr(i,in_e,exptp)
  in
   (ENV`LeaveScope();
    CI`SetTypeInfo(cid, etp);
    return mk_(reswf and wf_e,etp));
 );

wf_LetExpr : TYPE`Ind * AS`LetExpr * REP`TypeRep ==> bool * REP`TypeRep --OK rettet
wf_LetExpr (i, mk_AS`LetExpr(defs, in_e, cid), exptp) ==
 (ENV`EnterScope({|->});
  def reswf : bool = wf_LocalDefs(i,defs);
      mk_(wf_e, etp) = wf_Expr (i, in_e, exptp)
  in
   (ENV`LeaveScope();
    CI`SetTypeInfo(cid, etp);
    return mk_(reswf and wf_e, etp));
 );

wf_LocalDefs: TYPE`Ind * seq of AS`LocalDef ==> bool 
wf_LocalDefs(i,defs) ==
  def mk_(wf,bd) = ENV`ExtractPatterns(i,defs);
      nbd = { nm |-> mk_(bd(nm).#1, 1) | nm in set dom bd }
  in
   (--dcl reswf : bool := true;
    dcl reswf : bool := wf;
    for all stid in set ENV`UsedStateIds(dom bd) do
      ------------------------------------------------------
      -- Error message #18
      -- The scope of the state component "%1" is now hidden
      ------------------------------------------------------
      ERR`GenErr(stid,<WARNING>,18,[ENV`PrintName(stid)]);

    --ENV`EnterScope({|->});
    for val in defs do
      cases true:
        (is_AS`ValueDef(val))     -> def mk_(wf_def, realbd) = ENV`wf_ValueDef(i,val)
                                     in
                                      (reswf := wf_def and reswf;
                                       ENV`UpdateScope (realbd)),
        (is_AS`ExplFnDef(val))    -> let nm = val.nm,
                                         nm_s = {nm, AUX`Pre(nm), AUX`Post(nm)}
                                     in
                                      (ENV`UpdateScope (nm_s <: nbd);
                                       reswf := DEF`wf_ExplFunction(i,val) and reswf),
        (is_AS`ImplFnDef(val))    -> let nm = val.nm,
                                         nm_s = {nm, AUX`Pre(nm), AUX`Post(nm)}
                                     in
                                      (reswf := DEF`wf_ImplFunction(i,val) and reswf;
                                       ENV`UpdateScope (nm_s <: nbd)),
        (is_AS`ExtExplFnDef(val)) -> let nm = val.nm,
                                         nm_s = {nm, AUX`Pre(nm), AUX`Post(nm)}
                                     in
                                      (ENV`UpdateScope (nm_s <: nbd);
                                       reswf := DEF`wf_ExtExplFunction(i,val) and reswf)
      end; -- for loop ends here
    return reswf;
   );

wf_LetBeSTExpr : TYPE`Ind * AS`LetBeSTExpr * REP`TypeRep ==> bool * REP`TypeRep
wf_LetBeSTExpr (i, vLetBeSTExpr, exptp) ==
  def mk_AS`LetBeSTExpr(bind, st_e, in_e, cid) = vLetBeSTExpr;
      mk_(wf_sb, bd) = PAT`wf_MultiBindList(i, bind, true);
      btp = mk_REP`BooleanTypeRep()
  in
   (dcl reswf : bool := wf_sb = true;
    if wf_sb = nil or not wf_sb
      --------------------------------------
      -- Error message #113
      -- Pattern in Let-Be-Expr cannot match
      --------------------------------------
    then ERR`GenErr(vLetBeSTExpr, <ERROR>,113,[]);
    ENV`EnterScope (bd);
    if st_e <> nil
    then
      def mk_(wf_st, sttp) = wf_Expr (i, st_e, btp);
          stcomp = TYPE`IsCompatible(i, sttp, mk_REP`BooleanTypeRep())
      in
       (if not stcomp
        then
          -------------------------------------------------
          -- Error message #231
          -- Predicate for "%1" is not a boolean expression
          -------------------------------------------------
          ERR`GenErr(st_e, <ERROR>,231,["Let-Be-Stmt"]);
        reswf := reswf and wf_st and stcomp);
    def mk_(wf_e, etp)   = wf_Expr (i, in_e, exptp);
    in 
     (reswf := reswf and wf_e;
      ENV`LeaveScope();
      CI`SetTypeInfo(cid,etp);
      return mk_(reswf, etp));
   );
\end{vdm_al}

\subsection{Conditional Expressions}

\begin{vdm_al}
  wf_IfExpr : TYPE`Ind * AS`IfExpr * REP`TypeRep ==> bool * REP`TypeRep 
  wf_IfExpr (i, mk_AS`IfExpr(test,cons,elsif,altn,cid),tp) ==
    def btp = mk_REP`BooleanTypeRep();
        -- if
        mk_(wf_test, test_tp) = wf_Expr (i, test,btp);
        tcomp = TYPE`IsCompatible (i, test_tp, btp);
    in
     (dcl reswf : bool := wf_test and tcomp;
      if not tcomp
      then
        -------------------------------------------------
        -- Error message #115
        -- Test expression in "%1" is not of boolean type
        -------------------------------------------------
        ERR`GenErr(test,<ERROR>,115,["If-Expr"]);

      -- then
      def mk_(wf_cons, cons_tp) = wf_Expr (i, cons,tp);
          ccomp = TYPE`IsCompatible(<POS>,cons_tp,tp);
      in
       (dcl m_tp : REP`TypeRep := cons_tp;
        if not ccomp
        then
          -----------------------------------
          -- Error message #116
          -- then-part is not of correct type
          -----------------------------------
          ERR`GenErr(cons,<ERROR>,116,[]);
        reswf := reswf and wf_cons and ccomp;

        -- elseif
        if elsif <> []
        then
          def mk_(wf_e, etp) = wf_ElseIfExprs(i, elsif,tp);
          in
           (reswf := reswf and wf_e;
            m_tp := AUX`MergeTypes (m_tp, etp));

        -- else
        def mk_(wf_altn, altn_tp) = wf_Expr (i, altn,tp);
            ecomp = TYPE`IsCompatible(<POS>,altn_tp,tp)
        in 
         (if not ecomp
          then
            -----------------------------------
            -- Error message #117
            -- else-part is not of correct type
            -----------------------------------
            ERR`GenErr(altn,<ERROR>,117,[]);
          reswf := reswf and wf_altn and ecomp;
          m_tp := AUX`MergeTypes (m_tp, altn_tp));
 
        CI`SetTypeInfo(cid,m_tp);
        return mk_(reswf, m_tp);
       );
     );

wf_ElseIfExprs : TYPE`Ind * seq1 of AS`ElseifExpr * REP`TypeRep ==> bool * REP`TypeRep 
wf_ElseIfExprs (i, else_l,tp) ==
  def mk_(wf_e,etp) = wf_ElseIfExpr(i,hd else_l,tp)
  in
    if len else_l = 1
    then return mk_(wf_e,etp)
    else def mk_(wf_rest,restp) = wf_ElseIfExprs(i,tl else_l,tp)
         in
           return mk_(wf_rest and wf_e, AUX`MergeTypes(etp,restp));
               
wf_ElseIfExpr : TYPE`Ind * AS`ElseifExpr * REP`TypeRep ==> bool * REP`TypeRep 
wf_ElseIfExpr (i, mk_AS`ElseifExpr(test, cons, -),tp) ==
  def btp = mk_REP`BooleanTypeRep();
      mk_(wf_t, ttp) = wf_Expr(i, test,btp);
      mk_(wf_c, ctp) = wf_Expr(i, cons,tp);
      ecomp = TYPE`IsCompatible(i, ttp, btp);
      ccomp = TYPE`IsCompatible(<POS>,ctp,tp)
  in
   (if not ecomp then
      -------------------------------------------------
      -- Error message #115
      -- Test expression in "%1" is not of boolean type
      -------------------------------------------------
      ERR`GenErr (test,<ERROR>,115,["Else-If-Expr"]);
    if not ccomp then
      -------------------------------------
      -- Error message #118
      -- elseif-part is not of correct type
      -------------------------------------
      ERR`GenErr(cons,<ERROR>,118,[]);
    return mk_(wf_t and wf_c and ecomp and ccomp, ctp);
   );

wf_CasesExpr : TYPE`Ind * AS`CasesExpr * REP`TypeRep ==> bool * REP`TypeRep 
wf_CasesExpr (i, mk_AS`CasesExpr(sel, altns, oth, cid),exptp) ==
  def mk_(wf_sel, seltp) = wf_Expr (i, sel,mk_REP`AllTypeRep())
  in
   (dcl reswf : bool := true,
        restp : [REP`TypeRep] := nil;
    for altn in altns do
      def mk_AS`CaseAltn(m,b,-) = altn;
          mk_(wf,tp) = wf_CaseAltn (i, m, b, seltp, exptp)
      in
       (reswf := reswf and wf;

        restp := if restp = nil
                 then tp
                 else if tp = nil
                      then restp
                      else AUX`MergeTypes (restp, tp)); -- for loop ends here

    if (oth <> nil)
    then
      def mk_(wf, tp) = wf_Expr (i, oth, exptp)
      in
       (if not TYPE`IsCompatible(<POS>,tp,exptp)
          ---------------------------------------
          -- Error message #119
          -- others branch is not of correct type
          ---------------------------------------
        then (ERR`GenErr(oth,<ERROR>,119,[]);
              reswf := false);
    reswf := reswf and wf;
    restp := if restp = nil
             then tp
             else AUX`MergeTypes (restp, tp));

    if restp = nil
    then restp := mk_REP`AllTypeRep();
    CI`SetTypeInfo(cid,restp);
    return mk_(wf_sel and reswf, restp);
   );

wf_CaseAltn : TYPE`Ind * seq1 of AS`Pattern * AS`Expr * REP`TypeRep * REP`TypeRep ==> [bool] * [REP`TypeRep]
wf_CaseAltn (i, m_l, b, tp,exptp) ==
 --(dcl resbd:map AS`Name to REP`TypeRep := {|->};
 (dcl resbd:map AS`Name to (REP`TypeRep * nat1) := {|->};
  dcl reswf:bool := true;
  dcl onewf:bool := false;

  for m in m_l do
    def mk_(wf_p, bd) = PAT`wf_Pattern(i, m, tp) 
    in
     (onewf := onewf or (wf_p = true);
      reswf := reswf and (wf_p = true);
      --resbd := resbd ++ bd ++ {id |-> AUX`MergeTypes(resbd(id),bd(id)) | id in set dom resbd inter dom bd};
      resbd := resbd ++ bd ++ {id |->
            mk_(AUX`MergeTypes(resbd(id).#1,bd(id).#1), resbd(id).#2 + bd(id).#2) | id in set dom resbd inter dom bd};

      ENV`EnterScope (bd);
      def mk_(wf_s, -) = wf_Expr (i, b,exptp)
      in reswf := reswf and wf_s;
      ENV`LeaveScope();
     );
  ENV`EnterScope (resbd);
  def mk_(wf_s, stp) = wf_Expr (i, b,exptp) 
  in
   (ENV`LeaveScope();
    if not TYPE`IsCompatible(<POS>,stp,exptp)
      ------------------------------------------
      -- Error message #120
      -- Case alternative is not of correct type
      ------------------------------------------
    then (ERR`GenErr(b, <ERROR>,120,[]);
          return mk_(false,exptp));
    if onewf = true
    then return mk_(reswf and wf_s, stp)
    elseif i = <POS> 
      --------------------------
      -- Error message #121
      -- Pattern can never match
      --------------------------
    then ERR`GenErr (m_l(1),<ERROR>,121,[]);
    if i = <DEF> and TYPE`IsCompatible(i,stp,exptp)
    then return mk_(false, stp)
    else return mk_(false, nil))
 );
\end{vdm_al}

\subsection{Unary Expressions}

\begin{vdm_al}

  wf_PrefixExpr : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
  wf_PrefixExpr (i, unexpr, exptp) ==
    let mk_AS`PrefixExpr (op,-,cid) = unexpr
    in
     (dcl res : bool * REP`TypeRep;
      cases op :
        <NUMPLUS>            -> res := wf_UNARYNUMPLUS (i,unexpr,exptp),
        <NUMMINUS>           -> res := wf_UNARYNUMMINUS (i,unexpr,exptp),
        <NUMABS>             -> res := wf_NUMABS (i,unexpr,exptp),
        <FLOOR>              -> res := wf_FLOOR (i,unexpr,exptp),
        <NOT>                -> res := wf_NOT (i,unexpr,exptp),
        <SETCARD>            -> res := wf_SETCARD (i,unexpr,exptp),
        <SETDISTRUNION>      -> res := wf_SETDISTRUNION (i,unexpr,exptp),
        <SETDISTRINTERSECT>  -> res := wf_SETDISTRINTERSECT (i,unexpr,exptp),
        <SETPOWER>           -> res := wf_SETPOWER (i,unexpr,exptp),
        <SEQLEN>             -> res := wf_SEQLEN (i,unexpr,exptp),
        <SEQDISTRCONC>       -> res := wf_SEQDISTRCONC (i,unexpr,exptp),
        <SEQELEMS>           -> res := wf_SEQELEMS (i,unexpr,exptp),
        <SEQINDICES>         -> res := wf_SEQINDICES (i,unexpr,exptp),
        <SEQTAIL>            -> res := wf_SEQTAIL (i,unexpr,exptp),
        <SEQHEAD>            -> res := wf_SEQHEAD (i,unexpr,exptp),
        <SEQREVERSE>         -> res := wf_SEQREVERSE (i,unexpr,exptp),
        <MAPDOM>             -> res := wf_MAPDOM (i,unexpr,exptp),
        <MAPRNG>             -> res := wf_MAPRNG (i,unexpr,exptp),
        <MAPDISTRMERGE>      -> res := wf_MAPDISTRMERGE (i,unexpr,exptp),
        <MAPINVERSE>         -> res := wf_MAPINVERSE (i,unexpr,exptp),
        others -> error
      end;
      def mk_(-, petp) = res
      in CI`SetTypeInfo(cid,petp);
      return res;
     );

wf_UNARYNUMPLUS : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
wf_UNARYNUMPLUS (i, unexpr, exptp) ==
  def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
      ExpectedRhsType = mk_REP`NumericTypeRep(<REAL>);
      intertp = AUX`IntersectTypeReps(ExpectedRhsType,exptp);
      mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
  in
    if TYPE`IsCompatible(i, argtp, ExpectedRhsType)
    then return mk_(wf_arg, AUX`ExtractNumericType(argtp))
    else
      -----------------------------------------
      -- Error message #122
      -- Rhs of unary '+' is not a numeric type
      -----------------------------------------
     (ERR`GenErr(unexpr, <ERROR>,122,[]);
      return mk_(false, ExpectedRhsType)); 

    wf_UNARYNUMMINUS : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_UNARYNUMMINUS (i, unexpr, exptp) ==
      def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
          ExpectedRhsType = mk_REP`NumericTypeRep(<REAL>);
          intertp = AUX`IntersectTypeReps(ExpectedRhsType,exptp);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
        if TYPE`IsCompatible(i, argtp, ExpectedRhsType)
        then
          def restp = AUX`ExtractNumericType(argtp)
          in
            if restp = mk_REP`NumericTypeRep(<NAT>) or restp = mk_REP`NumericTypeRep(<NATONE>)
            then return mk_(wf_arg, mk_REP`NumericTypeRep(<INTEGER>))
            else return mk_(wf_arg, restp)
        else
            -----------------------------------------
            -- Error message #123
            -- Rhs of unary '-' is not a numeric type
            -----------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,123,[]);
            return mk_(false, ExpectedRhsType)); 

    wf_NUMABS : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_NUMABS (i, unexpr, exptp) ==
      def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
          ExpectedRhsType = mk_REP`NumericTypeRep(<REAL>);
          intertp = AUX`IntersectTypeReps(ExpectedRhsType,exptp);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
        if TYPE`IsCompatible(i, argtp, ExpectedRhsType)
        then
          def restp = AUX`ExtractNumericType(argtp)
          in
            if restp = mk_REP`NumericTypeRep(<INTEGER>)
            then return mk_(wf_arg, mk_REP`NumericTypeRep(<NAT>))
            else return mk_(wf_arg, restp)
        else
            ------------------------------------------
            -- Error message #124
            -- Argument of 'abs' is not a numeric type
            ------------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,124,[]);
            return mk_(false,ExpectedRhsType)); 

    wf_FLOOR : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_FLOOR (i, unexpr, exptp) ==
      def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
          ExpectedRhsType = mk_REP`NumericTypeRep(<REAL>);
          intertp = AUX`IntersectTypeReps(ExpectedRhsType,exptp);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
        if TYPE`IsCompatible(i, argtp, ExpectedRhsType)
        then
          def restp = AUX`ExtractNumericType(argtp)
          in
            if restp = mk_REP`NumericTypeRep(<NAT>) or restp = mk_REP`NumericTypeRep(<NATONE>)
            then return mk_(wf_arg, restp)
            else return mk_(wf_arg, mk_REP`NumericTypeRep(<INTEGER>))
        else
            --------------------------------------------
            -- Error message #125
            -- Argument to 'floor' is not a numeric type
            --------------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,125,[]);
            return mk_(false,mk_REP`NumericTypeRep(<INTEGER>))); 

    wf_NOT : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_NOT (i, unexpr,exptp) ==
      def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
          ExpectedRhsType = mk_REP`BooleanTypeRep();
          intertp = AUX`IntersectTypeReps(ExpectedRhsType,exptp);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
        if TYPE`IsCompatible(i, argtp, ExpectedRhsType)
        then
          return mk_(wf_arg, ExpectedRhsType)
        else
            ------------------------------------------
            -- Error message #126
            -- Argument to 'not' is not a boolean type
            ------------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,126,[]);
            return mk_(false,ExpectedRhsType)); 

    wf_SETCARD : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_SETCARD (i, unexpr,-) ==
      def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
          ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,ExpectedRhsType)
      in
        if TYPE`IsCompatible(i, argtp, ExpectedRhsType)
        then
          if TYPE`IsCompatible(<DEF>, argtp, AUX`RemoveEmptySetType(ExpectedRhsType))
          then return mk_(wf_arg, mk_REP`NumericTypeRep(<NATONE>))
          else return mk_(wf_arg, mk_REP`NumericTypeRep(<NAT>))
        else
            ---------------------------------------
            -- Error message #127
            -- Argument to 'card' is not a set type
            ---------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,127,[]);
            return mk_(false,mk_REP`NumericTypeRep(<NAT>))); 

  wf_SETDISTRUNION : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep  --OK
  wf_SETDISTRUNION (i, unexpr, exptp) ==
    def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
        ExpectedRhsType = mk_REP`UnionTypeRep(
                              {mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                               mk_REP`SetTypeRep(mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                                      mk_REP`SetTypeRep(mk_REP`AllTypeRep())}))});
        ExpRes = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                      mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
    in
     (dcl rhsexptp : REP`TypeRep;
      if TYPE`IsCompatible (i, exptp, ExpRes) 
      then rhsexptp := mk_REP`UnionTypeRep({mk_REP`SetTypeRep(
                                                mk_REP`UnionTypeRep({AUX`ExtractSetType(exptp),
                                                                     mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())})),
                                               mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())})
      else rhsexptp := ExpectedRhsType;
      def intertp = AUX`IntersectTypeReps(ExpectedRhsType,rhsexptp);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
        if TYPE`IsCompatible(i, argtp, ExpectedRhsType)
        then def elemtp = AUX`UnmaskSetType(i,AUX`ExtractSetType(argtp))
             in
               if elemtp = nil
                     ---------------------------------------------
                     -- Error message #128
                     -- The 'dunion' will always give an empty set
                     ---------------------------------------------
               then (ERR`GenErr(unexpr, <WARNING>,128,[]);
                     return mk_(wf_arg,mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())))
               else def realtp = AUX`ExtractSetType(elemtp)
                    in
                    if is_REP`UnionTypeRep(realtp)
                    then let mk_REP`UnionTypeRep(tp_s) = realtp
                         in
                           return mk_(wf_arg,AUX`SetTypeUnion(tp_s))
                    else return mk_(wf_arg,realtp) 
        else
            ------------------------------------------------
            -- Error message #129
            -- Argument of 'dunion' is not a set of set type
            ------------------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,129,[]);
            return mk_(false, ExpRes))
     ); 


  wf_SETDISTRINTERSECT : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
  wf_SETDISTRINTERSECT (i, unexpr, exptp) ==
    def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
        ExpectedRhsType = mk_REP`SetTypeRep(mk_REP`UnionTypeRep({
                                                 mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SetTypeRep(mk_REP`AllTypeRep())}));
        ExpRes = mk_REP`UnionTypeRep({ mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                         mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
    in
     (dcl rhsexptp : REP`TypeRep := ExpectedRhsType;
      if TYPE`IsCompatible (i, exptp, ExpRes)
      then rhsexptp := mk_REP`SetTypeRep(mk_REP`UnionTypeRep({AUX`ExtractSetType(exptp),
                                                              mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())}));
      def intertp = AUX`IntersectTypeReps(ExpectedRhsType,rhsexptp);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
        if argtp = mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())
              ------------------------------------------------
              -- Error message #130
              -- An empty set is given as argument to 'dinter'
              ------------------------------------------------
        then (ERR`GenErr(unexpr, <ERROR>,130,[]);
              return mk_(false, ExpRes))
        elseif TYPE`IsCompatible(i, argtp, ExpectedRhsType)
        then def elemtp = AUX`UnmaskSetType(i, AUX`ExtractSetType(argtp))
             in
               if elemtp = nil
                     ------------------------------------------------
                     -- Error message #130
                     -- An empty set is given as argument to 'dinter'
                     ------------------------------------------------
               then (ERR`GenErr(unexpr, <ERROR>,130,[]);
                     return mk_(false, ExpRes))
               else def realtp = AUX`ExtractSetType(elemtp)
                    in
                    if is_REP`UnionTypeRep(realtp) and (i = <DEF>)
                    then let mk_REP`UnionTypeRep(tp_s) = realtp
                         in
                           def restp = AUX`SetTypeInter(tp_s)
                           in
                            (if restp = mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())
                                  -----------------------------------------
                                  -- Error message #131
                                  -- Result of 'dinter' can be an empty set
                                  -----------------------------------------
                             then ERR`GenErr(unexpr, <WARNING>,131,[]);
                             return mk_(wf_arg,restp))
                    else return mk_(wf_arg,realtp) 
        else 
            ------------------------------------------------
            -- Error message #132
            -- Argument of 'dinter' is not a set of set type
            ------------------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,132,[]);
            return mk_(false, ExpRes))
     ); 

  wf_SETPOWER : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
  wf_SETPOWER (i, unexpr, exptp) ==
    def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
        ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
        ExpectedType    = mk_REP`SetTypeRep(mk_REP`AllTypeRep());
        est = mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep());
    in
     (dcl rhsexptp : REP`TypeRep := ExpectedRhsType;
      if TYPE`IsCompatible(i,exptp,ExpectedType)
      then rhsexptp := AUX`UnmaskSetType(i,AUX`ExtractSetType(exptp));
      def intertp = AUX`IntersectTypeReps(ExpectedRhsType,rhsexptp);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
        if TYPE`IsCompatible(i, argtp, ExpectedRhsType) then
          def r1tp = AUX`ExtractSetType(argtp) in
          let restp =
            cases r1tp:
              (est) -> est,
              mk_REP`UnionTypeRep(utp) -> mk_REP`UnionTypeRep(utp union {est}),
              others -> mk_REP`UnionTypeRep ({r1tp, est})
            end in
          return mk_(wf_arg, mk_REP`SetTypeRep(restp))
        else
            ----------------------------------------
            -- Error message #133
            -- Argument to 'power' is not a set type
            ----------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,133,[]);
            return mk_(false, mk_REP`SetTypeRep(mk_REP`SetTypeRep(
                              mk_REP`AllTypeRep())))); 
     );

    wf_SEQLEN : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep
    wf_SEQLEN (i, unexpr,-) ==
      def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
          ExpectedRhsType    = mk_REP`UnionTypeRep(
                                {mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
                                 mk_REP`SeqTypeRep(mk_REP`AllTypeRep())});
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,ExpectedRhsType)
      in
        if TYPE`IsCompatible(i,argtp, ExpectedRhsType)
        then
          if TYPE`IsCompatible(<DEF>, argtp, AUX`RemoveEmptySeqType(ExpectedRhsType))
          then return mk_(wf_arg, mk_REP`NumericTypeRep(<NATONE>))
          else return mk_(wf_arg, mk_REP`NumericTypeRep(<NAT>))
        else
            -------------------------------------------
            -- Error message #134
            -- Argument of 'len' is not a sequence type
            -------------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,134,[]);
            return mk_(false,mk_REP`NumericTypeRep(<NAT>))); 

    wf_SEQDISTRCONC : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK --??
    wf_SEQDISTRCONC (i, unexpr, exptp) ==
    ( def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
          ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SeqTypeRep(
                                                   mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
                                                                        mk_REP`SeqTypeRep(mk_REP`AllTypeRep())}))});
          intertp = AUX`IntersectTypeReps(ExpectedRhsType,exptp);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
        if TYPE`IsCompatible(i, argtp, ExpectedRhsType)
        then def elemtp = AUX`UnmaskSeqType(i, AUX`ExtractSeqType(argtp))
             in
               if elemtp = nil
               then (--GenOLDErr(<WARNING>,"This distributed sequence "^
                     --                 "concatenation will always yield "^
                     --                 "an empty sequence");
                     return mk_(wf_arg, mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep())))
               else def realtp = AUX`ExtractSeqType(elemtp)
                    in
                    if is_REP`UnionTypeRep(realtp)
                    then let mk_REP`UnionTypeRep(tp_s) = realtp
                         in
                           let restp = AUX`SeqTypeConc(tp_s)
                           in
                            (if restp = mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()) and (i = <DEF>)
                                  --------------------------------------------
                                  -- Error message #135
                                  -- Result of 'conc' can be an empty sequence
                                  --------------------------------------------
                             then ERR`GenErr(unexpr, <WARNING>,135,[]);
                             return mk_(wf_arg,restp))
                    else return mk_(wf_arg,realtp) 
        else
            ----------------------------------------------------
            -- Error message #136
            -- Argument of 'conc' is not a sequence of sequences
            ----------------------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,136,[]);
            return mk_(false,mk_REP`SeqTypeRep(mk_REP`AllTypeRep())))
    ); 

  wf_SEQELEMS : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK --??
  wf_SEQELEMS (i, unexpr, exptp) ==
    def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
          ExpectedType    = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
          ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SeqTypeRep(mk_REP`AllTypeRep())});
    in
     (dcl elemtp : REP`TypeRep := mk_REP`AllTypeRep();
      if TYPE`IsCompatible(i, exptp, ExpectedType)
      then elemtp := AUX`UnmaskSetType(i,AUX`ExtractSetType(exptp));
      def expseqtp = mk_REP`SeqTypeRep(elemtp);
          intertp = AUX`IntersectTypeReps(ExpectedRhsType,expseqtp);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
        if TYPE`IsCompatible(i, argtp, ExpectedRhsType) then
          def r1tp = AUX`ExtractSeqType(argtp) in
            cases r1tp:
              mk_REP`EmptySeqTypeRep(s) -> return mk_(wf_arg, mk_REP`EmptySetTypeRep(s)),
              mk_REP`SeqTypeRep(s) -> return mk_(wf_arg, mk_REP`SetTypeRep(s)),
              mk_REP`UnionTypeRep(u) -> 
                let restp = {mk_REP`SetTypeRep(utp) | mk_REP`SeqTypeRep(utp) in set u} union
                            {mk_REP`EmptySetTypeRep(utp) | mk_REP`EmptySeqTypeRep(utp) in set u} in
                  return mk_(wf_arg, mk_REP`UnionTypeRep(restp))
            end
        else
            ---------------------------------------------
            -- Error message #137
            -- Argument of 'elems' is not a sequence type
            ---------------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,137,[]);
            return mk_(false,mk_REP`SetTypeRep(mk_REP`AllTypeRep())));
     );

    wf_SEQINDICES : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK --??
    wf_SEQINDICES (i, unexpr, -) ==
      def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
          ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SeqTypeRep(mk_REP`AllTypeRep())});
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,ExpectedRhsType)
      in
        if TYPE`IsCompatible(i, argtp, ExpectedRhsType) then
          if argtp = mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep())
          then return mk_(wf_arg, mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()))
          else return mk_(wf_arg, mk_REP`SetTypeRep(mk_REP`NumericTypeRep(<NATONE>)))
        else
            --------------------------------------------
            -- Error message #138
            -- Argument of 'inds' is not a sequence type
            --------------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,138,[]);
            return mk_(false, mk_REP`SetTypeRep(mk_REP`NumericTypeRep(<NATONE>)))); 

    wf_SEQHEAD : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK --??
    wf_SEQHEAD (i, unexpr, exptp) ==
     (dcl reswf : bool := true;
     
      def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
          ExpectedRhsType    = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
                                                    mk_REP`SeqTypeRep(mk_REP`AllTypeRep())});
          EmptySeq           = mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep());
          expseqtp           = mk_REP`SeqTypeRep(exptp);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,expseqtp)
      in
        if TYPE`IsCompatible(i, argtp, ExpectedRhsType) then
          def restp = AUX`ExtractSeqType(argtp) in
            cases restp :
              (EmptySeq) ->
                  ----------------------------------------
                  -- Error message #139
                  -- Argument of 'hd' is an empty sequence
                  ----------------------------------------
                ( ERR`GenErr(unexpr, <ERROR>,139,[]);
                  return mk_(false, mk_REP`AllTypeRep())),
              mk_REP`SeqTypeRep(s) ->
                return mk_(wf_arg,s),
              mk_REP`UnionTypeRep(utps) ->
                ( if EmptySeq in set utps and i = <DEF> then
                      --------------------------------------------
                      -- Error message #140
                      -- Argument of 'hd' can be an empty sequence
                      --------------------------------------------
                    ( ERR`GenErr(unexpr, <ERROR>,140,[]);
                      reswf := false);
                  let r1tp  = {utp|mk_REP`SeqTypeRep(utp) in set utps} 
                              in
                  let r2tp  = AUX`MergeNumericTypes(r1tp) in
                  let restp = cases r2tp:
                                {} -> undefined,
                                {e} -> e,
                                others -> mk_REP`UnionTypeRep(r2tp)
                              end in
                  return mk_(wf_arg and reswf, restp))
            end
        else
            ------------------------------------------
            -- Error message #141
            -- Argument of 'hd' is not a sequence type
            ------------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,141,[]);
            return mk_(false, mk_REP`AllTypeRep()))); 

    wf_SEQTAIL : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK --??
    wf_SEQTAIL (i, unexpr, exptp) ==
      def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
          ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SeqTypeRep(mk_REP`AllTypeRep())});
          intertp = AUX`IntersectTypeReps(ExpectedRhsType,exptp);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
        if TYPE`IsCompatible(i, argtp, ExpectedRhsType) then
          def restp = AUX`ExtractSeqType(argtp) in
            cases restp :
              mk_REP`EmptySeqTypeRep(-) ->
                    ----------------------------------------
                    -- Error message #142
                    -- Argument of 'tl' is an empty sequence
                    ----------------------------------------
                  ( ERR`GenErr(unexpr, <ERROR>,142,[]);
                    return mk_(false, ExpectedRhsType)),
              mk_REP`SeqTypeRep(-) ->
                return mk_(wf_arg, mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(restp.elemtp), restp})),
              mk_REP`UnionTypeRep(utps) ->
                let restp = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep())} union utps)
                in
                ( if (exists t in set utps & is_REP`SeqTypeRep(t) or is_REP`EmptySeqTypeRep(t)) and i = <DEF>
                  then
                      --------------------------------------------
                      -- Error message #143
                      -- Argument of 'tl' can be an empty sequence
                      --------------------------------------------
                    ( ERR`GenErr(unexpr, <ERROR>,143,[]);
                      return mk_(false, restp))
                  else return mk_(wf_arg, restp))
            end
        else
            ------------------------------------------
            -- Error message #144
            -- Argument of 'tl' is not a sequence type
            ------------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,144,[]);
            return mk_(false, ExpectedRhsType)); 

    wf_SEQREVERSE : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep
    wf_SEQREVERSE (i, unexpr, exptp) ==
      def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
          ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SeqTypeRep(mk_REP`AllTypeRep())});
          intertp = AUX`IntersectTypeReps(ExpectedRhsType,exptp);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
          if TYPE`IsCompatible(i, argtp, ExpectedRhsType)
          then return mk_(wf_arg, AUX`ExtractSeqType(argtp))
          else
            ------------------------------------------
            -- Error message #437
            -- Argument of 'reverse' is not a sequence type
            ------------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,437,[]);
            return mk_(false, ExpectedRhsType)); 

  wf_MAPDOM : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK --??
  wf_MAPDOM (i, unexpr, exptp) ==
    def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
        ExpectedDomType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
    in
     (dcl domtp : REP`TypeRep := mk_REP`AllTypeRep();
      if TYPE`IsCompatible(i,exptp,ExpectedDomType)
      then domtp := AUX`UnmaskSetType(i,AUX`ExtractSetType(exptp));
      def ExpectedType    = mk_REP`UnionTypeRep({mk_REP`GeneralMapTypeRep(domtp, mk_REP`AllTypeRep()),
                                                 mk_REP`EmptyMapTypeRep(domtp, mk_REP`AllTypeRep())});
          ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                                 mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())});
          intertp = AUX`IntersectTypeReps(ExpectedRhsType, ExpectedType);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
        if TYPE`IsCompatible(i,argtp, ExpectedRhsType)
        then
          def r1tp = AUX`ExtractMapType(argtp)
          in
            cases r1tp :
              nil                               -> return mk_(wf_arg,mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())),
              mk_REP`EmptyMapTypeRep(Dom,-)     -> return mk_(wf_arg,mk_REP`EmptySetTypeRep(Dom)),
              mk_REP`GeneralMapTypeRep(Dom,-),
              mk_REP`InjectiveMapTypeRep(Dom,-) -> return mk_(wf_arg,mk_REP`SetTypeRep(Dom)),
              mk_REP`UnionTypeRep(utps) ->
                let r2tp = {domtp | mk_REP`GeneralMapTypeRep(domtp,-) in set utps} union
                           {domtp | mk_REP`InjectiveMapTypeRep(domtp,-) in set utps},
                    r3tp = AUX`MergeNumericTypes(r2tp),
                    r4tp = cases r3tp:
                             {e} -> if exists tp in set utps & is_REP`EmptyMapTypeRep(tp)
                                    then mk_REP`UnionTypeRep ({mk_REP`EmptySetTypeRep(e), mk_REP`SetTypeRep(e)})
                                    else mk_REP`SetTypeRep(e),
                             others -> if exists tp in set utps & is_REP`EmptyMapTypeRep(tp)
                                       then mk_REP`UnionTypeRep ({mk_REP`EmptySetTypeRep(mk_REP`UnionTypeRep(r3tp)),
                                                                  mk_REP`SetTypeRep(mk_REP`UnionTypeRep(r3tp))})
                                       else mk_REP`SetTypeRep(mk_REP`UnionTypeRep(r3tp))
                           end
                in
                return mk_(wf_arg,r4tp)
            end
        else
            --------------------------------------
            -- Error message #145
            -- Argument of 'dom' is not a map type
            --------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,145,[]);
            return mk_(false, mk_REP`SetTypeRep(mk_REP`AllTypeRep()))); 
     );

  wf_MAPRNG : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK --??
  wf_MAPRNG (i, unexpr, exptp) ==
    def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
        ExpectedRngType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
    in
     (dcl rngtp : REP`TypeRep := mk_REP`AllTypeRep();
      if TYPE`IsCompatible(i,exptp,ExpectedRngType)
      then rngtp := AUX`UnmaskSetType(i,AUX`ExtractSetType(exptp));
      def ExpectedType    = mk_REP`UnionTypeRep({mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), rngtp),
                                                 mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), rngtp)});
          ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                                 mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())});
          intertp = AUX`IntersectTypeReps(ExpectedRhsType, ExpectedType);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
        if TYPE`IsCompatible(i,argtp, ExpectedRhsType)
        then
          def r1tp = AUX`ExtractMapType(argtp) in
            cases r1tp :
              nil                               -> return mk_(wf_arg,mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())),
              mk_REP`EmptyMapTypeRep(-,Rng)     -> return mk_(wf_arg,mk_REP`EmptySetTypeRep(Rng)),
              mk_REP`GeneralMapTypeRep(-,Rng),
              mk_REP`InjectiveMapTypeRep(-,Rng) -> return mk_(wf_arg,mk_REP`SetTypeRep(Rng)),
              mk_REP`UnionTypeRep(utps) ->
                let r2tp = { rngtp | mk_REP`GeneralMapTypeRep(-,rngtp) in set utps}
                           union
                           { rngtp | mk_REP`InjectiveMapTypeRep(-,rngtp) in set utps},
                    r3tp = AUX`MergeNumericTypes(r2tp),
                    r4tp = cases r3tp:
                             {e} -> if exists tp in set utps & is_REP`EmptyMapTypeRep(tp)
                                    then mk_REP`UnionTypeRep ({mk_REP`EmptySetTypeRep(e), mk_REP`SetTypeRep(e)})
                                    else mk_REP`SetTypeRep(e),
                             others -> if exists tp in set utps & is_REP`EmptyMapTypeRep(tp)
                                       then mk_REP`UnionTypeRep ({mk_REP`EmptySetTypeRep(mk_REP`UnionTypeRep(r3tp)),
                                                                  mk_REP`SetTypeRep(mk_REP`UnionTypeRep(r3tp))})
                                       else mk_REP`SetTypeRep(mk_REP`UnionTypeRep(r3tp))
                           end
                in
                  return mk_(wf_arg,r4tp)
            end
        else
            --------------------------------------
            -- Error message #146
            -- Argument of 'rng' is not a map type
            --------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,146,[]);
            return mk_(false, mk_REP`SetTypeRep(mk_REP`AllTypeRep()))); 
     );

  wf_MAPDISTRMERGE : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
  wf_MAPDISTRMERGE (i, unexpr, exptp) ==
    def mk_AS`PrefixExpr(-,rhs,-) = unexpr;
        ExpectedMapType = mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                               mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                               mk_REP`InjectiveMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())});
    in
     (dcl maptp : REP`TypeRep := ExpectedMapType;
      if TYPE`IsCompatible(i, exptp, ExpectedMapType)
      then maptp := AUX`ExtractMapType(exptp);
      def ExpectedType = mk_REP`SetTypeRep(maptp);
          ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SetTypeRep(ExpectedMapType)});
          intertp = AUX`IntersectTypeReps (ExpectedRhsType, ExpectedType);
          mk_(wf_arg, argtp) = wf_Expr(i,rhs,intertp)
      in
        if TYPE`IsCompatible(i,argtp, ExpectedRhsType)
        then def elemtp = AUX`UnmaskSetType(i,AUX`ExtractSetType(argtp))
             in
               if elemtp = nil or argtp = mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())
                     ----------------------------------------
                     -- Error message #147
                     -- 'merge' will always give an empty map
                     ----------------------------------------
               then (ERR`GenErr(unexpr, <ERROR>,147,[]);
                     return mk_(false, mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())))
               else def realtp = AUX`ExtractMapType(elemtp)
                    in
                    if is_REP`UnionTypeRep(realtp)
                    then let mk_REP`UnionTypeRep(tp_s) = realtp
                         in
                           return mk_(wf_arg, AUX`MapTypeMerge(tp_s))
                    elseif realtp = nil
                    then return mk_(wf_arg,mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()))
                    else return mk_(wf_arg,realtp)
        else
            -------------------------------------------
            -- Error message #148
            -- Argument of 'merge' is not a set of maps
            -------------------------------------------
          ( ERR`GenErr(unexpr, <ERROR>,148,[]);
            return mk_(false,ExpectedType)
          )
    );
\end{vdm_al}

% The function $wf\_MAPINVERSE$ still needs to be fully defined.
% Currently it only contains a skeleton.

\begin{vdm_al}
    wf_MAPINVERSE : TYPE`Ind * AS`PrefixExpr * REP`TypeRep ==> bool * REP`TypeRep
    wf_MAPINVERSE (i, unexpr, exptp) ==
       def mk_AS`PrefixExpr(-,oper,cid) = unexpr;
          ExpectedType = mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                              mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                              mk_REP`InjectiveMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())});
          intertp = AUX`IntersectTypeReps(ExpectedType,AUX`InverseMapType(exptp));
          mk_(wf_arg,tp) = wf_Expr(i, oper,intertp)
      in
        if TYPE`IsCompatible(i,tp,ExpectedType)
        then def mtp = AUX`ExtractMapType(tp)
             in
                    let restp = if mtp = nil
                                then mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())
                                else AUX`InverseMapType(mtp)
                    in
                    ( CI`SetTypeInfo(cid,restp);
                      return mk_(wf_arg,restp) )
               -------------------------------------------------------
               -- Error message #149
               -- Argument to Map-Inverse-Expr is not an injective map
               -------------------------------------------------------
        else ( ERR`GenErr(unexpr, <ERROR>,149,[]);
               CI`SetTypeInfo(cid,ExpectedType);
               return mk_(false,ExpectedType) );

\end{vdm_al}

\subsection{Binary Expressions}

\begin{vdm_al}

  wf_BinaryExpr: TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK rettet
  wf_BinaryExpr (i, binexpr, exptp) ==
    let mk_AS`BinaryExpr(-,op,-,cid) = binexpr
    in
     (dcl res : bool * REP`TypeRep;
      cases op :
        <NUMPLUS>      -> res := wf_NUMPLUS (i, binexpr, exptp),
        <NUMMINUS>     -> res := wf_NUMMINUS (i, binexpr, exptp),
        <NUMMULT>      -> res := wf_NUMMULT (i, binexpr, exptp),
        <NUMDIV>       -> res := wf_NUMDIV (i, binexpr, exptp),
        <NUMREM>       -> res := wf_NUMREM (i, binexpr, exptp),
        <NUMMOD>       -> res := wf_NUMMOD (i, binexpr, exptp),
        <INTDIV>       -> res := wf_INTDIV (i, binexpr, exptp),
        <NUMEXP>       -> res := wf_NUMEXP (i, binexpr, exptp),
        <NUMLT>        -> res := wf_NUMLT (i, binexpr, exptp),
        <NUMLE>        -> res := wf_NUMLE (i, binexpr, exptp),
        <NUMGT>        -> res := wf_NUMGT (i, binexpr, exptp),
        <NUMGE>        -> res := wf_NUMGE (i, binexpr, exptp),
        <AND>          -> res := wf_AND (i, binexpr, exptp),
        <OR>           -> res := wf_OR (i, binexpr, exptp),
        <IMPLY>        -> res := wf_IMPLY (i, binexpr, exptp),
        <EQUIV>        -> res := wf_EQUIV (i, binexpr, exptp),
        <EQ>           -> res := wf_EQ (i, binexpr, exptp),
        <NE>           -> res := wf_NE (i, binexpr, exptp),
        <SETUNION>     -> res := wf_SETUNION (i, binexpr, exptp),
        <SETINTERSECT> -> res := wf_SETINTERSECT(i, binexpr, exptp),
        <SETMINUS>     -> res := wf_SETMINUS (i, binexpr, exptp),
        <SUBSET>       -> res := wf_SUBSET (i, binexpr, exptp),
        <PROPERSUBSET> -> res := wf_PROPERSUBSET (i, binexpr, exptp),
        <INSET>        -> res := wf_INSET (i, binexpr, exptp),
        <NOTINSET>     -> res := wf_NOTINSET (i, binexpr, exptp),
        <SEQCONC>      -> res := wf_SEQCONC (i, binexpr, exptp),
        <MAPMERGE>     -> res := wf_MAPMERGE (i, binexpr, exptp),
        <MAPDOMRESTTO> -> res := wf_MAPDOMRESTTO (i, binexpr, exptp),
        <MAPDOMRESTBY> -> res := wf_MAPDOMRESTBY (i, binexpr, exptp),
        <MAPRNGRESTTO> -> res := wf_MAPRNGRESTTO (i, binexpr, exptp),
        <MAPRNGRESTBY> -> res := wf_MAPRNGRESTBY (i, binexpr, exptp),
        <COMPOSE>      -> res := wf_COMPOSE(i, binexpr, exptp),
        others -> error
      end;
      def mk_(-,betp) = res
      in CI`SetTypeInfo(cid,betp);
      return res;
     );

    wf_NUMPLUS : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_NUMPLUS (i, binexpr,exptp) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`NumericTypeRep(<REAL>);
          intertp = AUX`IntersectTypeReps(ExpectedLhsAndRhsType,exptp);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,intertp);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,intertp);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            -----------------------------------
            -- Error message #150
            -- Lhs of '+' is not a numeric type
            -----------------------------------
            ERR`GenErr(binexpr, <ERROR>,150,[]);
          if not rhscomp then
            -----------------------------------
            -- Error message #151
            -- Rhs of '+' is not a numeric type
            -----------------------------------
            ERR`GenErr(binexpr, <ERROR>,151,[]);
          if lhscomp and rhscomp then
            def lhsrestp = AUX`ExtractNumericType(lhstp);
                rhsrestp = AUX`ExtractNumericType(rhstp) in
              let newtp = AUX`MostGeneralNumericType({lhsrestp, rhsrestp})
              in 
                return mk_(wf_lhs and wf_rhs, 
                           if newtp = mk_REP`NumericTypeRep(<NAT>) and
                              mk_REP`NumericTypeRep(<NATONE>) in set {lhsrestp, rhsrestp}
                           then mk_REP`NumericTypeRep(<NATONE>)
                           else newtp)
          else
            return mk_(false,ExpectedLhsAndRhsType));

    wf_NUMMINUS : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_NUMMINUS (i, binexpr, exptp) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`NumericTypeRep(<REAL>);
          intertp = AUX`IntersectTypeReps(ExpectedLhsAndRhsType,exptp);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,intertp);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,intertp);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            -----------------------------------
            -- Error message #152
            -- Lhs of '-' is not a numeric type
            -----------------------------------
            ERR`GenErr(binexpr, <ERROR>,152,[]);
          if not rhscomp then
            -----------------------------------
            -- Error message #153
            -- Rhs of '-' is not a numeric type
            -----------------------------------
            ERR`GenErr(binexpr, <ERROR>,153,[]);
          if lhscomp and rhscomp then
            def lhsrestp = AUX`ExtractNumericType(lhstp);
                rhsrestp = AUX`ExtractNumericType(rhstp) in
            let restp    = AUX`MostGeneralNumericType ({lhsrestp, rhsrestp, mk_REP`NumericTypeRep(<INTEGER>)}) in
            return mk_(wf_lhs and wf_rhs, restp)
          else
            return mk_(false,ExpectedLhsAndRhsType));

    wf_NUMMULT : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_NUMMULT (i, binexpr,exptp) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`NumericTypeRep(<REAL>);
          intertp = AUX`IntersectTypeReps(ExpectedLhsAndRhsType,exptp);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,intertp);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,intertp);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            -----------------------------------
            -- Error message #154
            -- Lhs of '*' is not a numeric type
            -----------------------------------
            ERR`GenErr(binexpr, <ERROR>,154,[]);
          if not rhscomp then
            -----------------------------------
            -- Error message #155
            -- Rhs of '*' is not a numeric type
            -----------------------------------
            ERR`GenErr(binexpr, <ERROR>,155,[]);
          if lhscomp and rhscomp then
            def lhsrestp = AUX`ExtractNumericType(lhstp);
                rhsrestp = AUX`ExtractNumericType(rhstp) in
              return mk_(wf_lhs and wf_rhs, AUX`MostGeneralNumericType({lhsrestp, rhsrestp}))
          else
            return mk_(false, ExpectedLhsAndRhsType));

    wf_NUMDIV : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_NUMDIV (i, binexpr, exptp) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`NumericTypeRep(<REAL>);
          intertp = AUX`IntersectTypeReps(ExpectedLhsAndRhsType,exptp);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,intertp);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,intertp);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            -----------------------------------
            -- Error message #156
            -- Lhs of '/' is not a numeric type
            -----------------------------------
            ERR`GenErr(binexpr,<ERROR>,156,[]);
          if not rhscomp then
            -----------------------------------
            -- Error message #157
            -- Rhs of '/' is not a numeric type
            -----------------------------------
            ERR`GenErr(binexpr, <ERROR>,157,[])
          elseif rhstp <> mk_REP`NumericTypeRep(<NATONE>) and i = <DEF>
               ------------------------------
               -- Error message #158
               -- Rhs of '/' must be non zero
               ------------------------------
          then ERR`GenErr(binexpr, <PROOFOBL>,158,[]);
          if lhscomp and rhscomp and i = <POS>
          then return mk_(wf_lhs and wf_rhs, ExpectedLhsAndRhsType)
          elseif rhstp <> mk_REP`NumericTypeRep(<NATONE>)
          then return mk_(false, ExpectedLhsAndRhsType)
          else return mk_(wf_lhs and wf_rhs and lhscomp and rhscomp, ExpectedLhsAndRhsType));

    wf_NUMREM : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep
    wf_NUMREM (i, binexpr, exptp) ==
      def  mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`NumericTypeRep(<INTEGER>);
          intertp = AUX`IntersectTypeReps(ExpectedLhsAndRhsType,exptp);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,intertp);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,intertp);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            --------------------------------------
            -- Error message #159
            -- Lhs of 'rem' is not an integer type
            --------------------------------------
            ERR`GenErr(binexpr,<ERROR>,159,[]);
          if not rhscomp then
            --------------------------------------
            -- Error message #160
            -- Rhs of 'rem' is not an integer type
            --------------------------------------
            ERR`GenErr(binexpr, <ERROR>,160,[])
          elseif rhstp <> mk_REP`NumericTypeRep(<NATONE>) and i = <DEF>
          then
            --------------------------------
            -- Error message #161
            -- Rhs of 'rem' must be non zero
            --------------------------------
            ERR`GenErr(binexpr, <PROOFOBL>,161,[]);
          if lhscomp and rhscomp then
            def lhsrestp = AUX`ExtractIntNumType(lhstp);
                rhsrestp = AUX`ExtractIntNumType(rhstp) in
            return mk_(wf_lhs and wf_rhs, AUX`MostGeneralNumericType({lhsrestp, rhsrestp}))
          else
            return mk_(false, ExpectedLhsAndRhsType));

    wf_NUMMOD : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_NUMMOD (i, binexpr, exptp) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`NumericTypeRep(<INTEGER>);
          intertp = AUX`IntersectTypeReps(ExpectedLhsAndRhsType,exptp);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,intertp);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,intertp);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            --------------------------------------------
            -- Error message #162
            -- Lhs of 'mod' is not an integer number type
            --------------------------------------------
            ERR`GenErr(binexpr,<ERROR>,162,[]);
          if not rhscomp then
            --------------------------------------------
            -- Error message #163
            -- Rhs of 'mod' is not an integer number type
            --------------------------------------------
            ERR`GenErr(binexpr,<ERROR>,163,[])
          elseif rhstp <> mk_REP`NumericTypeRep(<NATONE>) and i = <DEF>
          then
            --------------------------------
            -- Error message #164
            -- Rhs of 'mod' must be non zero
            --------------------------------
            ERR`GenErr(binexpr,<PROOFOBL>,164,[]);
          if lhscomp and rhscomp
          then return mk_(wf_lhs and wf_rhs, ExpectedLhsAndRhsType)
          else return mk_(false, ExpectedLhsAndRhsType));

    wf_INTDIV : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_INTDIV (i, binexpr, exptp) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`NumericTypeRep(<INTEGER>);
          intertp = AUX`IntersectTypeReps(ExpectedLhsAndRhsType,exptp);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,intertp);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,intertp);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            --------------------------------------
            -- Error message #165
            -- Lhs of 'div' is not an integer type
            --------------------------------------
            ERR`GenErr(binexpr,<ERROR>,165,[]);
          if not rhscomp then
            --------------------------------------
            -- Error message #166
            -- Rhs of 'div' is not an integer type
            --------------------------------------
            ERR`GenErr(binexpr,<ERROR>,166,[])
          elseif rhstp <> mk_REP`NumericTypeRep(<NATONE>) and i = <DEF>
          then
            --------------------------------
            -- Error message #167
            -- Rhs of 'div' must be non zero
            --------------------------------
            ERR`GenErr(binexpr, <PROOFOBL>,167,[]);
          if lhscomp and rhscomp and i = <POS> then
            def lhsrestp = AUX`ExtractIntNumType(lhstp);
                rhsrestp = AUX`ExtractIntNumType(rhstp) in
            return mk_(wf_lhs and wf_rhs, AUX`MostGeneralNumericType({lhsrestp, rhsrestp}))
          elseif rhstp <> mk_REP`NumericTypeRep(<NATONE>)
          then return mk_(false, ExpectedLhsAndRhsType)
          else 
            if lhscomp
            then
              def lhsrestp = AUX`ExtractIntNumType(lhstp)
              in 
                if lhsrestp = mk_REP`NumericTypeRep(<NATONE>) or lhsrestp = mk_REP`NumericTypeRep(<NAT>)
                then return mk_(wf_lhs and wf_rhs and lhscomp and rhscomp, mk_REP`NumericTypeRep(<NAT>))
              else return mk_(wf_lhs and wf_rhs and lhscomp and rhscomp, ExpectedLhsAndRhsType)
            else return mk_(wf_lhs and wf_rhs and lhscomp and rhscomp, ExpectedLhsAndRhsType));


\end{vdm_al}

\begin{vdm_al}
    wf_NUMEXP : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep
    wf_NUMEXP (i, mk_AS`BinaryExpr(lhs,-,rhs,-),exptp) ==
      def ExpectedLhsType = ExpectedNUMEXPType();
          ExpectedRhsType = mk_REP`NumericTypeRep(<REAL>);
          interlhstp = AUX`IntersectTypeReps(ExpectedLhsType,exptp);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,interlhstp);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,ExpectedRhsType);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedRhsType)
      in
        ( if not lhscomp then
            -------------------------------------------------------------------
            -- Error message #168
            -- Lhs of '**' is neither a numeric type, map type or function type
            -------------------------------------------------------------------
            ERR`GenErr(lhs,<ERROR>,168,[]);
          if not rhscomp then
            ------------------------------------
            -- Error message #169
            -- Rhs of '**' is not a numeric type
            ------------------------------------
            ERR`GenErr(rhs, <ERROR>,169,[]);
          def mk_(wf_comp,tp) = EXPType(i,lhstp,rhstp,lhscomp, rhs)
          in
            return mk_(wf_comp and lhscomp and rhscomp and wf_lhs and wf_rhs,tp));

  EXPType: TYPE`Ind * REP`TypeRep * REP`TypeRep * bool  * AS`Expr ==> bool * REP`TypeRep
  EXPType(i,lhstp,rhstp,lhswf, rhs) ==
    (dcl reswf: bool := true;
     dcl ress: set of REP`TypeRep;

     if lhswf 
     then def maptp = AUX`ExtractMapType(lhstp);
              fntp  = AUX`ExtractFunType(lhstp);
              exprname = "function and map iteration";
              numtp = AUX`ExtractNumericType(lhstp)
          in
           (ress := {maptp,fntp,numtp} \ {nil, mk_REP`AllTypeRep()};
              if numtp = mk_REP`AllTypeRep ()
              then (reswf := TYPE`IsCompatible(i,rhstp, mk_REP`NumericTypeRep(<NAT>));
                    if not reswf
                         ---------------------------------------
                         -- Error message #170
                         -- Rhs of "%1" must be a natural number
                         ---------------------------------------
                    then ERR`GenErr(rhs,<ERROR>,170,[exprname]);
                    if i = <DEF> and not AUX`RngSubTypeDom(ress)
                    then (reswf := false;
                          ------------------------------------------------------
                          -- Error message #171
                          -- If Rhs of "%1" is larger than 2 range must be a
                          -- subset of domain
                          ------------------------------------------------------
                          ERR`GenErr(rhs,<ERROR>,171,[exprname]))) 
              elseif rhstp = mk_REP`AllTypeRep()
              then return mk_(false, ExpectedNUMEXPType())
              else 
                  (ress := AUX`MergeNumericTypes(ress union {rhstp}); 
                    if (i = <DEF>) and ((maptp <> nil) or fntp <> nil)
                         and not AUX`RngSubTypeDom(ress)
                    then (reswf := false;
                          ------------------------------------------------------
                          -- Error message #171
                          -- If Rhs of "%1" is larger than 2 range must be a
                          -- subset of domain
                          ------------------------------------------------------
                          ERR`GenErr(rhs,<ERROR>,171,[exprname])));
              cases ress:
                {}         -> error,
                {t}        -> return mk_(reswf,t),      
                {t1,t2}    -> return mk_(reswf,AUX`MergeTypes(t1,t2)),
                {t1,t2,t3} -> return mk_(reswf,AUX`MergeTypes(t1,AUX`MergeTypes(t2,t3)))
              end)
     else return mk_(false,ExpectedNUMEXPType()))

functions

  ExpectedNUMEXPType: () -> REP`TypeRep
  ExpectedNUMEXPType() ==
    mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                         mk_REP`NumericTypeRep(<REAL>),
                         mk_REP`TotalFnTypeRep([mk_REP`AllTypeRep()], mk_REP`AllTypeRep()),
                         mk_REP`PartialFnTypeRep([mk_REP`AllTypeRep()], mk_REP`AllTypeRep()),
                         mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                         mk_REP`InjectiveMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())})

operations

    wf_NUMLT : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_NUMLT (i, binexpr, -) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`NumericTypeRep(<REAL>);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,ExpectedLhsAndRhsType);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,ExpectedLhsAndRhsType);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            -----------------------------------
            -- Error message #172
            -- Lhs of '<' is not a numeric type
            -----------------------------------
            ERR`GenErr(binexpr,<ERROR>,172,[]);
          if not rhscomp then
            -----------------------------------
            -- Error message #173
            -- Rhs of '<' is not a numeric type
            -----------------------------------
            ERR`GenErr(binexpr, <ERROR>,173,[]);
          if lhscomp and rhscomp
          then return mk_(wf_lhs and wf_rhs, mk_REP`BooleanTypeRep())
          else return mk_(false, mk_REP`BooleanTypeRep()));

    wf_NUMLE : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_NUMLE (i, binexpr, -) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`NumericTypeRep(<REAL>);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,ExpectedLhsAndRhsType);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,ExpectedLhsAndRhsType);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            ------------------------------------
            -- Error message #174
            -- Lhs of '<=' is not a numeric type
            ------------------------------------
            ERR`GenErr(binexpr,<ERROR>,174,[]);
          if not rhscomp then
            ------------------------------------
            -- Error message #175
            -- Rhs of '<=' is not a numeric type
            ------------------------------------
            ERR`GenErr(binexpr, <ERROR>,175,[]);
          if lhscomp and rhscomp
          then return mk_(wf_lhs and wf_rhs, mk_REP`BooleanTypeRep())
          else return mk_(false, mk_REP`BooleanTypeRep()));

    wf_NUMGT : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_NUMGT (i, binexpr, -) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`NumericTypeRep(<REAL>);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,ExpectedLhsAndRhsType);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,ExpectedLhsAndRhsType);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            -----------------------------------
            -- Error message #176
            -- Lhs of '>' is not a numeric type
            -----------------------------------
            ERR`GenErr(binexpr,<ERROR>,176,[]);
          if not rhscomp then
            -----------------------------------
            -- Error message #177
            -- Rhs of '>' is not a numeric type
            -----------------------------------
            ERR`GenErr(binexpr, <ERROR>,177,[]);
          if lhscomp and rhscomp
          then return mk_(wf_lhs and wf_rhs, mk_REP`BooleanTypeRep())
          else return mk_(false, mk_REP`BooleanTypeRep()));

    wf_NUMGE : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_NUMGE (i, binexpr, -) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`NumericTypeRep(<REAL>);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,ExpectedLhsAndRhsType);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,ExpectedLhsAndRhsType);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            ------------------------------------
            -- Error message #178
            -- Lhs of '>=' is not a numeric type
            ------------------------------------
            ERR`GenErr(binexpr,<ERROR>,178,[]);
          if not rhscomp then
            ------------------------------------
            -- Error message #179
            -- Rhs of '>=' is not a numeric type
            ------------------------------------
            ERR`GenErr(binexpr, <ERROR>,179,[]);
          if lhscomp and rhscomp
          then return mk_(wf_lhs and wf_rhs, mk_REP`BooleanTypeRep())
          else return mk_(false, mk_REP`BooleanTypeRep()));

    wf_AND : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_AND (i, binexpr, -) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`BooleanTypeRep();
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,ExpectedLhsAndRhsType);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,ExpectedLhsAndRhsType);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            -------------------------------------
            -- Error message #180
            -- Lhs of 'and' is not a boolean type
            -------------------------------------
            ERR`GenErr(binexpr,<ERROR>,180,[]);
          if not rhscomp then
            -------------------------------------
            -- Error message #181
            -- Rhs of 'and' is not a boolean type
            -------------------------------------
            ERR`GenErr(binexpr, <ERROR>,181,[]);
          if lhscomp and rhscomp
          then return mk_(wf_lhs and wf_rhs, ExpectedLhsAndRhsType)
          else return mk_(false, ExpectedLhsAndRhsType));

    wf_OR : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_OR (i, binexpr, -) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`BooleanTypeRep();
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,ExpectedLhsAndRhsType);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,ExpectedLhsAndRhsType);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            ------------------------------------
            -- Error message #182
            -- Lhs of 'or' is not a boolean type
            ------------------------------------
            ERR`GenErr(binexpr,<ERROR>,182,[]);
          if not rhscomp then
            ------------------------------------
            -- Error message #183
            -- Rhs of 'or' is not a boolean type
            ------------------------------------
            ERR`GenErr(binexpr,<ERROR>,183,[]);
          if lhscomp and rhscomp
          then return mk_(wf_lhs and wf_rhs, ExpectedLhsAndRhsType)
          else return mk_(false, ExpectedLhsAndRhsType));

    wf_IMPLY : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_IMPLY (i, binexpr, -) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`BooleanTypeRep();
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,ExpectedLhsAndRhsType);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,ExpectedLhsAndRhsType);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            ------------------------------------
            -- Error message #184
            -- Lhs of '=>' is not a boolean type
            ------------------------------------
            ERR`GenErr(binexpr,<ERROR>,184,[]);
          if not rhscomp then
            ------------------------------------
            -- Error message #185
            -- Rhs of '=>' is not a boolean type
            ------------------------------------
            ERR`GenErr(binexpr, <ERROR>,185,[]);
          if lhscomp and rhscomp then
            return mk_(wf_lhs and wf_rhs, ExpectedLhsAndRhsType)
          else
            return mk_(false, ExpectedLhsAndRhsType));

    wf_EQUIV : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_EQUIV (i, binexpr, -) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`BooleanTypeRep();
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,ExpectedLhsAndRhsType);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,ExpectedLhsAndRhsType);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            -------------------------------------
            -- Error message #186
            -- Lhs of '<=>' is not a boolean type
            -------------------------------------
            ERR`GenErr(binexpr,<ERROR>,186,[]);
          if not rhscomp then
            -------------------------------------
            -- Error message #187
            -- Rhs of '<=>' is not a boolean type
            -------------------------------------
            ERR`GenErr(binexpr, <ERROR>,187,[]);
          if lhscomp and rhscomp then
            return mk_(wf_lhs and wf_rhs, ExpectedLhsAndRhsType)
          else
            return mk_(false, ExpectedLhsAndRhsType));

    wf_EQ : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_EQ (i,binexpr,-) ==
     (def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          mk_(wf_lhs, tp_lhs) = wf_Expr(i,lhs,mk_REP`AllTypeRep());
          mk_(wf_rhs, tp_rhs) = wf_Expr(i,rhs,mk_REP`AllTypeRep())
      in
      -- QUESTION: is this correct???
        (def iscomp = TYPE`IsCompatible(<POS>,tp_lhs,tp_rhs) in
         ( if not iscomp then 
             -------------------------------------
             -- Error message #188
             -- This equality will always be false
             -------------------------------------
             ERR`GenErr(binexpr, <ERROR>,188,[]);
           return mk_(wf_lhs and wf_rhs and iscomp, mk_REP`BooleanTypeRep()))));

    wf_NE : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_NE (i,binexpr, -) ==
     (def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          mk_(wf_lhs, tp_lhs) = wf_Expr(i,lhs,mk_REP`AllTypeRep());
          mk_(wf_rhs, tp_rhs) = wf_Expr(i,rhs,mk_REP`AllTypeRep())
      in
      -- QUESTION: is this correct???
        (def iscomp = TYPE`IsCompatible(<POS>,tp_lhs,tp_rhs) in
         ( if not iscomp then 
             --------------------------------------
             -- Error message #189
             -- This inequality will always be true
             --------------------------------------
             ERR`GenErr(binexpr, <ERROR>,189,[]);
           return mk_(wf_lhs and wf_rhs and iscomp, mk_REP`BooleanTypeRep()))));

    wf_SETUNION : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_SETUNION (i, binexpr, exptp) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                       mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
          intertp = AUX`IntersectTypeReps(ExpectedLhsAndRhsType,exptp);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,intertp);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,intertp);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            -----------------------------------
            -- Error message #190
            -- Lhs of 'union' is not a set type
            -----------------------------------
            ERR`GenErr(binexpr,<ERROR>,190,[]);
          if not rhscomp then
            -----------------------------------
            -- Error message #191
            -- Rhs of 'union' is not a set type
            -----------------------------------
            ERR`GenErr(binexpr, <ERROR>,191,[]);
          if lhscomp and rhscomp then
            def lhsrestp = AUX`ExtractSetType(lhstp);
                rhsrestp = AUX`ExtractSetType(rhstp) in
            (if i = <POS> and
                not TYPE`IsCompatible(i, lhsrestp, rhsrestp) and
                TYPE`IsCompatible(i, AUX`SetTypeUnion({lhsrestp,rhsrestp}), intertp)
             then
               (if not is_REP`EmptySetTypeRep(lhsrestp) and not TYPE`IsCompatible(i, lhsrestp, intertp)
                -----------------------------------
                -- Error message #443
                -- Lhs of 'union' is not a correct type
                -----------------------------------
                then ERR`GenErr(lhs, <ERROR>,443,[]);
                if not is_REP`EmptySetTypeRep(rhsrestp) and not TYPE`IsCompatible(i, rhsrestp, intertp)
                -----------------------------------
                -- Error message #444
                -- Rhs of 'union' is not a correct type
                -----------------------------------
                then ERR`GenErr(rhs, <ERROR>,444,[]));
            return mk_(wf_lhs and wf_rhs, AUX`SetTypeUnion({lhsrestp,rhsrestp})))
          else
            return mk_(false,ExpectedLhsAndRhsType));

    wf_SETINTERSECT : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_SETINTERSECT (i, binexpr, exptp) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                       mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
          intertp = AUX`IntersectTypeReps(ExpectedLhsAndRhsType,exptp);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,intertp);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,intertp);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            -----------------------------------
            -- Error message #192
            -- Lhs of 'inter' is not a set type
            -----------------------------------
            ERR`GenErr(binexpr,<ERROR>,192,[]);
          if not rhscomp then
            -----------------------------------
            -- Error message #193
            -- Rhs of 'inter' is not a set type
            -----------------------------------
            ERR`GenErr(binexpr,<ERROR>,193,[]);
          if not TYPE`IsCompatible(<POS>,lhstp,rhstp)
                -------------------------------------------------------------
                -- Error message #194
                -- This set intersection will always be equal to an empty set
                -------------------------------------------------------------
          then (ERR`GenErr(binexpr,<ERROR>,194,[]);
                return mk_(false, mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())))
          elseif lhscomp and rhscomp then
            def lhsrestp = AUX`ExtractSetType(lhstp);
                rhsrestp = AUX`ExtractSetType(rhstp);
                tp = AUX`SetTypeInter({lhsrestp,rhsrestp})
            in
              (if tp = mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())
                     -----------------------------------------------------------
                     -- Error message #194
                     -- This set intersection will always be equal to an empty
                     -- set
                     -----------------------------------------------------------
               then (ERR`GenErr(binexpr,<WARNING>,194,[]);
                     return mk_(wf_lhs and wf_rhs, mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())));
               return mk_(wf_lhs and wf_rhs,
                          if is_REP`UnionTypeRep(tp)
                          then let mk_REP`UnionTypeRep(tps) = tp
                               in mk_REP`UnionTypeRep(tps union {mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())})
                          else mk_REP`UnionTypeRep({tp, mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())})))
          else
            return mk_(false,ExpectedLhsAndRhsType));

    wf_SETMINUS : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_SETMINUS (i, binexpr, exptp) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                       mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
          intertp = AUX`IntersectTypeReps(ExpectedLhsAndRhsType,exptp);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,intertp);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,intertp);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            ---------------------------------------
            -- Error message #195
            -- Lhs of 'set minus' is not a set type
            ---------------------------------------
            ERR`GenErr(binexpr,<ERROR>,195,[]);
          if not rhscomp then
            ---------------------------------------
            -- Error message #196
            -- Rhs of 'set minus' is not a set type
            ---------------------------------------
            ERR`GenErr(binexpr,<ERROR>,196,[]);
          if not TYPE`IsCompatible(<POS>,lhstp,rhstp)
                ------------------------------------------
                -- Error message #197
                -- Set minus operation removes no elements
                ------------------------------------------
          then (ERR`GenErr(binexpr,<ERROR>,197,[]);
                return mk_(wf_lhs and wf_rhs and lhscomp and rhscomp,
                           if lhscomp
                           then lhstp
                           else ExpectedLhsAndRhsType))
          elseif lhscomp and rhscomp then
            def lhsrestp = AUX`ExtractSetType(lhstp);
                rhsrestp = AUX`ExtractSetType(rhstp) in
              def tp = AUX`SetTypeMinus(lhsrestp,rhsrestp)
              in
                return mk_(wf_lhs and wf_rhs, if tp = nil
                                              then lhsrestp
                                              else tp)
          else
            return mk_(false,mk_REP`SetTypeRep(mk_REP`AllTypeRep())));

    wf_SUBSET : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_SUBSET (i, binexpr, -) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                       mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,ExpectedLhsAndRhsType);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,ExpectedLhsAndRhsType);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType);
	  combine = lhstp <> mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()) =>
                      TYPE`IsCompatible(<POS>,AUX`RemoveEmptySetType(lhstp),rhstp)
      in
        ( if not lhscomp then
            ------------------------------------
            -- Error message #198
            -- Lhs of 'subset' is not a set type
            ------------------------------------
            ERR`GenErr(binexpr,<ERROR>,198,[]);
          if not rhscomp then
            ------------------------------------
            -- Error message #199
            -- Rhs of 'subset' is not a set type
            ------------------------------------
            ERR`GenErr(binexpr,<ERROR>,199,[]);
	  if lhscomp and rhscomp and not combine then
            ------------------------------------
            -- Error message #392
            -- subset will only be true if the Lhs set is empty
            ------------------------------------
            ERR`GenErr(binexpr,<ERROR>,392,[]);
          if lhscomp and rhscomp and combine then
            return mk_(wf_lhs and wf_rhs, mk_REP`BooleanTypeRep())
          else
            return mk_(false, mk_REP`BooleanTypeRep()));

    wf_PROPERSUBSET : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_PROPERSUBSET (i, binexpr, -) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                       mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,ExpectedLhsAndRhsType);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,ExpectedLhsAndRhsType);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType);
	  combine = lhstp <> mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()) =>
                      TYPE`IsCompatible(<POS>,AUX`RemoveEmptySetType(lhstp),rhstp)
      in
        ( if not lhscomp then
            -------------------------------------
            -- Error message #200
            -- Lhs of 'psubset' is not a set type
            -------------------------------------
            ERR`GenErr(binexpr,<ERROR>,200,[]);
          if not rhscomp then
            --------------------------------------
            -- Error message #201
            -- Rhs of 'psubset' is not a set type
            --------------------------------------
            ERR`GenErr(binexpr,<ERROR>,201,[]);
	  if lhscomp and rhscomp and not combine then
            ------------------------------------
            -- Error message #392
            -- subset will only be true if the Lhs set is empty
            ------------------------------------
            ERR`GenErr(binexpr,<ERROR>,392,[]);
          if lhscomp and rhscomp and combine then
            return mk_(wf_lhs and wf_rhs, mk_REP`BooleanTypeRep())
          else
            return mk_(false, mk_REP`BooleanTypeRep()));

    wf_INSET : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_INSET (i, binexpr, -) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
          ExpectedLhsType = mk_REP`AllTypeRep();
    --  EXTENDED POS CHECK:
    --  Instead of REP`AllTypeRep one could use the type lhstp found
    --  by the wf check of the lefthandside
          mk_(wf_lhs, lhstp) = wf_Expr(i,lhs,ExpectedLhsType);
          mk_(wf_rhs, rhstp) = wf_Expr(i,rhs,ExpectedRhsType);
      -- QUESTION: is this correct???
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedRhsType)
      in
         if not rhscomp then
             ------------------------------------
             -- Error message #202
             -- Rhs of 'in set' is not a set type
             ------------------------------------
           ( ERR`GenErr(binexpr,<ERROR>,202,[]);
             return mk_(false, mk_REP`BooleanTypeRep()))
         else
           (def iscomp = TYPE`IsCompatible(<POS>,mk_REP`SetTypeRep(lhstp), AUX`RemoveEmptySetType(rhstp)) and
                         not is_REP`EmptySetTypeRep(rhstp) in
            ( if not iscomp then 
                ------------------------------------------------
                -- Error message #203
                -- This membership check will always yield false
                ------------------------------------------------
                ERR`GenErr(binexpr,<ERROR>,203,[]);
              return mk_(wf_lhs and wf_rhs and iscomp, mk_REP`BooleanTypeRep())));

    wf_NOTINSET : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_NOTINSET (i, binexpr, -) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                                 mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
          ExpectedLhsType = mk_REP`AllTypeRep();
    --  EXTENDED POS CHECK:
    --  Instead of REP`AllTypeRep one could use the type lhstp found by the wf check of the lefthandside
          mk_(wf_lhs, lhstp) = wf_Expr(i,lhs,ExpectedLhsType);
          mk_(wf_rhs, rhstp) = wf_Expr(i,rhs,ExpectedRhsType);
      -- QUESTION: is this correct???
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedRhsType)
      in
         if not rhscomp then
             ----------------------------------------
             -- Error message #204
             -- Rhs of 'not in set' is not a set type
             ----------------------------------------
           ( ERR`GenErr(binexpr,<ERROR>,204,[]);
             return mk_(false, mk_REP`BooleanTypeRep()))
         else
           (def iscomp = TYPE`IsCompatible(<POS>,mk_REP`SetTypeRep(lhstp), AUX`RemoveEmptySetType(rhstp)) and
                         not is_REP`EmptySetTypeRep(rhstp) in
            ( if not iscomp then 
                 ---------------------------------------------------
                 -- Error message #205
                 -- This not-membership check will always yield true
                 ---------------------------------------------------
                 ERR`GenErr(binexpr, <ERROR>,205,[]);
              return mk_(wf_lhs and wf_rhs and iscomp, mk_REP`BooleanTypeRep())));

    wf_SEQCONC : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK rettet
    wf_SEQCONC (i, binexpr, exptp) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          ExpectedLhsAndRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
                                                       mk_REP`SeqTypeRep(mk_REP`AllTypeRep())});
          intertp = AUX`IntersectTypeReps(ExpectedLhsAndRhsType,exptp);
          mk_(wf_lhs, lhstp) = wf_Expr(i,lhs,intertp);
          mk_(wf_rhs, rhstp) = wf_Expr(i,rhs,intertp);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            ------------------------------------
            -- Error message #206
            -- Lhs of '^' is not a sequence type
            ------------------------------------
            ERR`GenErr(binexpr,<ERROR>,206,[]);
          if not rhscomp then
            ------------------------------------
            -- Error message #207
            -- Rhs of '^' is not a sequence type
            ------------------------------------
            ERR`GenErr(binexpr,<ERROR>,207,[]);
          if lhscomp and rhscomp then
            def lhsrestp = AUX`ExtractSeqType(lhstp);
                rhsrestp = AUX`ExtractSeqType(rhstp) in
            (if i = <POS> and
                not TYPE`IsCompatible(i, lhsrestp, rhsrestp) and
                TYPE`IsCompatible(i, AUX`SeqTypeConc({lhsrestp,rhsrestp}), intertp)
             then
               (if not is_REP`EmptySeqTypeRep(lhsrestp) and not TYPE`IsCompatible(i, lhsrestp, intertp)
                -----------------------------------
                -- Error message #441
                -- Lhs of '^ion' is not a correct type
                -----------------------------------
                then ERR`GenErr(lhs, <ERROR>,441,[]);
                if not is_REP`EmptySetTypeRep(rhsrestp) and not TYPE`IsCompatible(i, rhsrestp, intertp)
                -----------------------------------
                -- Error message #442
                -- Rhs of '^ion' is not a correct type
                -----------------------------------
                then ERR`GenErr(rhs, <ERROR>,442,[]));
              return mk_(wf_lhs and wf_rhs,AUX`SeqTypeConc({lhsrestp,rhsrestp})))
          else
            return mk_(false, ExpectedLhsAndRhsType));

    wf_MAPMERGE : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK rettet
    wf_MAPMERGE (i, binexpr, exptp) ==
      def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
          --ExpectedLhsAndRhsType = mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
          ExpectedLhsAndRhsType = mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                                 mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                                 mk_REP`InjectiveMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())});
          intertp = AUX`IntersectTypeReps(ExpectedLhsAndRhsType,exptp);
          mk_(wf_lhs, lhstp)    = wf_Expr(i,lhs,intertp);
          mk_(wf_rhs, rhstp)    = wf_Expr(i,rhs,intertp);
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsAndRhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedLhsAndRhsType)
      in
        ( if not lhscomp then
            ------------------------------------
            -- Error message #208
            -- Lhs of 'munion' is not a map type
            ------------------------------------
            ERR`GenErr(binexpr,<ERROR>,208,[]);
          if not rhscomp then
            ------------------------------------
            -- Error message #209
            -- Rhs of 'munion' is not a map type
            ------------------------------------
            ERR`GenErr(binexpr,<ERROR>,209,[]);
          if lhscomp and rhscomp then
            def lhsrestp = AUX`ExtractMapType(lhstp);
                rhsrestp = AUX`ExtractMapType(rhstp) in
             return mk_(wf_lhs and wf_rhs, AUX`MapTypeMerge({lhsrestp,rhsrestp}))
          else
            return mk_(false, ExpectedLhsAndRhsType));

  wf_MAPDOMRESTTO : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK rettet
  wf_MAPDOMRESTTO (i, binexpr, exptp) ==
    def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
        ExpectedLhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                               mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
        --ExpectedRhsType = mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
        ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                               mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                               mk_REP`InjectiveMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())});
    in
     (dcl expdomtp : REP`TypeRep := mk_REP`AllTypeRep();
      if TYPE`IsCompatible(i,ExpectedRhsType,exptp)
      then
        def mk_(expdomtp',-) = AUX`SplitMapType(AUX`ExtractMapType(exptp))
        in expdomtp := expdomtp';
      def interrhstp = AUX`IntersectTypeReps(ExpectedRhsType,exptp);
          interlhstp = AUX`IntersectTypeReps(ExpectedLhsType,expdomtp);
          mk_(wf_lhs, lhstp) = wf_Expr(i,lhs,interlhstp);
          mk_(wf_rhs, rhstp) = wf_Expr(i,rhs,interrhstp);
      -- QUESTION: is this correct???
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedRhsType)
      in
        ( if not lhscomp then
            --------------------------------
            -- Error message #210
            -- Lhs of '<:' is not a set type
            --------------------------------
            ERR`GenErr(binexpr,<ERROR>,210,[]);
          if not rhscomp then
            --------------------------------
            -- Error message #211
            -- Rhs of '<:' is not a map type
            --------------------------------
            ERR`GenErr(binexpr,<ERROR>,211,[]);
          if lhscomp and rhscomp then
            def lhsrestp = AUX`ExtractSetType(lhstp);
                rhsrestp = AUX`ExtractMapType(rhstp);
                mk_(restp,overlap) = AUX`MapTypeDomRestrict (lhsrestp,rhsrestp)
            in
                if overlap = <OK>
                then return mk_(wf_lhs and wf_rhs, restp)
                elseif overlap = <EMPTYMAP>
                      ---------------------------------
                      -- Error message #212
                      -- An empty map is used with '<:'
                      ---------------------------------
                then (ERR`GenErr(binexpr,<WARNING>,212,[]);
                      return mk_(wf_lhs and wf_rhs,rhsrestp)) 
                      ------------------------------------------
                      -- Error message #213
                      -- The '<:' will always yield an empty map
                      ------------------------------------------
                else (ERR`GenErr(binexpr,<ERROR>,213,[]);
                      return mk_(false, mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(),mk_REP`AllTypeRep())))
          else
            return mk_(false, ExpectedRhsType));
     );

  wf_MAPDOMRESTBY : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep --OK rettet
  wf_MAPDOMRESTBY (i, binexpr, exptp) ==
    def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
        ExpectedLhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                               mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
        --ExpectedRhsType = mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
        ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                               mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                               mk_REP`InjectiveMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())});
    in
     (dcl expdomtp : REP`TypeRep := mk_REP`AllTypeRep();
      if TYPE`IsCompatible(i,ExpectedRhsType,exptp)
      then
        def mk_(expdomtp',-) = AUX`SplitMapType(AUX`ExtractMapType(exptp))
        in expdomtp := expdomtp';
      def interlhstp = AUX`IntersectTypeReps(ExpectedLhsType,expdomtp);
          interrhstp = AUX`IntersectTypeReps(ExpectedRhsType,exptp);
          mk_(wf_lhs, lhstp) = wf_Expr(i,lhs,interlhstp);
          mk_(wf_rhs, rhstp) = wf_Expr(i,rhs,interrhstp);
      -- QUESTION: is this correct???
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedRhsType)
      in
        ( if not lhscomp then
            ---------------------------------
            -- Error message #214
            -- Lhs of '<-:' is not a set type
            ---------------------------------
            ERR`GenErr(binexpr,<ERROR>,214,[]);
          if not rhscomp then
            ---------------------------------
            -- Error message #215
            -- Rhs of '<-:' is not a map type
            ---------------------------------
            ERR`GenErr(binexpr,<ERROR>,215,[]);
          if lhscomp and rhscomp then
            def lhsrestp = AUX`ExtractSetType(lhstp);
                rhsrestp = AUX`ExtractMapType(rhstp);
                mk_(restp,overlap) = AUX`MapTypeDomRestrict (lhsrestp,rhsrestp)
            in
                if overlap = <OK>
                then return mk_(wf_lhs and wf_rhs, restp)
                elseif overlap = <EMPTYMAP>
                      ----------------------------------
                      -- Error message #216
                      -- An empty map is used with '<-:'
                      ----------------------------------
                then (ERR`GenErr(binexpr,<WARNING>,216,[]);
                      return mk_(wf_lhs and wf_rhs,rhsrestp))
                      --------------------------------------------------------
                      -- Error message #217
                      -- The '<-:' will never remove any elements from the map
                      --------------------------------------------------------
                else (ERR`GenErr(binexpr,<ERROR>,217,[]);
                      return mk_(false,rhsrestp))
          else
            return mk_(false, ExpectedRhsType));
     );

  wf_MAPRNGRESTTO : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_MAPRNGRESTTO (i, binexpr,exptp) ==
    def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
        --ExpectedLhsType = mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
        ExpectedLhsType = mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                               mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                               mk_REP`InjectiveMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())});
       ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                              mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
    in
     (dcl exprngtp : REP`TypeRep := mk_REP`AllTypeRep();
      if TYPE`IsCompatible(i,ExpectedLhsType,exptp)
      then
        def mk_(-,exprngtp') = AUX`SplitMapType(AUX`ExtractMapType(exptp))
        in exprngtp := exprngtp';
      def interlhstp = AUX`IntersectTypeReps(ExpectedLhsType,exptp);
          interrhstp = AUX`IntersectTypeReps(ExpectedRhsType,exprngtp);
          mk_(wf_lhs, lhstp) = wf_Expr(i,lhs,interlhstp);
          mk_(wf_rhs, rhstp) = wf_Expr(i,rhs,interrhstp);
      -- QUESTION: is this correct???
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedRhsType)
      in
        ( if not lhscomp then
            --------------------------------
            -- Error message #218
            -- Lhs of ':>' is not a map type
            --------------------------------
            ERR`GenErr(binexpr,<ERROR>,218,[]);
          if not rhscomp then
            --------------------------------
            -- Error message #219
            -- Rhs of ':>' is not a set type
            --------------------------------
            ERR`GenErr(binexpr,<ERROR>,219,[]);
          if lhscomp and rhscomp then
            def lhsrestp = AUX`ExtractMapType(lhstp);
                rhsrestp = AUX`ExtractSetType(rhstp);
                mk_(restp,overlap) = AUX`MapTypeRngRestrict (lhsrestp,rhsrestp)
            in
                if overlap = <OK>
                then return mk_(wf_lhs and wf_rhs, restp)
                elseif overlap = <EMPTYMAP>
                      ---------------------------------
                      -- Error message #220
                      -- An empty map is used with ':>'
                      ---------------------------------
                then (ERR`GenErr(binexpr,<WARNING>,220,[]);
                      return mk_(wf_lhs and wf_rhs,lhsrestp))
                      ------------------------------------------
                      -- Error message #221
                      -- The ':>' will always yield an empty map
                      ------------------------------------------
                else (ERR`GenErr(binexpr,<ERROR>,221,[]);
                      return mk_(false, mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(),mk_REP`AllTypeRep())))
          else
            return mk_(false, ExpectedLhsType));
     );

  wf_MAPRNGRESTBY : TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_MAPRNGRESTBY (i, binexpr, exptp) ==
    def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
        --ExpectedLhsType = mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
        ExpectedLhsType = mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                               mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                               mk_REP`InjectiveMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())});
        ExpectedRhsType = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                               mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
    in
     (dcl exprngtp : REP`TypeRep := mk_REP`AllTypeRep();
      if TYPE`IsCompatible(i,ExpectedLhsType,exptp)
      then
        def mk_(-,exprngtp') = AUX`SplitMapType(AUX`ExtractMapType(exptp))
        in exprngtp := exprngtp';
      def interlhstp = AUX`IntersectTypeReps(ExpectedLhsType,exptp);
          interrhstp = AUX`IntersectTypeReps(ExpectedRhsType,exprngtp);
          mk_(wf_lhs, lhstp) = wf_Expr(i,lhs,interlhstp);
          mk_(wf_rhs, rhstp) = wf_Expr(i,rhs,interrhstp);
      -- QUESTION: is this correct???
          lhscomp = TYPE`IsCompatible (i,lhstp, ExpectedLhsType);
          rhscomp = TYPE`IsCompatible (i,rhstp, ExpectedRhsType)
      in
        ( if not lhscomp then
            ---------------------------------
            -- Error message #222
            -- Lhs of ':->' is not a map type
            ---------------------------------
            ERR`GenErr(binexpr,<ERROR>,222,[]);
          if not rhscomp then
            ---------------------------------
            -- Error message #223
            -- Rhs of ':->' is not a set type
            ---------------------------------
            ERR`GenErr(binexpr,<ERROR>,223,[]);
          if lhscomp and rhscomp then
            def lhsrestp = AUX`ExtractMapType(lhstp);
                rhsrestp = AUX`ExtractSetType(rhstp);
                mk_(restp,overlap) = AUX`MapTypeRngRestrict (lhsrestp,rhsrestp)
            in
                if overlap = <OK>
                then return mk_(wf_lhs and wf_rhs, restp)
                elseif overlap = <EMPTYMAP>
                      ----------------------------------
                      -- Error message #224
                      -- An empty map is used with ':->'
                      ----------------------------------
                then (ERR`GenErr(binexpr,<WARNING>,224,[]);
                      return mk_(wf_lhs and wf_rhs,lhsrestp))
                      --------------------------------------------------------
                      -- Error message #225
                      -- The ':->' will never remove any elements from the map
                      --------------------------------------------------------
                else (ERR`GenErr(binexpr,<ERROR>,225,[]);
                      return mk_(false,lhsrestp))
          else
            return mk_(false, ExpectedLhsType));
     );

  wf_COMPOSE :  TYPE`Ind * AS`BinaryExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_COMPOSE(i, binexpr, exptp) ==
    def mk_AS`BinaryExpr(lhs,-,rhs,-) = binexpr;
        ExpectedType = mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                            mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                            mk_REP`InjectiveMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                            mk_REP`TotalFnTypeRep([mk_REP`AllTypeRep()], mk_REP`AllTypeRep()),
                                            mk_REP`PartialFnTypeRep([mk_REP`AllTypeRep()], mk_REP`AllTypeRep())});
        intertp = AUX`IntersectTypeReps(ExpectedType,exptp);
        mk_(wf_lhs,tplhs) = wf_Expr(i,lhs,intertp);
        mk_(wf_rhs,tprhs) = wf_Expr(i,rhs,intertp);
    -- QUESTION: is this correct???
        lhscomp = TYPE`IsCompatible(i,tplhs,ExpectedType);
        rhscomp = TYPE`IsCompatible(i,tprhs,ExpectedType)
      in
        (if not lhscomp then
            ----------------------------------------------------------
            -- Error message #226
            -- Lhs of 'comp' is neither a map type nor a function type
            ----------------------------------------------------------
            ERR`GenErr(lhs,<ERROR>,226,[]);
         if not rhscomp then
            ----------------------------------------------------------
            -- Error message #227
            -- Rhs of 'comp' is neither a map type nor a function type
            ----------------------------------------------------------
            ERR`GenErr(rhs,<ERROR>,227,[]);
         def mk_(wf_comp,restp,-,-) = AUX`ExtractComposeType(i,tplhs,tprhs) 
         in
           (if not wf_comp and lhscomp and rhscomp
                 ---------------------------------------------------------------
                 -- Error message #228
                 -- Rhs range type is not compatible with lhs domain type in
                 -- composition expression
                 ---------------------------------------------------------------
            then ERR`GenErr(binexpr,<ERROR>,228,[]);
            return mk_(wf_comp and lhscomp and rhscomp and wf_lhs and wf_rhs, restp)));
\end{vdm_al}

\subsection{Quantified Expressions}

\begin{vdm_al}

    wf_AllOrExistsExpr : TYPE`Ind * AS`AllOrExistsExpr * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_AllOrExistsExpr (i, vAllOrExistsExpr, -) ==
      def mk_AS`AllOrExistsExpr (-, bind, pred, cid) = vAllOrExistsExpr;
          mk_(wf_smb, bd) = PAT`wf_MultiBindList(i, bind, false);
          btp = mk_REP`BooleanTypeRep()
      in
        (if wf_smb = nil
                --------------------------------
                -- Error message #229
                -- Binding for "%1" is erroneous
                --------------------------------
         then ERR`GenErr(vAllOrExistsExpr, <ERROR>,229,["Quant-Expr"])
         --then ( ERR`GenErr(vAllOrExistsExpr, <ERROR>,229,["Quant-Expr"]);
         --       CI`SetTypeInfo(cid,btp);
         --       CI`SetPidM(cid,bd);
         --       return mk_(false, btp) );

         --if not wf_smb
         else if wf_smb = false
               -----------------------------------
               -- Error message #230
               -- Not all bindings are well-formed
               -----------------------------------
         then ERR`GenErr(vAllOrExistsExpr,<ERROR>,230,[]);

          ENV`EnterScope (bd);
          def mk_(wf_p, etp) = wf_Expr (i, pred, btp)
          in
          -- QUESTION: is this correct???
          def predcomp = TYPE`IsCompatible (i, etp, btp) in
            ( ENV`LeaveScope();
              if not predcomp then
                -------------------------------------------------
                -- Error message #231
                -- Predicate for "%1" is not a boolean expression
                -------------------------------------------------
                ERR`GenErr(vAllOrExistsExpr,<ERROR>,231,["Quant-Expr"]);
              CI`SetTypeInfo(cid,btp);
              --CI`SetPidM(cid,bd);
              CI`SetPidM(cid,{ nm |-> bd(nm).#1 | nm in set dom bd});
              return mk_((wf_smb = true) and wf_p and predcomp, btp)));
      
    wf_ExistsUniqueExpr : TYPE`Ind * AS`ExistsUniqueExpr * REP`TypeRep ==> bool * REP`TypeRep
    wf_ExistsUniqueExpr (i, vExistsUniqueExpr, -) ==
      def mk_AS`ExistsUniqueExpr (bind, pred, cid) = vExistsUniqueExpr;
          mk_(wf_bd, bd) = PAT`wf_Bind(i, bind);
          btp = mk_REP`BooleanTypeRep()
      in
        ( if wf_bd = nil
                 --------------------------------
                 -- Error message #229
                 -- Binding for "%1" is erroneous
                 --------------------------------
          then ERR`GenErr(vExistsUniqueExpr, <ERROR>,229,["Exist-Unique-Expr"])
          --then ( ERR`GenErr(vExistsUniqueExpr, <ERROR>,229,["Exist-Unique-Expr"]);
          --       CI`SetTypeInfo(cid,btp);
          --       CI`SetPidM(cid,bd);
          --       return mk_(false, btp));

          --if not wf_bd 
          else if wf_bd = false
               -----------------------------------
               -- Error message #230
               -- Not all bindings are well-formed
               -----------------------------------
          then ERR`GenErr(vExistsUniqueExpr,<ERROR>,230,[]);

          ENV`EnterScope (bd);
          def mk_(wf_e, etp) = wf_Expr (i, pred, btp) in
          -- QUESTION: is this correct???
          def stcomp = TYPE`IsCompatible(i, etp, btp) in
            ( ENV`LeaveScope();
              if not stcomp then
                -------------------------------------------------
                -- Error message #231
                -- Predicate for "%1" is not a boolean expression
                -------------------------------------------------
                ERR`GenErr(vExistsUniqueExpr,<ERROR>,231,["Exist-Unique-Expr"]);
              CI`SetTypeInfo(cid,btp);
              --CI`SetPidM(cid,bd);
              CI`SetPidM(cid,{ nm |-> bd(nm).#1 | nm in set dom bd});
              return mk_((wf_bd = true) and wf_e and stcomp, btp)));
\end{vdm_al}

\subsection{Iota Expression}

\begin{vdm_al}
  wf_IotaExpr : TYPE`Ind * AS`IotaExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_IotaExpr(i, vIotaExpr, -) ==
   def mk_AS`IotaExpr(bind, pred, cid) = vIotaExpr;
       mk_(wf_bd, bd,restp) = PAT`wf_BindAndType(i, bind);
       btp = mk_REP`BooleanTypeRep()
   in
     ( CI`SetTypeInfo(cid, restp);
       if wf_bd = nil
              --------------------------------
              -- Error message #229
              -- Binding for "%1" is erroneous
              --------------------------------
       then ERR`GenErr(vIotaExpr, <ERROR>,229,["Iota-Expr"])
       --then ( ERR`GenErr(vIotaExpr, <ERROR>,229,["Iota-Expr"]);
       --       return mk_(false, restp));
       --else if not wf_bd
       else if wf_bd = false
            --------------------------------------------------
            -- Error message #232
            -- No binding is possible for this iota expression
            --------------------------------------------------
       then ERR`GenErr (vIotaExpr,<ERROR>,232,[]);
--     then ( ERR`GenErr (vIotaExpr,<ERROR>,232,[]);
--            return mk_(false,restp))
--        else (
      ( 
        ENV`EnterScope (bd);
        def mk_(wf_e, etp) = wf_Expr (i, pred, btp) in
        -- QUESTION: is this correct???
        def stcomp = TYPE`IsCompatible(i, etp, btp) in
          ( ENV`LeaveScope();
            if not stcomp then
              -------------------------------------------------
              -- Error message #231
              -- Predicate for "%1" is not a boolean expression
              -------------------------------------------------
              ERR`GenErr(vIotaExpr, <ERROR>,231,["Iota-Expr"]);
            if i = <DEF>
                 ---------------------------------------------------------------
                 -- Error message #233
                 -- More than one value can satisfy the predicate in the iota
                 -- expression
                 ---------------------------------------------------------------
            then ERR`GenErr(vIotaExpr, <ERROR>,233,[]);
            return mk_((wf_bd = true) and wf_e and stcomp and (i <> <DEF>), restp))));
\end{vdm_al}

\subsection{Set Expressions}

\begin{vdm_al}

  wf_SetEnumerationExpr : TYPE`Ind * AS`SetEnumerationExpr * REP`TypeRep ==> bool * REP`TypeRep 
  wf_SetEnumerationExpr (i, mk_AS`SetEnumerationExpr(els,cid), exptp) ==
   (dcl reswf : bool := true;
    dcl restp : [REP`TypeRep] := nil;
    dcl restp_l : seq of REP`TypeRep := [];
    if els = []
    then
     (CI`SetTypeInfo(cid, mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()));
      return mk_(true, mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep())) )
    else
      def settype = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                           mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
      in
       (dcl expelemtp : REP`TypeRep := mk_REP`AllTypeRep ();
        if TYPE`IsCompatible(<POS>,settype,exptp)
        then
          def ust = AUX`UnmaskSetType(<POS>, AUX`ExtractSetType(exptp))
          in
            if ust <> nil
            then expelemtp := ust;

        for elem in els do
          def mk_(wf,tp) = wf_Expr (i,elem,expelemtp) in
              ( reswf := reswf and wf;
                restp := if restp = nil
                         then tp
                         else AUX`MergeTypes (restp, tp);
                restp_l := restp_l ^ [tp]);
          if (i = <POS>) and TYPE`IsCompatible(i, restp, expelemtp)
          then  
            for all idx in set inds els do
              if not TYPE`IsCompatible(i, restp_l(idx), expelemtp)
                -------------------------------
                -- Error message #397
                -- Value is not type-compatible
                -------------------------------
              then ERR`GenErr(els(idx), <ERROR>,397,[]);
          let str = mk_REP`SetTypeRep(restp) in
          ( CI`SetTypeInfo(cid, str);
            return mk_(reswf, str) ))
    );

  wf_SetComprehensionExpr : TYPE`Ind * AS`SetComprehensionExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_SetComprehensionExpr(i, vSetComprehension, exptp) ==
    def mk_AS`SetComprehensionExpr(elem, bind, pred, cid) = vSetComprehension;
        mk_(wf_bd, bd) = PAT`wf_MultiBindList(i, bind, false);
        btp = mk_REP`BooleanTypeRep();
        settype = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(mk_REP`AllTypeRep()),
                                       mk_REP`SetTypeRep(mk_REP`AllTypeRep())});
    in
     (dcl expelemtp : REP`TypeRep := mk_REP`AllTypeRep (),
          reswf : bool := wf_bd = true;
      if TYPE`IsCompatible(<POS>,settype,exptp)
      then
        def ust = AUX`UnmaskSetType(<POS>, AUX`ExtractSetType(exptp))
        in
          if ust <> nil
          then expelemtp := ust;

      CI`SetPidM(cid,{ nm |-> bd(nm).#1 | nm in set dom bd});
      if wf_bd = nil
      then
        --------------------------------
        -- Error message #229
        -- Binding for "%1" is erroneous
        --------------------------------
       (ERR`GenErr(vSetComprehension, <ERROR>,229,["Set-Comprh-Expr"]);
        let atr = mk_REP`SetTypeRep(mk_REP`AllTypeRep())
        in
         (CI`SetTypeInfo(cid,atr);
          return mk_(false, atr)) );

      if not wf_bd
        -----------------------------------
        -- Error message #230
        -- Not all bindings are well-formed
        -----------------------------------
      then ERR`GenErr(vSetComprehension, <ERROR>,230,[]);

      ENV`EnterScope(bd);

      if pred <> nil
      then
        def mk_(wf_pr, pr_tp) = wf_Expr(i, pred, btp);
            pcomp = TYPE`IsCompatible(i, pr_tp, btp)
        in
         (if not pcomp
          then
            -------------------------------------------------
            -- Error message #231
            -- Predicate for "%1" is not a boolean expression
            -------------------------------------------------
            ERR`GenErr(pred, <ERROR>,231,["Set-Comprh-Expr"]);
          reswf := reswf and wf_pr and pcomp);

      def mk_(wf_e, e_tp) = wf_Expr(i, elem, expelemtp);
      in
       (ENV`LeaveScope();
        reswf := reswf and wf_e;
        let utr = mk_REP`UnionTypeRep({mk_REP`EmptySetTypeRep(e_tp), mk_REP`SetTypeRep(e_tp)})
        in
         (CI`SetTypeInfo(cid, utr);
          return mk_(reswf, utr));
       )
     );

  wf_SetRangeExpr : TYPE`Ind * AS`SetRangeExpr * REP`TypeRep ==> bool * REP`TypeRep --OK rettet
  wf_SetRangeExpr (i, mk_AS`SetRangeExpr(lb, ub, cid), -) ==
    def ntp = mk_REP`NumericTypeRep(<REAL>);
        mk_(wf_lb, lb_tp) = wf_Expr(i, lb, ntp);
        lcomp = TYPE`IsCompatible(i, lb_tp, ntp); -- QUESTIONS: Is this correct ???
        mk_(wf_ub, ub_tp) = wf_Expr(i, ub, ntp);
        ucomp = TYPE`IsCompatible(i, ub_tp, ntp) -- QUESTIONS: Is this correct ???
    in
     (dcl str : REP`TypeRep;

      if not lcomp
      then
        ----------------------------------------------------
        -- Error message #234
        -- Lower index of Set-Range-Expr is not of type real
        ----------------------------------------------------
        ERR`GenErr(lb,<ERROR>,234,[]);

      if not ucomp
      then
        ----------------------------------------------------
        -- Error message #235
        -- Upper index of Set-Range-Expr is not of type real
        ----------------------------------------------------
        ERR`GenErr(ub, <ERROR>,235,[]);

      if lcomp and ucomp 
      then
        def numtp = AUX`ExtractNumericType(lb_tp)
        in
          let restp = cases numtp:
                        (mk_REP`NumericTypeRep(<NATONE>)),
                        (mk_REP`NumericTypeRep(<NAT>))    -> numtp,
                        others                            -> mk_REP`NumericTypeRep(<INTEGER>)
                      end
          in str := mk_REP`SetTypeRep(restp)
        else str := mk_REP`AllTypeRep();
          
        CI`SetTypeInfo(cid, str);
        return mk_(wf_lb and lcomp and wf_ub and ucomp, str);
     );
\end{vdm_al}

\subsection{Sequence Expressions}

\begin{vdm_al}

  wf_SeqEnumerationExpr : TYPE`Ind * AS`SeqEnumerationExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_SeqEnumerationExpr (i, mk_AS`SeqEnumerationExpr(els,cid), exptp) ==
   (dcl reswf : bool := true;
    dcl restp : [REP`TypeRep] := nil;
    dcl restp_l : seq of REP`TypeRep := [];
    if els = []
    then
     (CI`SetTypeInfo(cid, mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()));
      return mk_(true, mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep())) )
    else
      def seqtype = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
                                           mk_REP`SeqTypeRep(mk_REP`AllTypeRep())});
      in
       (dcl expelemtp : REP`TypeRep := mk_REP`AllTypeRep();
        if TYPE`IsCompatible(<POS>,seqtype,exptp)
        then expelemtp := AUX`UnmaskSeqType(<POS>, AUX`ExtractSeqType(exptp));
        for j in els do
          def mk_(wf, tp) = wf_Expr(i,j,expelemtp)
          in
              ( reswf := reswf and wf;
                restp := if restp = nil
                         then tp
                         else AUX`MergeTypes (restp, tp);
                restp_l := restp_l ^ [tp]);
          if i = <POS> and TYPE`IsCompatible(i, restp, expelemtp)
          then  
            for all idx in set inds els do
              if not TYPE`IsCompatible(i, restp_l(idx), expelemtp)
                -------------------------------
                -- Error message #397
                -- Value is not type-compatible
                -------------------------------
              then ERR`GenErr(els(idx), <ERROR>,397,[]);
          let str = mk_REP`SeqTypeRep(restp) in
          ( CI`SetTypeInfo(cid,str);
            return mk_(reswf, str)) );
    );

  wf_SeqComprehensionExpr : TYPE`Ind * AS`SeqComprehensionExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_SeqComprehensionExpr (i, vSeqComprehension, exptp) ==
    def mk_AS`SeqComprehensionExpr(elem,bind,pred,cid) = vSeqComprehension;
        --mk_(wf_bd, bd) = PAT`wf_Bind(i, bind);
    -- the <POS> argument is a hack. MIAN
        btp = mk_REP`BooleanTypeRep();
        seqtype = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
                                       mk_REP`SeqTypeRep(mk_REP`AllTypeRep())});
    in
     (dcl wf_bd : [bool],
          bd : map AS`Name to (REP`TypeRep * nat1),
          expelemtp : REP`TypeRep := mk_REP`AllTypeRep();
      cases true:
        (is_AS`SetBind(bind)) -> def mk_(wf_lbd, lbd) = PAT`wf_SetBind(i, bind)
                                 in
                                  (wf_bd := wf_lbd;
                                   bd := lbd),
        (is_AS`SeqBind(bind)) -> def mk_(wf_lbd, lbd) = PAT`wf_SeqBind(i, bind)
                                 in
                                  (wf_bd := wf_lbd;
                                   bd := lbd),
         others -> error
      end;
      if TYPE`IsCompatible(<POS>,seqtype,exptp)
      then expelemtp := AUX`UnmaskSeqType(<POS>, AUX`ExtractSeqType(exptp));
      --def only_num = forall tp in set rng bd & TYPE`IsCompatible(i,tp,mk_REP`NumericTypeRep(<REAL>));
      def only_num = forall mk_(tp,-) in set rng bd & TYPE`IsCompatible(i,tp,mk_REP`NumericTypeRep(<REAL>));
          only_one = card dom bd = 1
      in
       (dcl reswf : bool := (wf_bd = true) and only_num and only_one;
        --CI`SetPidM(cid,bd);
        CI`SetPidM(cid,{ nm |-> bd(nm).#1 | nm in set dom bd});
        if wf_bd = true and (not only_num or not only_one)
             -------------------------------------------------------------------
             -- Error message #236
             -- Binding in Seq-Comprh-Expr uses non-numeric values or multiple
             -- bindings
             -------------------------------------------------------------------
        then ERR`GenErr(vSeqComprehension, <ERROR>,236,[]);
        if wf_bd = nil
              --------------------------------
              -- Error message #229
              -- Binding for "%1" is erroneous
              --------------------------------
        then (ERR`GenErr(vSeqComprehension, <ERROR>,229,["Seq-Comprh-Expr"]);
              let str = mk_REP`SeqTypeRep(mk_REP`AllTypeRep()) in
              ( CI`SetTypeInfo(cid,str);
                return mk_(false, str)) );
        if not wf_bd then
          -----------------------------------
          -- Error message #230
          -- Not all bindings are well-formed
          -----------------------------------
          ERR`GenErr (vSeqComprehension,<ERROR>,230,[]);

        ENV`EnterScope(bd);

        if pred <> nil
        then
          def mk_(wf_pr, pr_tp) = wf_Expr(i,pred,btp);
              pcomp = TYPE`IsCompatible(i, pr_tp, btp)
          in
           (if not pcomp
            then
              -------------------------------------------------
              -- Error message #231
              -- Predicate for "%1" is not a boolean expression
              -------------------------------------------------
              ERR`GenErr(pred,<ERROR>,231,["Seq-Comprh-Expr"]);
            reswf := reswf and wf_pr and pcomp);

        def mk_(wf_e, e_tp) = wf_Expr(i,elem,expelemtp);
        in
         (ENV`LeaveScope();
          reswf := reswf and wf_e;
          --let etp = mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
          --    rtp = mk_REP`SeqTypeRep(e_tp) in
          --if not wf_e then
          --  let str = mk_REP`SeqTypeRep(mk_REP`AllTypeRep()) in
          --  ( CI`SetTypeInfo(cid,str);
          --    return mk_(false, str) )
          --else
          --  let utr = mk_REP`UnionTypeRep({etp,rtp}) in
          --  ( CI`SetTypeInfo(cid,utr);
          --    return mk_(wf_bd and wf_pr and pcomp and only_num and only_one,  utr))
          let utr = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(e_tp), mk_REP`SeqTypeRep(e_tp)})
          in
           (CI`SetTypeInfo(cid,utr);
            return mk_(reswf, utr));
         );
       );
     );

  wf_SubSequenceExpr : TYPE`Ind * AS`SubSequenceExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_SubSequenceExpr (i, mk_AS`SubSequenceExpr(s,f,t,cid), exptp) ==
    def stp = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
                                   mk_REP`SeqTypeRep(mk_REP`AllTypeRep())});
        ntp = mk_REP`NumericTypeRep(<NATONE>);
        intertp = AUX`IntersectTypeReps(stp,exptp);
        mk_(wf_s, sqtp) = wf_Expr(i,s,intertp);
        scomp = TYPE`IsCompatible (i, sqtp, stp); -- QUESTION: Is this correct ????
    in
     (dcl reswf : bool := wf_s and scomp,
          restp : REP`TypeRep := stp;
      if not scomp
      then
        ------------------------------------
         -- Error message #237
         -- Expression is not a sequence type
         ------------------------------------
         ERR`GenErr(s,<ERROR>,237,[])
       else
        (restp := AUX`ExtractSeqType(sqtp);
         if not TYPE`IsCompatible (<POS>, restp, mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()))
         then restp := AUX`MergeTypes (restp, mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep())));

       def mk_(wf_f, ftp) = wf_Expr(i,f,ntp);
           fcomp = TYPE`IsCompatible (i, ftp, ntp); -- QUESTION: Is this correct ????
       in
        (if not fcomp
         then
           -----------------------------------------------
           -- Error message #238
           -- Lower index is not a positive natural number
           -----------------------------------------------
           ERR`GenErr(f, <ERROR>,238,[]);
         reswf := reswf and wf_f and fcomp);

       def mk_(wf_t, ttp) = wf_Expr(i,t,ntp);
           tcomp = TYPE`IsCompatible (i, ttp, ntp) -- QUESTION: Is this correct ????
       in
        (if not tcomp
         then
           -----------------------------------------------
           -- Error message #239
           -- Upper index is not a positive natural number
           -----------------------------------------------
           ERR`GenErr(t, <ERROR>,239,[]);
         reswf := reswf and wf_t and tcomp);

       CI`SetTypeInfo(cid,restp);
       return mk_(reswf, restp);
     );

  wf_SeqModifyMapOverrideExpr : TYPE`Ind * AS`SeqModifyMapOverrideExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_SeqModifyMapOverrideExpr (i, SeqModMapOverride, exptp) ==
   (dcl restp  : REP`TypeRep;
    dcl resstp : REP`TypeRep;
    dcl resmtp : REP`TypeRep;
    dcl resmap : REP`TypeRep;
       
    def mk_AS`SeqModifyMapOverrideExpr(s,m,cid) = SeqModMapOverride;
        ntp = mk_REP`NumericTypeRep(<NATONE>);
        seqtype = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()),
                                       mk_REP`SeqTypeRep(mk_REP`AllTypeRep())});
        maptype = mk_REP`UnionTypeRep({mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                       mk_REP`InjectiveMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())});
    in
     (dcl expelemtp : REP`TypeRep := mk_REP`AllTypeRep();
      if TYPE`IsCompatible(i,seqtype,exptp)
      then expelemtp := AUX`UnmaskSeqType(<POS>, AUX`ExtractSeqType(exptp))
      elseif TYPE`IsCompatible(i,maptype,exptp)
      then
        def mk_(-,r) = AUX`SplitMapType(AUX`ExtractMapType(exptp))
        in expelemtp := r;
      def expmaptp = mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                          mk_REP`GeneralMapTypeRep(ntp,expelemtp)});
          mk_(wf_seqmap, seqmaptp) = wf_Expr(i,s,AUX`RemoveEmptyMapType(exptp));
         utp  = mk_REP`AllTypeRep();
         m1tp = mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                     mk_REP`GeneralMapTypeRep(utp,utp)});
         stp  = mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()), mk_REP`SeqTypeRep(utp)});
         ExpectedType = AUX`MergeTypes(stp,m1tp);
         seqcomp = TYPE`IsCompatible (i, seqmaptp, stp);
         mapcomp = TYPE`IsCompatible (i, seqmaptp, m1tp);
         seqormapcomp = TYPE`IsCompatible(i,seqmaptp,ExpectedType)
      in
        (
         cases mk_(seqcomp,mapcomp,seqormapcomp):
           mk_(true,false,-) ->
                def mk_(wf_map, maptp) = wf_Expr(i, m, expmaptp);
                    amap    = TYPE`IsCompatible (i, maptp, m1tp);
                    mk_(wf,restp) = wf_SeqModify (i, seqmaptp, maptp, SeqModMapOverride)
                in
                  ( if not amap then
                      -----------------------------------
                      -- Error message #240
                      -- Rhs expression is not a map type
                      -----------------------------------
                      ERR`GenErr(SeqModMapOverride, <ERROR>,240,[]);
                    CI`SetTypeInfo(cid,restp);
                    return mk_(amap and wf and wf_seqmap and wf_map, restp) ),
           mk_(false,true,-) ->
                def mk_(wf_map, maptp) = wf_Expr(i, m, AUX`RemoveEmptyMapType(exptp));
                    amap    = TYPE`IsCompatible (i, maptp, m1tp);
                    mk_(wf,restp) = wf_MapOverride (seqmaptp, maptp, SeqModMapOverride)
                in
                  ( if not amap then
                      -----------------------------------
                      -- Error message #240
                      -- Rhs expression is not a map type
                      -----------------------------------
                      ERR`GenErr(SeqModMapOverride, <ERROR>,240,[]);
                      CI`SetTypeInfo(cid, restp);
                      return mk_(amap and wf and wf_seqmap and wf_map,restp) ),
           mk_(-, -, true) ->
                def m_exptp = AUX`MergeTypes(exptp, expmaptp);
                    mk_(wf_map, maptp) = wf_Expr(i, m, m_exptp);
                    amap    = TYPE`IsCompatible (i, maptp, m1tp)
                in
                (resstp := AUX`ExtractSeqType(seqmaptp);
                 resmtp := AUX`ExtractMapType(seqmaptp);
                 resmap := AUX`ExtractMapType(maptp);
                 if not amap then
                   ( restp := AUX`MergeTypes(stp,m1tp);
                     -----------------------------------
                     -- Error message #240
                     -- Rhs expression is not a map type
                     -----------------------------------
                     ERR`GenErr(SeqModMapOverride, <ERROR>,240,[]))
                 else (if resmap in set {nil, mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())}
                       then restp := AUX`MergeTypes(resstp, resmtp)
                       else restp := AUX`SeqMapTypeModify(resstp,resmtp,resmap));
                 if resmap = mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()) and
                    maptp <> mk_REP`AllTypeRep()
                        --------------------------------
                        -- Error message #242
                        -- An empty modification is used
                        --------------------------------
                 then ( ERR`GenErr(SeqModMapOverride, <ERROR>,242,[]);
                        CI`SetTypeInfo(cid,restp);
                        return mk_(false,restp) )
                 elseif resstp = mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep()) and
                        seqmaptp <> mk_REP`AllTypeRep()
                        ---------------------------------------
                        -- Error message #243
                        -- An empty sequence cannot be modified
                        ---------------------------------------
                 then ( ERR`GenErr(SeqModMapOverride, <ERROR>,243,[]);
                        CI`SetTypeInfo(cid,restp);
                        return mk_(false,restp) )
                 elseif i = <DEF>
                        ------------------------------------------------------
                        -- Error message #244
                        -- Modification of non-existing index may be attempted
                        ------------------------------------------------------
                 then ( ERR`GenErr(SeqModMapOverride, <ERROR>,244,[]);
                        CI`SetTypeInfo(cid,restp);
                        return mk_(false,restp) )
                 else ( CI`SetTypeInfo(cid,restp);
                        return mk_(wf_seqmap and wf_map and amap, restp) )),
          mk_(false,false,false) ->
                  --------------------------------------------------
                  -- Error message #245
                  -- Expression is neither a sequence nor a map type
                  --------------------------------------------------
                ( ERR`GenErr(SeqModMapOverride, <ERROR>,245,[]);
                  CI`SetTypeInfo(cid, ExpectedType);
                  return mk_(false, ExpectedType) ),
           others -> error
         end));
     );

    wf_SeqModify : TYPE`Ind * REP`TypeRep * REP`TypeRep * AS`Expr ==> bool * REP`TypeRep
    wf_SeqModify (i,s,m, SeqModMapOverride) ==
      def stp = AUX`ExtractSeqType(s);
          mtp = AUX`ExtractMapType(m);
          mk_(Dom,Rng) = cases mtp:
                           nil,
                           mk_REP`EmptyMapTypeRep(-,-) -> mk_(nil,nil),
                           mk_REP`GeneralMapTypeRep(d,r),
                           mk_REP`InjectiveMapTypeRep(d,r) -> mk_(d,r),
                           mk_REP`UnionTypeRep(utps) ->
                             let u1tp = {mk_(d,r) | mk_REP`InjectiveMapTypeRep(d,r) in set utps} union
                                        {mk_(d,r) | mk_REP`GeneralMapTypeRep(d,r) in set utps},
                                 mk_(d_s,r_s) = mk_({d|mk_(d,-) in set u1tp}, {r|mk_(-,r) in set u1tp}),
                                 dtps = AUX`MergeNumericTypes(d_s),
                                 rtps = AUX`MergeNumericTypes(r_s),
                                 d = cases dtps:
                                       {} -> undefined,
                                       {e} -> e,
                                       others -> mk_REP`UnionTypeRep(dtps)
                                     end,
                                 r = cases rtps:
                                       {} -> undefined,
                                       {e} -> e,
                                       others -> mk_REP`UnionTypeRep(rtps)
                                     end
                             in mk_(d,r),
                           others -> undefined
                         end
        in
          (if Dom = nil
                 --------------------------------
                 -- Error message #242
                 -- An empty modification is used
                 --------------------------------
           then (ERR`GenErr(SeqModMapOverride, <ERROR>,242,[]);
                 return mk_(false,stp))
           elseif stp = mk_REP`EmptySeqTypeRep(mk_REP`AllTypeRep())
                 ---------------------------------------
                 -- Error message #243
                 -- An empty sequence cannot be modified
                 ---------------------------------------
           then (ERR`GenErr(SeqModMapOverride,<ERROR>,243,[]);
                 return mk_(false,stp))
           elseif TYPE`IsCompatible(i,Dom,mk_REP`NumericTypeRep(<NATONE>))
           then if i = <DEF>
                      ------------------------------------------------------
                      -- Error message #244
                      -- Modification of non-existing index may be attempted
                      ------------------------------------------------------
                then (ERR`GenErr(SeqModMapOverride, <ERROR>,244,[]);
                      return mk_(false,AUX`MergeTypes(stp,mk_REP`SeqTypeRep(Rng))))
                else return mk_(true, AUX`MergeTypes(stp,mk_REP`SeqTypeRep(Rng)))
                 ---------------------------------------------------------------
                 -- Error message #246
                 -- A sequence can only be modified with indices which are
                 -- positive natural numbers
                 ---------------------------------------------------------------
           else (ERR`GenErr(SeqModMapOverride, <ERROR>,246,[]);
                 return mk_(false,AUX`MergeTypes(stp,mk_REP`SeqTypeRep(Rng)))));

    wf_MapOverride : REP`TypeRep * REP`TypeRep * AS`Expr ==> bool * REP`TypeRep 
    wf_MapOverride (s,m, SeqModMapOverride) ==
      def m1tp = AUX`ExtractMapType(s);
          m2tp = AUX`ExtractMapType(m)
      in
        if is_REP`EmptyMapTypeRep(m2tp)
              --------------------------------
              -- Error message #242
              -- An empty modification is used
              --------------------------------
        then (ERR`GenErr(SeqModMapOverride, <ERROR>,242,[]);
              return mk_(false,m1tp))
        elseif m2tp = nil
        then  return mk_(false, m1tp)
        else return mk_(true, AUX`MapTypeMerge({m1tp,m2tp}));
\end{vdm_al}

\subsection{Map Expressions}

\begin{vdm_al}
  wf_Maplet: TYPE`Ind * AS`Maplet * REP`TypeRep ==> bool * REP`TypeRep --OK rettet
  wf_Maplet (i, mk_AS`Maplet(Dom,Rng,-), exptp) ==
    def maptype = mk_REP`UnionTypeRep({mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
                                       mk_REP`InjectiveMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())});
    in
     (dcl expdomtp : REP`TypeRep := mk_REP`AllTypeRep(),
          exprngtp : REP`TypeRep := mk_REP`AllTypeRep();
      if TYPE`IsCompatible(<POS>,maptype,exptp) and not is_REP`AllTypeRep(exptp) and not is_REP`TypeVarRep(exptp)
      then
        def mk_(expdomtp',exprngtp') = AUX`SplitMapType(AUX`ExtractMapType(exptp))
        in
         (expdomtp := expdomtp';
          exprngtp := exprngtp');
      def mk_(wf_Dom, DomTp) = wf_Expr(i, Dom, expdomtp);
          mk_(wf_Rng, RngTp) = wf_Expr(i, Rng, exprngtp)
      in
        if wf_Dom and wf_Rng
        then return mk_(true, mk_REP`GeneralMapTypeRep(DomTp, RngTp))
        else return mk_(false, mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()));
     );

  wf_MapEnumerationExpr : TYPE`Ind * AS`MapEnumerationExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_MapEnumerationExpr (i, MapEnum, exptp) ==
    let mk_AS`MapEnumerationExpr(els,cid) = MapEnum in
    ( dcl reswf : bool := true;
      dcl restp : [REP`TypeRep] := nil;
      if els = [] then
        ( CI`SetTypeInfo(cid, mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()));
          return mk_(true, mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())) )
      else
         let realexptp = if is_REP`UnionTypeRep(exptp) and exists tp in set exptp.tps & is_REP`EmptyMapTypeRep(tp)
	 	         then if card exptp.tps = 2
			      then let {tp,mk_REP`EmptyMapTypeRep(-,-)} = exptp.tps
                                   in tp
			      else
			        mk_REP`UnionTypeRep(exptp.tps \
			               {mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())})
		         else exptp
	 in
	  (
	   for elem in els do
            def mk_(wf,tp) = wf_Maplet(i,elem, realexptp) in
              ( reswf := reswf and wf;
                restp := if restp = nil
                         then tp
                         else AUX`MergeTypes (restp, tp));
          CI`SetTypeInfo(cid, restp);
          if len els > 1 and i = <DEF>
                ------------------------------------------------------
                -- Error message #247
                -- Same domain value may map to different range values
                ------------------------------------------------------
          then (ERR`GenErr(MapEnum, <ERROR>,247,[]);
                return mk_(false,restp))
          else return mk_(reswf, restp))
    );

  wf_MapComprehensionExpr : TYPE`Ind * AS`MapComprehensionExpr * REP`TypeRep ==> bool * REP`TypeRep --OK rettet
  wf_MapComprehensionExpr (i, vMapComprehension,exptp) ==
    def mk_AS`MapComprehensionExpr(elem,bind,pred,cid) = vMapComprehension;
        mk_(wf_bd,bd) = PAT`wf_MultiBindList(i, bind, false);
      -- the <POS> argument is a hack. MIAN
        btp = mk_REP`BooleanTypeRep()
    in
     (dcl reswf : bool := wf_bd = true;
      --CI`SetPidM(cid, bd);
      CI`SetPidM(cid, { nm |-> bd(nm).#1 | nm in set dom bd});
      if wf_bd = nil
        --------------------------------
        -- Error message #229
        -- Binding for "%1" is erroneous
        --------------------------------
      then 
       (ERR`GenErr(vMapComprehension, <ERROR>,229,["Map-Comprh-Expr"]); -- WHAT????
        let gmtr = mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep())
        in
         (CI`SetTypeInfo(cid, gmtr);
          return mk_(false, gmtr)));
           if not wf_bd
                -----------------------------------
                -- Error message #230
                -- Not all bindings are well-formed
                -----------------------------------
           then ERR`GenErr(vMapComprehension, <ERROR>,230,[]);
 
      ENV`EnterScope(bd);

      if pred <> nil
      then
        def mk_(wf_pr, pr_tp) = wf_Expr(i,pred,btp);
            pcomp = TYPE`IsCompatible(i, pr_tp, btp)
        in
         (if not pcomp then
            -------------------------------------------------
            -- Error message #231
            -- Predicate for "%1" is not a boolean expression
            -------------------------------------------------
            ERR`GenErr(pred, <ERROR>,231,["Map-Comprh-Expr"]);
          reswf := reswf and wf_pr and pcomp);

      def mk_(wf_e, e_tp) = wf_Maplet(i,elem,exptp)
      in
       (ENV`LeaveScope();
        reswf := reswf and wf_e;
        if not wf_e
        then
         (CI`SetTypeInfo(cid,e_tp);
          return mk_(false, e_tp))
        else
          let emtp = mk_REP`EmptyMapTypeRep(mk_REP`AllTypeRep(), mk_REP`AllTypeRep()),
              utr = mk_REP`UnionTypeRep({e_tp,emtp})
          in
           (CI`SetTypeInfo(cid,utr);
            return mk_(reswf, utr)));
     );
\end{vdm_al}

\subsection{Tuple Constructor}

\begin{vdm_al}
    --  EXTENDED POS CHECK:
    --  This could be be extended such that each field was checked with its actual type instead of mk_REP`AllTypeRep
    wf_TupleConstructorExpr : TYPE`Ind * AS`TupleConstructorExpr * REP`TypeRep ==> bool * REP`TypeRep
    wf_TupleConstructorExpr (i, mk_AS`TupleConstructorExpr(fields,cid),-) ==
        ( dcl reswf : bool := true;
          dcl restp : seq of REP`TypeRep := [];
          for j in fields do
            def mk_(wf, tp) = wf_Expr(i, j, mk_REP`AllTypeRep()) in
            ( reswf := reswf and wf;
              restp := restp ^ [tp] );
          CI`SetTypeInfo(cid, mk_REP`ProductTypeRep(restp));
          return mk_(reswf, mk_REP`ProductTypeRep(restp)));
\end{vdm_al}

\subsection{Token Constructor} 

\begin{vdm_al}
  wf_TokenConstructorExpr: TYPE`Ind * AS`TokenConstructorExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_TokenConstructorExpr(i, mk_AS`TokenConstructorExpr(expr,cid), exptp) ==
   (dcl reswf : bool := true;
    def token_tp = mk_REP`TokenTypeRep();
        mk_(wf,-) = wf_Expr(i,expr,mk_REP`AllTypeRep())
    in
    ( if not TYPE`IsCompatible(i,token_tp,exptp)
      then ( -------------------------------------------------
             -- Error message #398
             -- Token value was not expected
             -------------------------------------------------
             ERR`GenErr(expr, <ERROR>,398,[]);
	     reswf := false);
      CI`SetTypeInfo(cid, token_tp);
      return mk_(wf and reswf, token_tp) ));
\end{vdm_al}

\subsection{Tuple Selector}

\begin{vdm_al}
  wf_TupleSelectExpr: TYPE`Ind * AS`TupleSelectExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_TupleSelectExpr (i,mk_AS`TupleSelectExpr(expr,no,cid),-) ==
    def mk_(wf_no,-)      = wf_Literal(<DEF>,no,mk_REP`NumericTypeRep(<NATONE>));
        mk_(wf_arg,argtp) = wf_Expr (i, expr, mk_REP`AllTypeRep ())
    in
      if not wf_no
      then
        return mk_(false,mk_REP`AllTypeRep())
      else
        def ptp = AUX`ExtractProductType(argtp,no.val,<GE>)
        in
          if ptp = nil
          then
             ---------------------------------------
             -- Error message #365
             -- A tuple was expected
             ---------------------------------------
             ( ERR`GenErr (expr, <ERROR>,365,[]);
               return mk_(false,mk_REP`AllTypeRep())
             )
          else
            let mk_REP`ProductTypeRep(ptp_l) = ptp
            in 
              if len ptp_l < 2
              then
                ---------------------------------------
                -- Error message #365
                -- A tuple was expected
                ---------------------------------------
               (ERR`GenErr (expr, <ERROR>,365,[]);
                return mk_(false,mk_REP`AllTypeRep())
               )
              elseif len ptp_l >= no.val
              then
               (CI`SetTypeInfo (cid,ptp_l(no.val));
                return mk_(wf_arg, ptp_l(no.val))
               )
              else
                -----------------------------------------
                -- Error message #364
                -- Tuple selector too large
                -----------------------------------------
               (ERR`GenErr(no, <ERROR>,364,[]);
                return mk_(false,mk_REP`AllTypeRep())
               );

  
\end{vdm_al}


\subsection{Type Judgement}

\begin{vdm_al}
  wf_TypeJudgementExpr:TYPE`Ind * AS`TypeJudgementExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_TypeJudgementExpr(i,tpjdg ,exptp) ==
    return wf_IsExpr (i, tpjdg, exptp);

\end{vdm_al}

\subsection{Precondition Apply}

\begin{vdm_al}
  wf_PreConditionApplyExpr: TYPE`Ind * AS`PreConditionApplyExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_PreConditionApplyExpr (i, mk_AS`PreConditionApplyExpr( expr, arg_l, cid), exprtp) ==
    def mk_(wfapp,-) = wf_ApplyExpr(i,mk_AS`ApplyExpr(expr,arg_l,cid),exprtp)
    in
      (CI`SetTypeInfo(cid,mk_REP`BooleanTypeRep());
       return mk_(wfapp,mk_REP`BooleanTypeRep()));
\end{vdm_al}
\subsection{Record Expressions}

\begin{vdm_al}
    --  EXTENDED POS CHECK:
    --  This could be be extended such that each field was checked with its actual type 
    --  instead of mk_REP`AllTypeRep
    wf_RecordConstructorExpr: TYPE`Ind * AS`RecordConstructorExpr * REP`TypeRep ==> bool * REP`TypeRep 
    wf_RecordConstructorExpr (i, RecordConstr, -) ==
     let mk_AS`RecordConstructorExpr(tag, fields, cid) = RecordConstr
     in ( dcl reswf : bool := true;
          dcl restp : seq of REP`FieldRep := [];
          for j in fields do
            def mk_(wf, tp) = wf_Expr(i, j, mk_REP`AllTypeRep()) in
            ( reswf := reswf and wf;
              restp := restp ^ [mk_REP`FieldRep(nil,tp,false)]);
          def pair = ENV`LookUpTag(i,tag,{}) in
            if pair = nil then
                ----------------------------------------------
                -- Error message #254
                -- Composite type "%1" is not defined in "%2".
                ----------------------------------------------
              ( ERR`GenErr(RecordConstr, <ERROR>,254,[ENV`PrintName(tag),"Record-Constructor-Expr"]);
                let ctr = mk_REP`CompositeTypeRep(tag, restp) in
                ( CI`SetTypeInfo(cid, ctr);
                  return mk_(false, ctr) ))
            else
#ifdef VDMSL
              let mk_(newtag,fl) = pair in
#endif VDMSL
#ifdef VDMPP
              let mk_(newtag,fl') = pair in
              def fl = ENV`CheckAccessCurClass (fl') in
              if fl = nil then
                 ---------------------
                 -- Error message #368
                 -- Access violation
                 ---------------------
                 ( ERR`GenErr(tag, <ERROR>,368,[ENV`PrintName (tag)]);
                   return mk_(false,mk_REP`CompositeTypeRep(newtag, restp)))
              else
#endif VDMPP
              let ctr = mk_REP`CompositeTypeRep(newtag, fl) in
              ( CI`SetTypeInfo(cid, ctr);
                if len fl <> len restp then
                    ----------------------------------
                    -- Error message #297
                    -- Wrong number of fields for "%1"
                    ----------------------------------
                  ( ERR`GenErr(RecordConstr, <ERROR>,297,["Record-Constructor-Expr"]);
                    return mk_(false, ctr) )
                else
                  ( for all j in set inds fl do
                      if not TYPE`IsCompatible (i, restp(j).tp, fl(j).tp) then
                          ------------------------------------------------------
                          -- Error message #250
                          -- Type of field number %1 is not compatible with its
                          -- defined type in Record-Constructor-Expr
                          ------------------------------------------------------
                        ( ERR`GenErr(fields(j), <ERROR>,250,[UTIL`itoa(j)]);
                          reswf := false);
                    -- 20100721
                    --return mk_(reswf, ctr))) );
                    return mk_(reswf, mk_REP`TypeNameRep(tag)))) );

    CheckModifications: TYPE`Ind *
                        (REP`CompositeTypeRep | REP`UnionTypeRep) *
                        seq1 of AS`RecordModification * 
                        REP`TypeRep 
                        ==> bool --OK
    CheckModifications (i,tp,mods,-) ==
    ( dcl reswf : bool := true;
      dcl domm  : set of AS`Name := {};
      dcl ftp   : map AS`Name to REP`TypeRep := {|->};
      cases tp:
      mk_REP`CompositeTypeRep(nm,-) ->
      def pair = ENV`LookUpTag(i,nm,{}) in
        if pair <> nil then
#ifdef VDMSL
          let mk_(-,fl) = pair in
#endif VDMSL
#ifdef VDMPP
        def mk_(-,fl') = pair;
            fl = ENV`CheckAccessCurClass (fl') in
          if fl = nil then
           ---------------------
           -- Error message #368
           -- Access violation
           ---------------------
           ( ERR`GenErr(nm, <ERROR>,368,[ENV`PrintName (nm)]);
             return false)
        else
#endif VDMPP
        ( for all mk_REP`FieldRep(fnm, tp,-) in set elems fl do
            if fnm <> nil and fnm not in set dom ftp then
              ftp := ftp munion { fnm |-> tp };
          for mk_AS`RecordModification(mnm,new,-) in mods do
            if mnm in set dom ftp then
              def mk_(wf_arg, argtp) = wf_Expr(i, new, ftp(mnm)) in
               ( reswf := reswf and wf_arg;
                  if not TYPE`IsCompatible (i, argtp, ftp(mnm)) then
                      ----------------------------------------------------------
                      -- Error message #251
                      -- Type of field "%1" is not compatible with its defined
                      -- type
                      ----------------------------------------------------------
                    ( ERR`GenErr (new, <ERROR>,251,[ENV`PrintName(mnm)]);
                      reswf := false
                    ) ;
                  if mnm in set domm then
                    ----------------------------------------
                    -- Error message #348
                    -- Field "%1" is modified more than once
                    ----------------------------------------
                    ERR`GenErr (new, <WARNING>,348,[ENV`PrintName(mnm)]);
                  domm := domm union {mnm}
                )
            else
                -------------------------------------------------
                -- Error message #253
                -- Field with id "%1" is not defined in type "%2"
                -------------------------------------------------
              ( ERR`GenErr(new, <ERROR>,253,[ENV`PrintName(mnm),ENV`PrintName(nm)]);
                reswf := false
              );
         return reswf)
       else
         ( -- There is no need to report an error here
           -- as it is already done, when the record was created.
           -- 28 Oct. 1998 11:05 -- Jesper K. Pedersen
           -- ERR`GenErr(<ERROR>,248,[ENV`PrintName(nm)]);
           return false ),
      mk_REP`UnionTypeRep(Utps) ->
      (dcl onewf : bool := false;
       dcl nms : seq of AS`Name := [];
       
       for all mk_REP`CompositeTypeRep(nm,-) in set Utps
       do
         
      (domm := {};
       nms := nms ^ [nm];
       def pair = ENV`LookUpTag(i,nm,{}) in
        if pair <> nil then
#ifdef VDMSL
        let mk_(-,fl) = pair in
#endif VDMSL
#ifdef VDMPP
        def mk_(-,fl') = pair;
            fl = ENV`CheckAccessCurClass (fl') in
          if fl = nil then        
           ---------------------
           -- Error message #368
           -- Access violation
           ---------------------
           ( ERR`GenErr(nm,<ERROR>,368,[ENV`PrintName (nm)]);
             reswf := false)
        else
#endif VDMPP
        ( ftp := { fnm |-> tp | mk_REP`FieldRep(fnm, tp,-) in set elems fl & fnm <> nil };
          for mk_AS`RecordModification(mnm,new,-) in mods do
            if mnm in set dom ftp then
              def mk_(wf_arg, argtp) = wf_Expr(i, new, ftp(mnm)) in
               (  reswf := reswf and wf_arg;
                  if TYPE`IsCompatible (i, argtp, ftp(mnm))
                  then onewf := true
                  else if i = <DEF>
                             ---------------------------------------------------
                             -- Error message #251
                             -- Type of field "%1" is not compatible with its
                             -- defined type
                             ---------------------------------------------------
                       then (ERR`GenErr (mnm, <ERROR>,251,[ENV`PrintName(mnm)]);
                             reswf := false);
                  if mnm in set domm
                       ----------------------------------------
                       -- Error message #348
                       -- Field "%1" is modified more than once
                       ----------------------------------------
                  then ERR`GenErr (mnm, <WARNING>,348,[ENV`PrintName(mnm)]);
                  domm := domm union {mnm}
                )
            else
              if i = <DEF>
              then
                -------------------------------------------------
                -- Error message #253
                -- Field with id "%1" is not defined in type "%2"
                -------------------------------------------------
               (ERR`GenErr(mnm, <ERROR>,253,[ENV`PrintName(mnm),ENV`PrintName(nm)]);
                reswf := false
              ))
       else
         if i = <DEF>
         then
          (-- There is no need to report an error here
           -- as it is already done, when the record was created.
           -- 28 Oct. 1998 11:05 -- Jesper K. Pedersen
           -- ERR`GenErr(<ERROR>,248,[ENV`PrintName(nm)]);
           reswf := false ));
        if not onewf
        then
           ---------------------------------------------------------------------
           -- Error message #256
           -- None of the composite types "%1" have fields which are compatible
           -- with given field modifications
           ---------------------------------------------------------------------
          (ERR`GenErr(hd mods, <ERROR>,256,
             [ENV`PrintName(nms(1)) ^ conc [", "^ENV`PrintName(nms(j)) | j in set inds nms \ {1}]]);
           return false)
        else return reswf)
      end
    );

    wf_RecordModifierExpr : TYPE`Ind * AS`RecordModifierExpr * REP`TypeRep ==> bool * REP`TypeRep
    wf_RecordModifierExpr (i, mk_AS`RecordModifierExpr(rec,mods,cid), exptp) ==
    ( dcl reswf : bool;
      def mk_(wf_arg, argtp) = wf_Expr (i, rec, mk_REP`AllTypeRep());
          cmptp = mk_REP`CompositeTypeRep(mk_AS`Name([],CI`NilContextId),[]) in
                -- See comment on the use of Name in CompositeTypeRep in env.vdm
        if TYPE`IsCompatible (i, argtp, cmptp) then
          def r1tp = AUX`ExtractCompositeType(argtp) in
            if r1tp <> cmptp then
              ( reswf := CheckModifications(i,r1tp,mods,exptp);
                CI`SetTypeInfo(cid, r1tp);
                -- 20100721
                --return mk_(wf_arg and reswf, r1tp))
                return mk_(wf_arg and reswf, argtp))
            else
                -----------------------------------
                -- Error message #257
                -- Modifications cannot be analyzed
                -----------------------------------
              ( ERR`GenErr (rec, <WARNING>,257,[]);
                CI`SetTypeInfo(cid, mk_REP`AllTypeRep());
                return mk_(false, mk_REP`AllTypeRep()))
        else 
            ------------------------------
            -- Error message #258
            -- Rhs is not a composite type
            ------------------------------
          ( ERR`GenErr(rec, <ERROR>,258,[]);
            CI`SetTypeInfo(cid, mk_REP`AllTypeRep());
            return mk_(false, mk_REP`AllTypeRep()) )
    );
\end{vdm_al}

\subsection{Apply Expressions}

% The current version of the well-formedness operations for apply
% expressions creates unneccesary many warnings. This must be corrected
% somehow in the future.

\begin{vdm_al}
  wf_ApplyExpr : TYPE`Ind * AS`ApplyExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_ApplyExpr (i, vApply, exptp) ==
    def mk_AS`ApplyExpr(fct, arg, cid) = vApply;
        fnmapseqtp = mk_REP`UnionTypeRep({mk_REP`PartialFnTypeRep(mk_REP`AllTypeRep(), exptp),
                                          mk_REP`TotalFnTypeRep(mk_REP`AllTypeRep(), exptp),
                                          mk_REP`GeneralMapTypeRep(mk_REP`AllTypeRep(), exptp),
                                          mk_REP`InjectiveMapTypeRep(mk_REP`AllTypeRep(), exptp),
                                          mk_REP`SeqTypeRep(exptp)});
    in
     (dcl wf_fct : bool,
          fcttp : REP`TypeRep;
#ifdef VDMSL
      def mk_(wf, tp) = wf_Expr(i, fct, fnmapseqtp);
      in
       (wf_fct := wf;
        fcttp := tp);
#endif VDMSL
#ifdef VDMPP
      if is_AS`Name(fct)
      then
        def gtp = ENV`LookUpInObject(ENV`GetCurClass (), fct, false, false)
        in
          if is_(gtp , set of (ENV`AccessOpTypeRep | ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep))
          then
           (wf_fct := true;
            fcttp := mk_REP`OverTypeRep(ENV`CheckAccess (ENV`GetCurClass (), gtp)))
          else
            def mk_(wf, tp) = wf_Expr(i, fct, fnmapseqtp)
            in
             (wf_fct := wf;
              fcttp := tp)
      else
        def mk_(wf, tp) = wf_Expr(i, fct, fnmapseqtp);
        in
         (wf_fct := wf;
          fcttp := tp);
#endif VDMPP
      def argseq = [wf_Expr(i, arg(j), mk_REP`AllTypeRep()) | j in set inds arg]
      in
      --  EXTENDED POS CHECK:
      --  One could look up the expected type of each argument and use this instead of REP`AllTypeRep.
      def wf_arg  = forall mk_(wf_a,-) in set elems argseq & wf_a;
          argtp_l = [let mk_(-,tp) = argseq(j) in tp | j in set inds argseq];
          mk_(wf_apply, res_tp) = CheckApply(i,fcttp,argtp_l, vApply,true)
      in
       (if is_AS`Name(fct)
        then CI`SetTypeInfo(fct.cid, fcttp);
        if res_tp = mk_REP`UnitTypeRep()
        then 
          ---------------------------------
          -- Error message #259
          -- Apply-Expr must return a value
          ---------------------------------
          (ERR`GenErr (vApply, <ERROR>,259,[]);
           CI`SetTypeInfo(cid, mk_REP`AllTypeRep ());
           return mk_(false, mk_REP`AllTypeRep ())
          )
        else 
          (CI`SetTypeInfo(cid, res_tp);
           return mk_(wf_fct and wf_arg and wf_apply,res_tp) ));
     );
\end{vdm_al}

The \texttt{callerr} argument are used to signal whether an error message 
shall be called or not. 

\begin{vdm_al}
  CheckApply: TYPE`Ind * REP`TypeRep * seq of REP`TypeRep * (AS`ApplyExpr | AS`StateDesignator) * bool
              ==> bool * (REP`TypeRep | set of REP`TypeRep)
  CheckApply(i,fcttp,argtp_l,vApply,callerr) ==
   (dcl defwf  : bool := true;
    dcl poswf  : bool := true;
    dcl anyfct : bool := false;
    dcl allfct : bool := true;
    dcl restp  : [REP`TypeRep] := nil;
    dcl realfcttp : [REP`TypeRep | set of REP`TypeRep] := fcttp;
#ifdef VDMPP
    dcl acctp  : [ENV`AccessType] := nil;
#endif VDMPP

    while is_REP`TypeNameRep(realfcttp) and not TYPE`IsUnionRecursive(realfcttp) do
#ifdef VDMPP
      def realfcttp' = ENV`LookUpTypeName  (realfcttp.nm,true)
      in
        if ENV`IsAccessType (realfcttp')
        then
         (realfcttp := realfcttp'.tp;
          acctp := realfcttp')
        else
         (realfcttp := realfcttp';
          acctp := nil);
    if acctp <> nil and not ENV`IsAccessibleCurClass (acctp)
    then
     (------------------------------
      -- Error message #368
      -- Access violation
      ------------------------------
      if callerr
      then ERR`GenErr (realfcttp.nm, <ERROR>,368,[ENV`PrintName (realfcttp.nm)]);
      return mk_(false,mk_REP`AllTypeRep()));     
#endif VDMPP
#ifdef VDMSL
    realfcttp := ENV`LookUpTypeName (realfcttp.nm);
#endif VDMSL
    cases realfcttp :
      (nil),
      mk_REP`AllTypeRep(),
      mk_REP`TypeNameRep(-) -> return mk_(false, mk_REP`AllTypeRep()), 
      mk_REP`InvTypeRep(-,t,-) ->
        if i = <DEF>
        then
         (------------------------------------
          -- Error message #260
          -- Invariant type used in Apply-Expr
          ------------------------------------
          if callerr
          then ERR`GenErr(vApply, <ERROR>,260,[]);
          def mk_(-,newtp) = CheckApply(i,t,argtp_l, vApply,callerr)
          in return mk_(false,newtp))
        else CheckApply(i,t,argtp_l, vApply,callerr),
      mk_REP`SeqTypeRep(-),
      mk_REP`OpTypeRep (-,-),
      mk_REP`GeneralMapTypeRep(-,-),
      mk_REP`InjectiveMapTypeRep(-,-),
      mk_REP`PartialFnTypeRep (-,-),
      mk_REP`TotalFnTypeRep (-,-) -> CheckBasicApply (i, realfcttp, argtp_l, vApply,callerr),
      mk_REP`UnionTypeRep({mk_REP`EmptySeqTypeRep(-), mk_REP`SeqTypeRep(utp)}) ->
        if i = <POS>
        then CheckBasicApply(i,mk_REP`SeqTypeRep(utp),argtp_l, vApply,callerr)
        else
         (------------------------
          -- Error message #261
          -- Sequence may be empty
          ------------------------
          if callerr
          then ERR`GenErr(vApply, <ERROR>,261,[]);
          def mk_(-,t) = CheckBasicApply(i,mk_REP`SeqTypeRep(utp), argtp_l, vApply,callerr)
          in return mk_(false,t)),
      mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(-,-), mk_REP`GeneralMapTypeRep(dtp,rtp)}) ->
        if i = <POS>
        then CheckBasicApply(i,mk_REP`GeneralMapTypeRep(dtp,rtp), argtp_l, vApply,callerr)
        else
         (----------------------
          -- Error message #262
          -- Map may be empty
          ----------------------
          if callerr
          then ERR`GenErr(vApply, <ERROR>,262,[]);
          def mk_(-,t) = CheckBasicApply(i,mk_REP`GeneralMapTypeRep(dtp,rtp), argtp_l, vApply,callerr)
          in return mk_(false,t)),
      mk_REP`UnionTypeRep({mk_REP`EmptyMapTypeRep(-,-), mk_REP`InjectiveMapTypeRep(dtp,rtp)}) ->
        if i = <POS>
        then CheckBasicApply(i,mk_REP`InjectiveMapTypeRep(dtp,rtp), argtp_l, vApply,callerr)
        else
         (----------------------
          -- Error message #262
          -- Map may be empty
          ----------------------
          if callerr
          then ERR`GenErr(vApply, <ERROR>,262,[]);
          def mk_(-,t) = CheckBasicApply(i,mk_REP`InjectiveMapTypeRep(dtp,rtp), argtp_l, vApply,callerr)
          in return mk_(false,t)),
      mk_REP`UnionTypeRep (utps) ->
        ( for all utp in set utps do
            if is_REP`SeqTypeRep(utp) or
               is_REP`GeneralMapTypeRep(utp) or
               is_REP`InjectiveMapTypeRep(utp) or
               is_REP`PartialFnTypeRep(utp) or
               is_REP`TotalFnTypeRep(utp) or
               is_REP`TypeNameRep(utp) or
               is_REP`InvTypeRep(utp) or
               is_REP`OpTypeRep(utp)
            then
             (dcl wf : bool := false,
                  tp : REP`TypeRep := mk_REP`AllTypeRep();
                if is_REP`InvTypeRep(utp) or is_REP`TypeNameRep(utp)
                then
                  def mk_(ok,t) = AUX`CanBeApplied(utp)
                  in
                    if ok
                    then
                      def mk_(wf',tp') = CheckApply(i,t,argtp_l, vApply,false)
                      in
                       (wf := wf';
                        tp := tp')
                    else skip
                else
                  def mk_(wf',tp') = CheckUnionApply(i, utp, argtp_l, vApply)
                  in
                   (wf := wf';
                    tp := tp');
                defwf  := defwf and wf;
                poswf  := poswf or wf;
                restp  := if restp = nil
                            then tp
                            elseif tp <> mk_REP`AllTypeRep()
                            then if restp <> mk_REP`AllTypeRep()
                                 then AUX`MergeTypes (restp, tp)
                                 else tp
                            else restp;
                  anyfct := anyfct or wf)
            else allfct := false;
            if not anyfct
            then
             (-------------------------------
              -- Error message #263
              -- Expression cannot be applied
              -------------------------------
              if callerr
              then ERR`GenErr (vApply, <ERROR>,263,[]);
              return mk_(false, restp));
            if (i = <DEF>) and not allfct
            then
             (--------------------------------------------
              -- Error message #264
              -- Expression cannot be applied in all cases
              --------------------------------------------
              if callerr
              then ERR`GenErr(vApply, <ERROR>,264,[]);
              return mk_(false, restp));
            let reswf = if i = <POS>
                        then poswf
                        else defwf
            in
              (if not reswf and callerr
               then
                 ----------------------
                 -- Error message #267
                 -- Error in Apply-Expr
                 ----------------------
                 ERR`GenErr(vApply, <ERROR>,267,[]);
               return mk_(reswf, restp))),
#ifdef VDMPP
          mk_REP`OverTypeRep (tps) -> CheckOverloadedApply(i, tps, argtp_l, vApply, true, true),
#endif VDMPP
          others ->
             (-------------------------------
              -- Error message #263
              -- Expression cannot be applied
              -------------------------------
              if callerr
              then ERR`GenErr (vApply, <ERROR>,263,[]);
              return mk_(false, mk_REP`AllTypeRep()))
        end);
\end{vdm_al}

The operation \texttt{CheckOverloadedApply} takes a set of possible
method types, a sequence of types representing the types of the
arguments to a method call, the argument expression and a boolean. It
then checks to see whether any of the methods can be matched against the argument types. 
\begin{description}
\item[\texttt{p\_i}] A quote indicating whether we are performing a def or pos type check.
\item[\texttt{p\_overloadedTps}] The set of types corresponding to this method name.
\item[\texttt{p\_argTps}] The sequence of types corresponding to the arguments in the call.
\item[\texttt{p\_expr}] The actual argument expression.
\item[\texttt{p\_repErr}] A flag indicating whether error messages
should be generated or not (depends on the calling context). 
\item[\texttt{p\_retRng}] A flag indicating exactly what should be returned by the operation.
\end{description}
Note that \texttt{p\_expr} is included just for context id information when generating error messages. 

\begin{vdm_al}
  CheckOverloadedApply : TYPE`Ind 
                       * (set of REP`FnTypeRep | set of REP`OpTypeRep) 
                       * seq of REP`TypeRep
                       * (AS`Expr | AS`StateDesignator)
                       * bool 
                       * bool 
                       ==> bool * REP`TypeRep
  CheckOverloadedApply(p_i, p_overloadedTps, p_argTps, p_expr, p_repErr, p_retRng) ==
    let l_fnTps = { b_tp | b_tp in set p_overloadedTps & len ENV`GetMethDom(b_tp) = len p_argTps }
    in
    if l_fnTps = {}
    then
     (-------------------------------
      -- Error message #385
      -- No overloaded function or operation with this 
      -- number of arguments exists
      -------------------------------
      if p_repErr
      then ERR`GenErr (p_expr, <ERROR>, 385, []);
      return mk_(false, mk_REP`AllTypeRep()))
    else
      def l_compatTps = { b_fnTp | b_fnTp in set l_fnTps 
                           & forall b_i in set inds ENV`GetMethDom(b_fnTp) &
                            TYPE`IsCompatible(p_i, p_argTps(b_i), ENV`GetMethDom(b_fnTp)(b_i))
                        }
      in
        if l_compatTps = {}
        then
         (-------------------------------
          -- Error message #386
          -- No overloaded function or operation matches 
          -- these arguments
          -------------------------------
          if p_repErr
          then ERR`GenErr (p_expr, <ERROR>, 386, []);
          return mk_(false, mk_REP`AllTypeRep()))
        elseif card l_compatTps > 1 -- Could happen via inheritance
        then
         (-------------------------------
          -- Error message #387
          -- More than one overloaded function or 
          -- operation matches these arguments
          -------------------------------
          if p_repErr
          then ERR`GenErr (p_expr, <ERROR>, 387, []);
          return mk_(false, mk_REP`AllTypeRep()))
        else 
          let {l_tp} = l_compatTps 
          in
            if is_REP`OpTypeRep(l_tp)
            then if p_retRng
                 then return mk_(true, l_tp.Rng) -- was called from CheckApply
                 else return mk_(true, l_tp) -- was called from CheckOperationCall
            else return mk_(true, l_tp.fnrng);
\end{vdm_al}
    
The \texttt{callerr} argument is used for controlling when error messages are written out.

\begin{vdm_al}
    CheckBasicApply : TYPE`Ind * REP`TypeRep * seq of REP`TypeRep * (AS`ApplyExpr | AS`StateDesignator) * bool
                      ==> bool * REP`TypeRep
    CheckBasicApply (i, tp1 , tp_l, vApply,callerr) ==
      (dcl reswf:bool := true;
      
      cases tp1:
        mk_REP`SeqTypeRep(stp) ->
          if len tp_l = 1
          then 
            if TYPE`IsCompatible (i, hd(tp_l), mk_REP`NumericTypeRep(<NATONE>)) then
              if i = <POS>
              then return mk_(true, stp)
              else
               (---------------------------------------------------
                -- Error message #265
                -- Given index may not exist for the given sequence
                ---------------------------------------------------
                if callerr
                then ERR`GenErr(vApply, <ERROR>,265,[]);
                return mk_(false,stp))
            else
             (-----------------------------------------
              -- Error message #268
              -- Sequence index is not a natural number
              -----------------------------------------
              if callerr
              then ERR`GenErr (vApply, <ERROR>,268,[]);
              return mk_(false, stp))
          else
           (-----------------------------------------------
            -- Error message #266
            -- Sequence is applied with more than one index
            -----------------------------------------------
            if callerr
            then ERR`GenErr(vApply, <ERROR>,266,[]);
            return mk_(false, stp)),
        mk_REP`GeneralMapTypeRep(Dom, Rng),
        mk_REP`InjectiveMapTypeRep(Dom, Rng) ->
          if len tp_l = 1
          then 
            if TYPE`IsCompatible (i, hd tp_l, Dom) then
              if i = <POS>
              then return mk_(true, Rng)
              else
               (-------------------------------------------------------
                -- Error message #269
                -- Given domain element may not exist for the given map
                -------------------------------------------------------
                if callerr
                then ERR`GenErr(vApply, <ERROR>,269,[]);
                return mk_(false,Rng))
            else
             (------------------------------------
              -- Error message #270
              -- Map domain type of incorrect type
              ------------------------------------
              if callerr
              then ERR`GenErr (vApply, <ERROR>,270,[]);
              return mk_(false, Rng))
          else
           (------------------------------------------
            -- Error message #271
            -- Map is applied with more than one value
            ------------------------------------------
            if callerr
            then ERR`GenErr(vApply, <ERROR>,271,[]);
            return mk_(false, Rng)),
        mk_REP`PartialFnTypeRep (Dom, Rng),
        mk_REP`TotalFnTypeRep (Dom, Rng) ->
          if len Dom = len tp_l
          then
               if len tp_l = 1 and
                  (is_REP`PartialFnTypeRep(hd tp_l) or is_REP`TotalFnTypeRep(hd tp_l)) and
                  (is_REP`PartialFnTypeRep(Rng) or is_REP`TotalFnTypeRep(Rng))
               then CheckHigherOrder(i,hd tp_l, Dom, Rng, vApply)
               else
          (for index = 1 to len Dom do
            reswf := reswf and TYPE`IsCompatible (i, tp_l(index), Dom(index));
          if reswf
          then return mk_(true, Rng) 
          else
              --------------------------------------------------------------
              -- Error message #272
              -- Function is not applied with parameters of the correct type
              --------------------------------------------------------------
            ( if callerr
              then ERR`GenErr (vApply, <ERROR>,272,[]);
              return mk_(false, Rng)))
                ---------------------------------------------------
                -- Error message #273
                -- Function applied with wrong number of parameters
                ---------------------------------------------------
          else (if callerr
                then ERR`GenErr(vApply, <ERROR>,273,[]);
                return mk_(false,Rng)),
        mk_REP`OpTypeRep (Dom, Rng) ->
         (def kind = ENV`GetContext()
          in 
           if kind in set {<PRE>,<POST>}
           then
             -------------------------------
             -- Error message #448
             -- Operation call in pre/post function
             -------------------------------
             ERR`GenErr (vApply, <WARNING>, 448, []);

          if len Dom = len tp_l
          then
            (for index = 1 to len Dom do
              reswf := reswf and TYPE`IsCompatible (i, tp_l(index), Dom(index));

             (if reswf
              then return mk_(true, Rng)
              else
                  --------------------------------------------------------------
                  -- Error message #274
                  -- Operation is not applied with parameters of the correct
                  -- type
                  --------------------------------------------------------------
                ( if callerr
                  then ERR`GenErr (vApply, <ERROR>,274,[]);
                  return mk_(false, Rng))))
                ---------------------------------------------------
                -- Error message #275
                -- Operation applied with wrong number of arguments
                ---------------------------------------------------
          else (if callerr
                then ERR`GenErr(vApply, <ERROR>,275,[]);
                return mk_(false,Rng)))
      end);

  CheckHigherOrder: TYPE`Ind 
                  * REP`TypeRep
                  * seq1 of REP`TypeRep 
                  * REP`TypeRep 
                  * (AS`Expr | AS`StateDesignator)
                  ==> bool * REP`TypeRep
  CheckHigherOrder(i,argtp, Dom, Rng, vApply) ==
    (dcl realdomtp : seq1 of seq1 of REP`TypeRep := [Dom];
     dcl restargtp: REP`TypeRep := argtp;
     dcl restRng : REP`TypeRep := Rng;
     
     while (is_REP`PartialFnTypeRep(restargtp) or is_REP`TotalFnTypeRep(restargtp)) and
           (is_REP`PartialFnTypeRep(restRng) or is_REP`TotalFnTypeRep(restRng)) and
           (let atp = realdomtp(len realdomtp)(1)
            in
              not (is_REP`PartialFnTypeRep(atp) or is_REP`TotalFnTypeRep(atp))) 
     do
       (realdomtp := realdomtp ^ [restRng.fndom];
        restargtp := restargtp.fnrng;
        restRng := restRng.fnrng);

     def reswf = TYPE`IsCompatible(i,argtp,if len realdomtp = 1
                                      then hd hd realdomtp
                                      else CreateFnType(realdomtp))
     in
       if reswf
       then return mk_(true,restRng)
             --------------------------------------------------------------
             -- Error message #272
             -- Function is not applied with parameters of the correct type
             --------------------------------------------------------------
       else (ERR`GenErr(vApply, <ERROR>,272,[]);
             return mk_(false,restRng)))
  pre is_REP`PartialFnTypeRep(argtp) or is_REP`TotalFnTypeRep(argtp)

functions

  CreateFnType: seq of seq1 of REP`TypeRep +> REP`PartialFnTypeRep
  CreateFnType(tp_l_l) ==
    if len tp_l_l > 2
    then mk_REP`PartialFnTypeRep(hd tp_l_l, CreateFnType(tl tp_l_l))
    else mk_REP`PartialFnTypeRep(hd tp_l_l,if len tp_l_l(2) = 1
                                           then hd (tp_l_l(2))
                                           else mk_REP`ProductTypeRep(tp_l_l(2)))
  pre len tp_l_l >= 2

operations

    CheckUnionApply : TYPE`Ind * REP`TypeRep * seq of REP`TypeRep * (AS`Expr | AS`StateDesignator)
                  ==> bool * REP`TypeRep
    CheckUnionApply (i, tp1 , tp_l, vApply) ==
      (dcl reswf :bool := true; 

       let msgtp = if i = <POS> 
                   then <WARNING>
                   else <ERROR>
       in    
      
      cases tp1:
        mk_REP`SeqTypeRep(stp) ->
          if len tp_l = 1
          then 
          if TYPE`IsCompatible (i, hd(tp_l), mk_REP`NumericTypeRep(<NATONE>)) then
            if i = <POS>
            then return mk_(true, stp)
                  ---------------------------------------------------
                  -- Error message #265
                  -- Given index may not exist for the given sequence
                  ---------------------------------------------------
            else (ERR`GenErr(vApply, <ERROR>,265,[]);
                  return mk_(false,stp))
          else
              -----------------------------------------
              -- Error message #268
              -- Sequence index is not a natural number
              -----------------------------------------
            ( ERR`GenErr (vApply, msgtp,268,[]);
              return mk_(false, mk_REP`AllTypeRep()))
                -----------------------------------------------
                -- Error message #266
                -- Sequence is applied with more than one index
                -----------------------------------------------
          else (ERR`GenErr (vApply, msgtp,266,[]);
                return mk_(false, mk_REP`AllTypeRep())),
        mk_REP`GeneralMapTypeRep(Dom, Rng),
        mk_REP`InjectiveMapTypeRep(Dom, Rng) ->
          if len tp_l = 1
          then 
          if TYPE`IsCompatible (i, hd tp_l, Dom) then
            if i = <POS>
            then return mk_(true, Rng)
                  -------------------------------------------------------
                  -- Error message #269
                  -- Given domain element may not exist for the given map
                  -------------------------------------------------------
            else (ERR`GenErr(vApply, <ERROR>,269,[]);
                  return mk_(false,Rng))
          else
              ------------------------------------
              -- Error message #270
              -- Map domain type of incorrect type
              ------------------------------------
            ( ERR`GenErr (vApply, msgtp,270,[]);
              return mk_(false, Rng))
                ------------------------------------------
                -- Error message #271
                -- Map is applied with more than one value
                ------------------------------------------
          else (ERR`GenErr(vApply,msgtp,271,[]);
                return mk_(false, Rng)),
        mk_REP`PartialFnTypeRep (Dom, Rng),
        mk_REP`TotalFnTypeRep (Dom, Rng) ->
          if len Dom = len tp_l
          then
         (for index = 1 to len Dom do
            reswf := reswf and TYPE`IsCompatible (i, tp_l(index), Dom(index));
          if reswf
          then return mk_(true, Rng) 
          else
              --------------------------------------------------------------
              -- Error message #272
              -- Function is not applied with parameters of the correct type
              --------------------------------------------------------------
            ( ERR`GenErr (vApply, msgtp,272,[]);
              return mk_(false, Rng)))
                ---------------------------------------------------
                -- Error message #273
                -- Function applied with wrong number of parameters
                ---------------------------------------------------
          else (ERR`GenErr(vApply,msgtp,273,[]);
                return mk_(false,Rng)),
        mk_REP`OpTypeRep (Dom, Rng) ->
         (--GenOLDErr(<WARNING>,"Operation call in expression");
          if len Dom = len tp_l
          then
            (for index = 1 to len Dom do
              reswf := reswf and TYPE`IsCompatible (i, tp_l(index), Dom(index));

             (if reswf
              then return mk_(true, Rng)
              else
                  --------------------------------------------------------------
                  -- Error message #274
                  -- Operation is not applied with parameters of the correct
                  -- type
                  --------------------------------------------------------------
                ( ERR`GenErr (vApply,msgtp,274,[]);
                  return mk_(false, Rng))))
                ---------------------------------------------------
                -- Error message #275
                -- Operation applied with wrong number of arguments
                ---------------------------------------------------
          else (ERR`GenErr(vApply,msgtp,275,[]);
                return mk_(false,Rng)))
      end);                         

    IsAValidField : AS`Name * REP`CompositeTypeRep ==> bool * REP`TypeRep * [AS`Name] * [AS`Name]  --OK
    IsAValidField (fnm, mk_REP`CompositeTypeRep(tag, flds)) ==
      if tag.ids = []
        -- Wouldn't be better to use an IsEmptyName function ????
        -- Same comment on Name in CompositeTypeRep ????
      then return mk_(true, mk_REP`AllTypeRep (), nil, nil)
      else
      let ftags = { ftag | mk_REP`FieldRep(ftag, -,-) in set elems flds & 
                    ftag <> nil} 
      in if fnm not in set ftags and tag.ids <> []
         then return mk_(false, mk_REP`AllTypeRep (), fnm, tag)
         elseif tag.ids = []  
         then return mk_(false,mk_REP`AllTypeRep(), nil, nil)
         else let mk_REP`FieldRep(ftag, ftp,-) in set elems flds
              be st ftag = fnm in return mk_(true, ftp, nil, nil);

    wf_FieldSelectExpr : TYPE`Ind * AS`FieldSelectExpr * REP`TypeRep ==> bool * REP`TypeRep
    wf_FieldSelectExpr (i, mk_AS`FieldSelectExpr(rec, field, cid), -) ==
      def mk_(wf_arg, argtp) = wf_Expr(i, rec, mk_REP`AllTypeRep())
      in

#ifdef VDMPP
       def ename = mk_AS`Name([],CI`NilContextId);
           ctp = mk_REP`CompositeTypeRep(ename,[]);
           otp = mk_REP`ObjRefTypeRep(ename);
           -------------------------------------------
           objRefComp    = TYPE`IsCompatible(i,argtp, otp);
           compositeComp = TYPE`IsCompatible(i,argtp, ctp)
       in 
         if not (compositeComp or objRefComp) then
            -----------------------------------------------------------------
            -- Error message #277
            -- Expression is not a composite type or an object reference type
            -----------------------------------------------------------------
            ( ERR`GenErr (field,<ERROR>,277,[]);
              return mk_(false, mk_REP`AllTypeRep())
            )
         else if not CheckQualifiedField(i,field,objRefComp,argtp) then 
            return mk_(false, mk_REP`AllTypeRep())
         else
#endif VDMPP
      -- QUESTION: How can the expected type of rec be extracted ????
        (
#ifdef VDMPP
         dcl stat : bool := ENV`GetStatic();
         if (objRefComp)
         then ENV`SetStatic(false);
#endif VDMPP
        def mk_(wf_field, res_tp) = CheckFieldSelect(i,argtp,field,false)
        in
         (
#ifdef VDMPP
          ENV`SetStatic(stat);
#endif VDMPP
          let l_actResTp = if is_(res_tp, REP`TypeRep)
                           then res_tp
                           elseif card res_tp = 1
                           then let {l_v} = res_tp
                                in l_v
#ifdef VDMSL
                           else mk_REP`UnionTypeRep(res_tp)
#endif VDMSL
#ifdef VDMPP
                           else mk_REP`OverTypeRep(res_tp)
#endif VDMPP
          in
           (CI`SetTypeInfo(cid, l_actResTp);
            return mk_(wf_arg and wf_field, l_actResTp))
        ));


#ifdef VDMPP
  CheckQualifiedField: TYPE`Ind * (AS`Name | AS`FctTypeInstExpr) * bool * REP`TypeRep ==> bool 
  CheckQualifiedField(i,field,objRefComp,objtp) ==
    if not (is_AS`Name(field) and len field.ids = 2)
    then return true
    else
      if not objRefComp
      then              
        -------------------------------------
        -- Error message #396
        -- Composite type can not have qualified field
        -------------------------------------
       (ERR`GenErr (field,<ERROR>,396,[]);
        return false;)             
      else 
        def rtp    = AUX`ExtractObjRefType (objtp);
            cls    = cases rtp:
                       mk_REP`ObjRefTypeRep(nm)  -> {nm},
                       mk_REP`UnionTypeRep(utps) ->
                       {nm |  mk_REP`ObjRefTypeRep(nm) in set utps}
	             end;
            qualif = mk_AS`Name([field.ids(1)],CI`NilContextId);
                 --------------------------------------------------
        in
         (dcl qualif_ok : bool;
          if i = <POS>
          then
            qualif_ok := exists cl in set cls & cl = qualif or ENV`IsSubClass(cl,qualif)
          else -- i = <DEF> 
            qualif_ok := forall cl in set cls & cl = qualif or ENV`IsSubClass(cl,qualif);

	  if qualif_ok
          then return true
          else 
            -------------------------------------
            -- Error message #394
            -- Class qualifier "%1" must be a subclass of the object class
            -------------------------------------
           (ERR`GenErr (field,<ERROR>,394,[ENV`PrintName (qualif)]);
            return false);  
         );
#endif VDMPP
\end{vdm_al}

The writable parameter indicates whether the field to be checked also needs to be writable.

\begin{vdm_al}
    CheckFieldSelect: TYPE`Ind * REP`TypeRep * (AS`Name|AS`FctTypeInstExpr) * bool  
                      ==> bool * (REP`TypeRep | set of REP`TypeRep)
#ifdef VDMSL
    CheckFieldSelect(i,rectp,field,-) ==
#endif VDMSL
#ifdef VDMPP
    CheckFieldSelect(i,rectp,field,writable) ==
#endif VDMPP
    ( dcl reswf : bool;
      dcl restp : [REP`TypeRep|set of REP`TypeRep] := nil;
      
      def mk_(wf, tp) = CheckRecordFieldSelect(i,rectp,field) in 
      ( reswf := wf;
        restp := tp );

#ifdef VDMSL
      if restp <> nil then
        return mk_(reswf,restp)
      else
          -------------------------------------
          -- Error message #276
          -- Expression is not a composite type
          -------------------------------------
        ( ERR`GenErr (field,<ERROR>,276,[]);
          return mk_(false, mk_REP`AllTypeRep())
        )
   );
#endif VDMSL

#ifdef VDMPP
      def mk_(wf, tp) = CheckObjRefFieldSelect(i,rectp,field,writable) in 
      ( reswf := reswf or wf;
        if (restp <> nil) and (tp <> nil)
        then restp := AUX`MergeTypes(restp,tp)
        else if wf
             then restp := tp );

       if restp <> nil
       then return mk_(reswf,restp)
       else return mk_(false, mk_REP`AllTypeRep())
    );
#endif VDMPP

    CheckRecordFieldSelect: TYPE`Ind * REP`TypeRep * (AS`Name|AS`FctTypeInstExpr) ==> bool * [REP`TypeRep]
    CheckRecordFieldSelect(i,rectp,field) ==
      (dcl allwf : bool := true;
       dcl onewf : bool := false;
       dcl restp : [REP`TypeRep] := nil;
      
       let ename = mk_AS`Name([],CI`NilContextId) in
       let ctp = mk_REP`CompositeTypeRep(ename,[]) in
        -- Same comment on Name in CompositeTypeRep ????
       if TYPE`IsCompatible(i,rectp, ctp) then
#ifdef VDMPP
         if is_AS`FctTypeInstExpr (field) then
                   -------------------------------
                   -- Error message #367
                   -- Cannot apply polymorphic function "%1" to record field selector
                   -------------------------------
           ( ERR`GenErr (field.polyfct, <ERROR>,367,[ENV`PrintName(field.polyfct)]);
             return mk_(false, mk_REP`AllTypeRep()))
         else
#endif VDMPP
         def rtp = AUX`ExtractCompositeType (rectp) in
           cases rtp:
             mk_REP`CompositeTypeRep(-,-) ->
               def mk_(wf, tp, nvf, tag) = IsAValidField(field, rtp) in
                 if wf then
                   return mk_(wf, tp)
                 else
                   -------------------------------
                   -- Error message #278
                   -- An invalid field is selected
                   -------------------------------
                 ( ERR`GenErr(field, <ERROR>,278,[]); 
                   if nvf <> nil and tag <> nil then
                     -----------------------------------------------------------
                     -- Error message #279
                     -- The field "%1" is not defined for the record tagged with
                     -- "%2"
                     -----------------------------------------------------------
                     ERR`GenErr(nvf, <WARNING>,279,[ENV`PrintName(nvf),ENV`PrintName(tag)]);
                     return mk_(false, mk_REP`AllTypeRep())),
             mk_REP`UnionTypeRep(utps) ->
             ( dcl nvfields : set of (AS`Name * AS`Name) := {};
               for all utp in set utps do
                 def mk_(wf, tp, nvf, tag ) = IsAValidField (field, utp) in
                 ( allwf := allwf and wf;
                   onewf := onewf or wf;
                   restp := if restp = nil and wf
                            then tp
                            else 
                              if wf then AUX`MergeTypes (restp, tp)
                              else restp;
                   if not wf and nvf <> nil and tag <> nil
                   then nvfields := nvfields union {mk_(nvf, tag)});
                   if restp = nil then restp := mk_REP`AllTypeRep ();
                   let reswf = if i = <DEF> then allwf
                               else onewf in
                   ( if not reswf then 
                       -------------------------------
                       -- Error message #278
                       -- An invalid field is selected
                       -------------------------------
                     ( ERR`GenErr(field, <ERROR>,278,[]);
                       for all mk_(nvf, tag) in set nvfields do
                         -------------------------------------------------------
                         -- Error message #279
                         -- The field "%1" is not defined for the record tagged
                         -- with "%2"
                         -------------------------------------------------------
                         ERR`GenErr(nvf, <WARNING>,279,[ENV`PrintName(nvf),ENV`PrintName(tag)]) );
                     return mk_(reswf, restp))),
             nil -> return mk_(false, mk_REP`AllTypeRep ())
           end
       else
         return mk_(false,nil) -- type must only be nil in this case!
    );
\end{vdm_al}

The writable parameter indicates whether the field to be looked up need to be 
writable.

\begin{vdm_al}
#ifdef VDMPP

    CheckObjRefFieldSelect: TYPE`Ind * REP`TypeRep * (AS`Name|AS`FctTypeInstExpr) * bool
                          ==> bool * [REP`TypeRep | set of REP`TypeRep]
    CheckObjRefFieldSelect(i,objtp,field,writable) ==
    ( dcl allwf : bool := true;
      dcl onewf : bool := false;
      dcl restp : [REP`TypeRep | set of REP`TypeRep] := nil;
--      if is_AS`FctTypeInstExpr (field) then 
--                   wf_Expr (i,field, mk_REP`AllTypeRep ());
      let field' = if is_AS`FctTypeInstExpr (field) 
                   then field.polyfct 
                   else field,
          ename = mk_AS`Name([],CI`NilContextId),
          otp = mk_REP`ObjRefTypeRep(ename)
      in
       -- Same comment on Name in CompositeTypeRep ????
      if TYPE`IsCompatible(i,objtp, otp) then
        def rtp = AUX`ExtractObjRefType (objtp) in
          cases rtp:
            mk_REP`ObjRefTypeRep(cls) ->
              def tp' = ENV`LookUpInObject(cls,field',writable,true) in
                if tp' <> nil then
                  def tp = ENV`CheckAccess (cls,tp')
                  in 
                  if tp = nil then
                    ------------------------------
                    -- Error message #368
                    -- Access violation
                    ------------------------------
                    ( ERR`GenErr (field',<ERROR>,368,
                        if len field'.ids = 2 then 
                          [ENV`PrintName(field')]
                        else
                          [ENV`PrintName (cls)^"`"^ENV`PrintName(field')]);
                      return mk_(false,mk_REP`AllTypeRep ()))
                  elseif is_AS`FctTypeInstExpr (field) then
                    let poly = if is_REP`PolyTypeRep(tp) then 
                                 mk_(tp.vars,tp.tp)
                               elseif is_(tp,set of REP`PolyTypeRep) then 
                                 -- at most one element can match 
                                 let poly_set = {pp | pp in set tp & 
                                                 len pp.vars = len field.inst}
                                 in 
                                     if poly_set = {} then 
                                       nil
                                     else 
                                      let pp in set poly_set 
                                      in 
                                          mk_(pp.vars,pp.tp)
                                     else  
                                          nil
                    in
                     (cases poly:
                        mk_(-,t) -> CI`SetTypeInfo(field'.cid, t)
                      end;
                      return CheckFctTypeInst (i,poly,field))

                  else -- field <> FctTypeInstExpr
                    return mk_(true,tp)
                else
                  ----------------------------------------------
                  -- Error message #280
                  -- The field "%1" is not defined in class "%2"
                  ----------------------------------------------
                ( ERR`GenErr(field',<ERROR>,280,[ENV`PrintName(field'),ENV`PrintName(cls)]);
                  return mk_(false, mk_REP`AllTypeRep())),
            mk_REP`UnionTypeRep(utps) ->
              ( dcl nvfields : set of (AS`Name * AS`Name) := {};
                dcl insttp : set of REP`TypeRep := {};
--                dcl onefctwf : bool := false;
		dcl all_acc_wf: bool := true;
		dcl one_acc_wf: bool := false;
                for all mk_REP`ObjRefTypeRep(cls) in set utps do
                  def tp' =  ENV`LookUpInObject(cls,field',false,true) in

                  ( if tp' <> nil then
                      def tp = ENV`CheckAccess (cls,tp') in
                      if tp = nil then
                        (allwf := false;
			 all_acc_wf := false)
                      else -- not tp = nil
                      ( one_acc_wf := true;
		        if is_AS`FctTypeInstExpr (field) then
                          if is_REP`PolyTypeRep (tp) then
                            if len tp.vars = len field.inst then
                            ( onewf := true;
			      def tp' = CheckFctTypeInstAux (mk_(tp.vars,tp.tp),field) in
			      restp := if restp = nil 
                                       then tp' 
                                       else AUX`MergeTypes (restp,tp')
                            )
                            else -- len tp.vars <> field.inst
                            ( insttp := insttp union {tp};
                              allwf := false
                            )
                          elseif is_(tp,set of REP`PolyTypeRep) then 
                            -- at most one element can match 
                            let poly_set = {pp | pp in set tp & len pp.vars = len field.inst}
                            in 
                               if poly_set = {} then
                                 ( insttp := insttp union {tp};
                                   allwf := false
                                  )
                               else 
                                  let pp in set poly_set 
                                  in 
                                     ( onewf := true;
                                       def tp' = CheckFctTypeInstAux (mk_(pp.vars,pp.tp),field) 
                                       in
			                  restp := if restp = nil 
                                                   then tp'  
                                                   else AUX`MergeTypes (restp,tp')
                                     )
                          else -- not PolyTypeRep
                            allwf :=  false
                        else -- not AS`FctTypeInstExpr (field)
                        ( onewf := true;
			  if restp = nil
		          then restp := tp
		          else restp := AUX`MergeTypes (restp, tp)
                        )
                      )
                    else -- not tp' <> nil
                    ( allwf := false;
                      nvfields := nvfields union {mk_(field', cls)} )
                  );
 
                  if restp = nil then restp := mk_REP`AllTypeRep ();
                  let reswf = if i = <DEF> then allwf
                              else onewf in
                  ( if not reswf then 
                      -------------------------------
                      -- Error message #278
                      -- An invalid field is selected
                      -------------------------------
                    ( if card nvfields > 0 then
                      ( ERR`GenErr(field',<ERROR>,278,[]);
                        for all mk_(nvf, cls) in set nvfields do
                          ----------------------------------------------
                          -- Error message #280
                          -- The field "%1" is not defined in class "%2"
                          ----------------------------------------------
                          ERR`GenErr(nvf,<WARNING>,280,[ENV`PrintName(nvf),ENV`PrintName(cls)]) 
                      );
                      if card insttp > 0 then
                        for all t in set insttp do
                          def mk_(-,-) = CheckFctTypeInst (i,mk_(t.vars,t.tp),field) in skip
                      else if is_AS`FctTypeInstExpr (field) then
                        def mk_(-,-) = CheckFctTypeInst (i,nil,field) in skip;
		      if (card nvfields = 0) and 
		         ((i = <DEF> and not all_acc_wf) or (i = <POS> and
		          not one_acc_wf)) then
			  ------------------------------
			  -- Error message #368
			  -- Access violation
			  ------------------------------
			  ERR`GenErr (field',<ERROR>,368,[ENV`PrintName(field')])
			
                    );
                  --return mk_(reswf and if is_AS`FctTypeInstExpr(field) then
                  --           DEF`wf_TypeList (i,field.inst) else true, restp))
                  if is_AS`FctTypeInstExpr(field)
                  then return mk_(reswf and DEF`wf_TypeList (i,field.inst), restp)
                  else return mk_(reswf, restp))
              ),
            nil -> return mk_(false, mk_REP`AllTypeRep())
          end
      else
        return mk_(false,nil)
   );

--CheckObjRefFctTypeInst:
#endif VDMPP

  wf_FctTypeInstExpr: TYPE`Ind * AS`FctTypeInstExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_FctTypeInstExpr(i, fninst, -) ==
#ifdef VDMSL
    def poly = ENV`LookUpPolyFn(fninst.polyfct)
    in
      return CheckFctTypeInst (i,poly,fninst);
#endif VDMSL
#ifdef VDMPP
   (dcl p : [REP`TypeRep| ENV`AccessType| set of (ENV`AccessOpTypeRep | ENV`AccessFnTypeRep | ENV`AccessPolyTypeRep)]
               := ENV`LookUpInObject (ENV`GetCurClass (), fninst.polyfct,false,true);
    if p = nil
    then p := ENV`LookUp (fninst.polyfct, true);
    if p <> nil
    then
      def poly' = ENV`CheckAccessCurClass (p)
      in
        if poly' = nil
        then
          ------------------------------
          -- Error message #368
          -- Access violation
          ------------------------------
         (ERR`GenErr (fninst.polyfct, <ERROR>,368,[ENV`PrintName(fninst.polyfct)]);
          return mk_(false,mk_REP`AllTypeRep ()))
        else
          let poly = if is_REP`PolyTypeRep(poly')
                     then mk_(poly'.vars,poly'.tp)
                     elseif is_(poly',set of REP`PolyTypeRep)
                     then 
                       -- at most one element can match 
                       let poly_set = {pp | pp in set poly' & len pp.vars = len fninst.inst}
                       in 
                         --  if poly_set = {} then 
                         --    nil
                         --  else 
                         --    let pp in set poly_set 
                         --     in 
                         --        mk_(pp.vars,pp.tp)
                         cases poly_set:
                           {} -> nil,
                           {pp} -> mk_(pp.vars,pp.tp),
                           others -> { mk_(pp.vars,pp.tp) | pp in set poly_set }
                         end
                     else nil
          in return CheckFctTypeInst (i,poly,fninst)
    else return CheckFctTypeInst (i,nil,fninst);
   );
#endif VDMPP

#ifdef VDMSL
CheckFctTypeInst : TYPE`Ind * [(seq of REP`TypeVarRep) * REP`FnTypeRep] 
#endif VDMSL
#ifdef VDMPP
CheckFctTypeInst : TYPE`Ind * [((seq of REP`TypeVarRep) * REP`FnTypeRep) |
                               set of ((seq of REP`TypeVarRep) * REP`FnTypeRep)] 
#endif VDMPP
                   * AS`FctTypeInstExpr  ==> bool * REP`TypeRep
CheckFctTypeInst(i,poly,field) ==
  def mk_AS`FctTypeInstExpr(polyfct, inst, cid) = field;
      wf_inst = DEF`wf_TypeList(i,inst)
  in
    if poly = nil
    then 
      --------------------------
      -- Error message #366
      -- Unknown polymorphic identifier "%1"
      --------------------------
      ( ERR`GenErr(polyfct, <ERROR>,366,[ENV`PrintName(polyfct)]);
        CI`SetTypeInfo(cid, mk_REP`AllTypeRep());
        return mk_(false,mk_REP`AllTypeRep()) )
#ifdef VDMPP
    else if is_(poly, set of ((seq of REP`TypeVarRep) * REP`FnTypeRep))
    then
      def t_s = { CheckFctTypeInstAux(e, field) | e in set poly & len inst = len e.#1 }
      in 
        cases t_s:
          {} -> (------------------------------------------
                 -- Error message #281
                 -- All type variables must be instantiated
                 ------------------------------------------
                 (ERR`GenErr(field, <ERROR>,281,[]);
                  return mk_(false,mk_REP`AllTypeRep()))),
          {e} -> return mk_(wf_inst, e),
          others -> return mk_(wf_inst, mk_REP`OverTypeRep(t_s))
        end
#endif VDMPP
    else
      let mk_(tv_l,fntp) = poly
      in
        if len inst <> len tv_l
        then
          ------------------------------------------
          -- Error message #281
          -- All type variables must be instantiated
          ------------------------------------------
          (ERR`GenErr(field, <ERROR>,281,[]);
           let tpbd = {nm |-> mk_REP`AllTypeRep() | mk_REP`TypeVarRep(nm) in set elems tv_l},
               restp = AUX`InstFn(<VAR>,fntp,tpbd)
           in
             (CI`SetTypeInfo(cid, restp);
              return mk_(false,restp)))
        else 
          let tpbd = {nm |-> mk_REP`AllTypeRep() | mk_REP`TypeVarRep(nm) in set elems tv_l},
              restp = AUX`InstFn(<VAR>,fntp,tpbd)
          in
           (CI`SetTypeInfo(polyfct.cid, restp);
            return mk_(wf_inst, CheckFctTypeInstAux (poly,field));
           );

CheckFctTypeInstAux: ((seq of REP`TypeVarRep) * REP`FnTypeRep) * AS`FctTypeInstExpr ==> REP`TypeRep
CheckFctTypeInstAux (mk_(tv_l,fntp),mk_AS`FctTypeInstExpr(-,inst,cid)) == 
  def tp_l = ENV`TransTypeList(nil,inst)
    in
    let tpbd = {let mk_REP`TypeVarRep(nm) = tv_l(index)
                in nm |-> tp_l(index) | index in set inds tp_l}
    in
    let restp = AUX`InstFn(<VAR>,fntp,tpbd) in
    ( CI`SetTypeInfo(cid, restp);
      return restp);  
     
\end{vdm_al}

\subsection{Bracketed Expression}

\begin{vdm_al}
  wf_BracketedExpr : TYPE`Ind * AS`BracketedExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_BracketedExpr(i, mk_AS`BracketedExpr(expr,cid), exptp) ==
    def mk_(wf_e,etp) = wf_Expr(i,expr,exptp) in
    ( CI`SetTypeInfo(cid, etp);
      return mk_(wf_e, etp) );
\end{vdm_al}

\begin{vdm_al}
  wf_Macro : TYPE`Ind * AS`Macro * REP`TypeRep ==> bool * REP`TypeRep
  --wf_Macro(i, mk_AS`Macro(tp,cid), exptp) ==
  wf_Macro(-, mk_AS`Macro(tp,cid), -) ==
    cases tp: -- TODO:
      <MACRO_FILE>, -- for filepp macro processor
      <MACRO_CLMOD>,
      <MACRO_FNOP>   -> def argtp = mk_REP`SeqTypeRep(mk_REP`CharTypeRep());
                            --iscomp = TYPE`IsCompatible(i, argtp, exptp)
                        in
                         (CI`SetTypeInfo(cid, argtp);
                          return mk_(true, argtp)),
      <MACRO_LINE>, -- for filepp macro processor
      <MACRO_COLUMN> -> def argtp = mk_REP`NumericTypeRep(<INTEGER>);
                            --iscomp = TYPE`IsCompatible(i, argtp, exptp)
                        in
                         (CI`SetTypeInfo(cid, argtp);
                          return mk_(true, argtp)),
      others -> error
    end;
\end{vdm_al}

\subsection{Lambda Expression} 

\begin{vdm_al}
  wf_LambdaExpr : TYPE`Ind * AS`LambdaExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_LambdaExpr(i, vLambdaExpr, -) ==
    def mk_AS`LambdaExpr(parms, body, -, cid) = vLambdaExpr;
        mk_(wf_parms,bd,tp_l) = PAT`wf_TypeBindList(i,parms)
    in
      (ENV`EnterScope(bd);
       def mk_(wf_body,tp) = wf_Expr(i,body,mk_REP`AllTypeRep())
       in
         let fntp = mk_REP`PartialFnTypeRep(tp_l, tp)
         in
           (ENV`LeaveScope();
            CI`SetTypeInfo(cid, fntp);
            if wf_parms = nil
            then return mk_(false,fntp)
            elseif not wf_parms
                  -----------------------------------------------
                  -- Error message #282
                  -- No binding is possible in the parameter list
                  -----------------------------------------------
            then (ERR`GenErr(vLambdaExpr, <ERROR>,282,[]);
                  return mk_(false,fntp))
            else return mk_(wf_body,fntp)));
\end{vdm_al}

\subsection{Is Expression}

\begin{vdm_al}

    wf_IsExpr : TYPE`Ind * (AS`IsExpr|AS`TypeJudgementExpr) * REP`TypeRep ==> bool * REP`TypeRep --OK
    wf_IsExpr (i, isexpr, -) ==
      let tp = isexpr.type,
          arg = if is_AS`IsExpr (isexpr) then isexpr.arg else isexpr.expr,
          cid = isexpr.cid,
          restp = mk_REP`BooleanTypeRep()
      in
      ( CI`SetTypeInfo(cid, restp);
        if is_AS`BooleanType (tp) or is_AS`NumericType (tp) or is_AS`TokenType (tp) or is_AS`CharType (tp) or
           is_AS`TypeJudgementExpr (isexpr)
        then
           ( def rep_tp = ENV`TransType(nil,tp);
                 mk_(wf_arg, argtp) = wf_Expr(i,arg,mk_REP`AllTypeRep());
                 iscomp = TYPE`IsCompatible(<POS>, argtp, rep_tp)
             in
               ( if not iscomp then
                   -------------------------------
                   -- Error message #283
                   -- Is-Expr will always be false
                   -------------------------------
                   ERR`GenErr (isexpr, <ERROR>,283,[]); 
                 return mk_(wf_arg and iscomp, restp)))
        else
          def pair = ENV`LookUpTag(i,tp,{})
          in
            if pair = nil
            then
                ----------------------------------------------
                -- Error message #254
                -- Composite type "%1" is not defined in "%2".
                ----------------------------------------------
              ( ERR`GenErr (isexpr, <ERROR>,254,[ENV`PrintName(tp),"Is-Expr"]);
                return mk_(false, restp))
            else
#ifdef VDMSL
             let mk_(newtag,flds) = pair in
#endif VDMSL
#ifdef VDMPP
             def mk_(newtag,flds') = pair;
                 flds = ENV`CheckAccessCurClass (flds')
             in
               if flds = nil
               then
                 ------------------------------
                 -- Error message #368
                 -- Access violation
                 ------------------------------
                 ( ERR`GenErr (newtag,<ERROR>,368,[ENV`PrintName (newtag)]);
                   return mk_(false,restp))
               else
#endif VDMPP
                 def mk_(wf_arg, argtp) = wf_Expr(i,arg,mk_REP`AllTypeRep());
                     iscomp = TYPE`IsCompatible(<POS>, argtp, mk_REP`CompositeTypeRep(newtag, flds))
                 in
                  ( if not iscomp
                    then
                      -------------------------------
                      -- Error message #283
                      -- Is-Expr will always be false
                      -------------------------------
                      ERR`GenErr (arg,<ERROR>,283,[]); 
                    return mk_(wf_arg and iscomp, restp)) );
        -- QUESTION: Is this correct ????

\end{vdm_al}

\subsection{Narrow Expression}

\begin{vdm_al}
wf_NarrowExpr : TYPE`Ind * AS`NarrowExpr * REP`TypeRep ==> bool * REP`TypeRep
wf_NarrowExpr (i, mk_AS`NarrowExpr(expr,tp,cid), -) ==
  def rep_tp = ENV`TransType(nil,tp)
  in
   (CI`SetTypeInfo(cid, rep_tp);
    def mk_(wf_arg, argtp) = wf_Expr(i,expr,mk_REP`AllTypeRep());
        iscomp = TYPE`IsCompatible(i, rep_tp, argtp)
    in if not iscomp
       then
        (-------------------------------
         -- Error message #446
         -- Narrow-Expr will always be fail
         -------------------------------
         ERR`GenErr (mk_AS`NarrowExpr(expr,tp,cid),<ERROR>,446,[]); 
         return mk_(false, mk_REP`AllTypeRep()))
       else
         return mk_(wf_arg and iscomp, rep_tp));
\end{vdm_al}

#ifdef VDMPP
\subsection{New and Self Expressions} 

\begin{vdm_al}
  wf_SelfExpr : TYPE`Ind * AS`SelfExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_SelfExpr(-, mk_AS`SelfExpr(cid), -) ==
    def ortr = mk_REP`ObjRefTypeRep(ENV`GetCurClass()) in
    if ENV`GetStatic()
    then
    --------------------------------------------
    -- Error message #379
    -- Can not use self expression in a static class member
    --------------------------------------------
    ( ERR`GenErr(mk_AS`SelfExpr(cid), <ERROR>, 379, []);
      return mk_(false, ortr) )
    else
    ( CI`SetTypeInfo(cid, ortr);
      return mk_(true, ortr) );

  wf_NewExpr: TYPE`Ind * AS`NewExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_NewExpr(i,mk_AS`NewExpr(nm', exprs, cid), exptp) ==
    def nm = def mk_(ok, cl) = ENV`ExpandClassName(nm',{})
             in if ok then cl else nm'
    in
    if ENV`CheckClassName(nm)
    then 
#ifdef VICE
      if CpuOrBusOutSideSys(nm)
      then if nm.ids = ["CPU"]
           then 
          --------------------------------------------
          -- Error message #408
          -- Instances of CPU can only be made in a system class
          --------------------------------------------
          ( ERR`GenErr(nm,<ERROR>,408,[]);
            return mk_(false, mk_REP`ObjRefTypeRep(nm))
          )
          else 
          --------------------------------------------
          -- Error message #409
          -- Instances of BUS can only be made in a system class
          --------------------------------------------
          ( ERR`GenErr(nm,<ERROR>,409,[]);
            return mk_(false, mk_REP`ObjRefTypeRep(nm))
          )
      elseif VCM`IsSysClass(nm)
      then 
          --------------------------------------------
          -- Error message #410
          -- Instances of system classes cannot be made: "%1"
          --------------------------------------------
          ( ERR`GenErr(nm,<ERROR>,410,[ENV`PrintName(nm)]);
            return mk_(false, mk_REP`ObjRefTypeRep(nm))
          )
      else
#endif VICE
      if not ENV`CheckSubRespIsImplemented(i,nm)
      then
          --------------------------------------------
          -- Error message #395
          -- Abstract class "%1" can not be instantiated
          --------------------------------------------
          ( ERR`GenErr(nm,<ERROR>,395,[ENV`PrintName(nm)]);
            return mk_(false, mk_REP`ObjRefTypeRep(nm))
          )
      else 
      if exprs = [] 
      then 
        -- If no arguments are given, then this is a call to the
        -- default constructor. However we need to check that this is
        -- still visible i.e. it could have been redefined as a
        -- private or protected operation.
        if not ENV`DefaultConstructorAccessible(nm)
        then 
          --------------------------------------------
          -- Error message #389
          -- Default constructor not in scope
          --------------------------------------------
          ( ERR`GenErr(nm,<ERROR>,389,[ENV`PrintName(nm)]);
            return mk_(false, mk_REP`ObjRefTypeRep(nm))
          )
        else
          let tprep = mk_REP`ObjRefTypeRep(nm),
              optp = mk_REP`OpTypeRep([],mk_REP`TypeNameRep(nm))
          in
          (  CI`SetTypeInfo(nm.cid,optp);
             CI`SetTypeInfo(cid, tprep);
             def iscomp = TYPE`IsCompatible(<POS>, tprep, exptp) in
               ( if not iscomp then
                   -------------------------------
                   -- Error message #397
                   -- Value is not type-compatible
                   -------------------------------
                   ERR`GenErr (nm, <ERROR>,397,[]);
                return mk_(iscomp, tprep) ))
      else
      def l_argseq = [wf_Expr(i, exprs(j), mk_REP`AllTypeRep()) | j in set inds exprs];
          l_wf_arg = forall mk_(b_wf,-) in set elems l_argseq & b_wf;
          l_argtpL = [l_argseq(j).#2 | j in set inds l_argseq] 
      in 
     (ENV`SetDefClass(nm);
      if not ENV`ConstructorExists(i, nm, l_argtpL, nm) 
      then
         --------------------------------------------
         -- Error message #388
         -- No matching constructor could be found in this class or 
         -- its super classes
         --------------------------------------------
         ( ERR`GenErr(nm,<ERROR>,388,[]);
           ENV`SetDefClass(nil);
           return mk_(false, mk_REP`ObjRefTypeRep(nm))
         )
      else
          let tprep = mk_REP`ObjRefTypeRep(nm),
              optp = mk_REP`OpTypeRep(l_argtpL,mk_REP`TypeNameRep(nm))
          in
          (  CI`SetTypeInfo(nm.cid,optp);
             CI`SetTypeInfo(cid, tprep);
             ENV`SetDefClass(nil);
             return mk_(l_wf_arg, tprep) )
      )
          --------------------------------
          -- Error message #284
          -- "%1" is not an existing class
          --------------------------------
    else (ERR`GenErr(nm,<ERROR>,284,[ENV`PrintName(nm)]);
          return mk_(false, mk_REP`ObjRefTypeRep(nm)));

#ifdef VICE
CpuOrBusOutSideSys: AS`Name ==> bool
CpuOrBusOutSideSys(nm) ==
  return (nm.ids = ["CPU"] or nm.ids = ["BUS"]) and not VCM`IsSysClass(ENV`GetCurClass());
#endif VICE

wf_ThreadIdExpr: TYPE`Ind * AS`ThreadIdExpr * REP`TypeRep ==> bool * REP`TypeRep
wf_ThreadIdExpr (-,-,-) ==
  return mk_(true,mk_REP`NumericTypeRep(<NAT>));
#ifdef VICE
wf_CurTimeExpr: TYPE`Ind * AS`CurTimeExpr * REP`TypeRep ==> bool * REP`TypeRep
wf_CurTimeExpr (-,-,-) ==
  return mk_(true,mk_REP`NumericTypeRep(<NAT>));
#endif VICE
\end{vdm_al}

\subsection{Class Expressions} 

\begin{vdm_al}

wf_SameClassExpr: TYPE`Ind * (AS`SameBaseClassExpr|AS`SameClassExpr) * REP`TypeRep ==> bool * REP`TypeRep
wf_SameClassExpr(i, expr, -) ==
  def objtp = mk_REP`ObjRefTypeRep(mk_AS`Name([],CI`NilContextId));
      mk_(wf_exp1, tp_exp1) = wf_Expr(i, expr.expr1, objtp);
      mk_(wf_exp2, tp_exp2) = wf_Expr(i, expr.expr2, objtp);
      isobj1 = TYPE`IsCompatible(i,tp_exp1,objtp);
      isobj2 = TYPE`IsCompatible(i,tp_exp2,objtp);
      btp = mk_REP`BooleanTypeRep()
  in
   (if not isobj1 then 
      ---------------------------------------------
      -- Error message #285
      -- Expression must return an object reference
      ---------------------------------------------
      ERR`GenErr(expr.expr1,<ERROR>,285,[]);
    if not isobj2 then
      ---------------------------------------------
      -- Error message #285
      -- Expression must return an object reference
      ---------------------------------------------
      ERR`GenErr(expr.expr2, <ERROR>,285,[]);
    CI`SetTypeInfo(expr.cid, btp);
    return mk_(wf_exp1 and wf_exp2 and isobj1 and isobj2, btp)
   );

wf_IsOfClassExpr : TYPE`Ind * (AS`IsOfClassExpr|AS`IsOfBaseClassExpr) * REP`TypeRep ==> bool * REP`TypeRep
wf_IsOfClassExpr(i, expr, -) ==
  def cls = expr.cls;
      arg = expr.arg;
      objtp = mk_REP`ObjRefTypeRep(cls);
      btp = mk_REP`BooleanTypeRep();
      mk_(wf_e,tp_e) = wf_Expr(i,arg,objtp);
      wf_class = ENV`CheckClassName(cls);
      --iscomp = TYPE`IsCompatible(i,tp_e,objtp)
      iscomp = TYPE`IsCompatible(<POS>,tp_e,objtp)
  in
   (if not iscomp then 
      -------------------------------------------------------------------
      -- Error message #286
      -- Expression is not compatible with object reference of class "%1"
      -------------------------------------------------------------------
      ERR`GenErr(expr, <ERROR>,286,[ENV`PrintName(cls)]);
    if not wf_class then 
      --------------------------
      -- Error message #287
      -- Class "%1" is undefined
      --------------------------
      ERR`GenErr(cls, <ERROR>,287,[ENV`PrintName(cls)]);
    CI`SetTypeInfo(expr.cid, btp);
    return mk_(wf_e and wf_class and iscomp, btp)
   );

\end{vdm_al}

\subsection{Permission Expressions}
These expressions are only allowed in the guard condition for 
permission predicates.

\begin{vdm_al}
  
  wf_NameList: seq1 of AS`Name ==> bool * REP`TypeRep
  wf_NameList (name_l) ==
   (dcl reswf : bool := true,
        prev_nm : set of AS`Name := {};
    for name in name_l do
    if name = ENV`GetCurClass()
    then
     (------------------------
      -- Error message #431
      -- History counters cannot be used for constructors like "%1"
      ------------------------
      ERR`GenErr (name, <ERROR>,431,[ENV`PrintName(name)]);
      reswf := false
     )
    else
     (def mthtp = ENV`LookUpOperationName (nil, name, nil)
      in
       (if mthtp = {}
        then
          --------------------------------
          -- Error message #28
          -- Operation "%1" is not defined
          --------------------------------
         (ERR`GenErr (name, <ERROR>,28,[ENV`PrintName(name)]);
          reswf := false)
        else
         (if is_(mthtp,set of (ENV`AccessOpTypeRep | ENV`AccessFnTypeRep)) and
             card mthtp > 1
          then
            --------------------------------
            -- Error message #423
            -- Overloaded operation "%1" used in permission guard
            --------------------------------
            ERR`GenErr (name, <WARNING>,423,[ENV`PrintName (name)]);
          if is_(mthtp,set of ENV`AccessFnTypeRep)
          then
            --------------------------------
            -- Error message #429
            -- History counters cannot be used for functions like "%1"
            --------------------------------
           (ERR`GenErr (name, <ERROR>,429,[ENV`PrintName(name)]);
            reswf := false);
           for all tp in set mthtp do
             cases tp:
               mk_ENV`AccessOpTypeRep(-,-,-,true) -> 
                  --------------------------------
                  -- Error message #574
                  -- History counters cannot be used for pure operation like "%1"
                  --------------------------------
                 (ERR`GenErr (name, <ERROR>,457,[ENV`PrintName(name)]);
                  reswf := false),
               others -> skip
             end;
         );
        if name in set prev_nm
        then
          ------------------------------------
          -- Warning message #73
          -- "%1" multiple defined in namelist
          ------------------------------------
          ERR`GenErr (name,<WARNING>,73,[ENV`PrintName (name)])
        else
          prev_nm := prev_nm union {name};
       );
     );
    return mk_(reswf, mk_REP`NumericTypeRep (<NAT>))
  );


  wf_ActExpr : TYPE`Ind * AS`ActExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_ActExpr (-, nnm , -) ==
  let mk_AS`ActExpr (name_l, cid) = nnm,
      ntp = mk_REP`NumericTypeRep(<NAT>)
  in
    if ENV`GetContext () = <PERM> then
      (CI`SetTypeInfo(cid, ntp);
       return wf_NameList(name_l))
    else
        -------------------------------------------------
        -- Error message #288
        -- Act-Expr only allowed in permission predicates
        -------------------------------------------------
      ( ERR`GenErr (nnm, <ERROR>,288,[]);
        return mk_(false, mk_REP`NumericTypeRep (<NAT>))
      );


  wf_FinExpr : TYPE`Ind * AS`FinExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_FinExpr (-, nnm, -) ==
  let mk_AS`FinExpr (name_l, cid) = nnm,
      ntp = mk_REP`NumericTypeRep(<NAT>)
  in 
    if ENV`GetContext () = <PERM> then
      (CI`SetTypeInfo(cid, ntp);
       return wf_NameList (name_l))
    else
        -------------------------------------------------
        -- Error message #289
        -- Fin-Expr only allowed in permission predicates
        -------------------------------------------------
      ( ERR`GenErr (nnm, <ERROR>,289,[]);
        return mk_(false, mk_REP`NumericTypeRep (<NAT>))
      );

  wf_ActiveExpr : TYPE`Ind * AS`ActiveExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_ActiveExpr (-, nnm, -) ==
  let mk_AS`ActiveExpr (name_l, cid) = nnm,
      ntp = mk_REP`NumericTypeRep(<NAT>)
  in 
    if ENV`GetContext () = <PERM> then
      (CI`SetTypeInfo(cid, ntp);
       return wf_NameList (name_l))
    else
        -------------------------------------------------
        -- Error message #288
        -- Active-Expr only allowed in permission predicates
        -------------------------------------------------
      ( ERR`GenErr (nnm, <ERROR>,411,[]);
        return mk_(false, mk_REP`NumericTypeRep (<NAT>))
      );

  wf_WaitingExpr : TYPE`Ind * AS`WaitingExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_WaitingExpr (-, nnm, -) ==
   let mk_AS`WaitingExpr (name_l, cid) = nnm,
      ntp = mk_REP`NumericTypeRep(<NAT>)
   in
    if ENV`GetContext () = <PERM> then
      (CI`SetTypeInfo(cid, ntp);
       return wf_NameList (name_l))
    else
        -----------------------------------------------------
        -- Error message #290
        -- Waiting-Expr only allowed in permission predicates
        -----------------------------------------------------
      ( ERR`GenErr (nnm, <ERROR>,290,[]);
        return mk_(false, mk_REP`NumericTypeRep (<NAT>))
      );

  wf_ReqExpr : TYPE`Ind * AS`ReqExpr * REP`TypeRep ==> bool * REP`TypeRep
  wf_ReqExpr (-, nnm, -) ==
  let mk_AS`ReqExpr (name_l, cid) = nnm,
      ntp = mk_REP`NumericTypeRep(<NAT>)
  in
    if ENV`GetContext () = <PERM> then
      (CI`SetTypeInfo(cid, ntp);
       return wf_NameList (name_l))
    else
        -------------------------------------------------
        -- Error message #291
        -- Req-Expr only allowed in permission predicates
        -------------------------------------------------
      ( ERR`GenErr (nnm, <ERROR>,291,[]);
        return mk_(false, mk_REP`NumericTypeRep (<NAT>))
      );

\end{vdm_al}
#endif VDMPP

\subsection{Names}

The function \texttt{wf\_Name} could return as second tuple component
either a single type or a set of types (if the name is overloaded).
\begin{vdm_al}
  wf_Name : TYPE`Ind * AS`Name ==> bool * REP`TypeRep
  wf_Name (-, nm) ==
   (
      def mk_AS`Name(-,cid) = nm;
          restp = ENV`LookUp (nm, true)
      in
        if restp = nil
        then
         ( --GenOLDErr (<ERROR>, "Undefined identifier "^ENV`PrintName(nm));
          CI`SetTypeInfo(cid, mk_REP`AllTypeRep());
          return mk_(false, mk_REP`AllTypeRep()))
        else
#ifdef VDMSL
         (CI`SetTypeInfo(cid, restp);
          return mk_(true, restp));
#endif VDMSL
#ifdef VDMPP
          --def reptp = ENV`CheckAccess (nm,restp)
          def reptp = ENV`CheckAccessCurClass (restp)
          in 
            if reptp = nil
            then
              ---------------------
              -- Error message #368
              -- Access violation
              ---------------------
             (ERR`GenErr(nm, <ERROR>,368,[ENV`PrintName (nm)]);
              return mk_(false,mk_REP`AllTypeRep()))
            else
             (let l_actResTp = if is_(reptp, REP`TypeRep)
                               then reptp
                               elseif card reptp = 1
                               then
                                 let {l_v} = reptp
                                 in l_v
                               --else mk_REP`UnionTypeRep(reptp)
                               else mk_REP`OverTypeRep(reptp)
              in
               (CI`SetTypeInfo(cid, l_actResTp);
                return mk_(true, l_actResTp)
               )
             );
#endif VDMPP
   );
\end{vdm_al}

Note that old-names can only be used in the post context (i.e.\ in
some kind of post-condition).

\begin{vdm_al}

    wf_OldName : TYPE`Ind * AS`OldName ==> bool * REP`TypeRep --OK
    wf_OldName (-, onm) ==
    let mk_AS`OldName(id_l,cid) = onm
    in
      if ENV`GetContext() <> <POST>
        -------------------------------------------
        -- Error message #292
        -- Old names cannot be used in this context
        -------------------------------------------
      then (ERR`GenErr(onm, <ERROR>,292,[]);
            CI`SetTypeInfo(cid, mk_REP`AllTypeRep());
            return mk_(false,mk_REP`AllTypeRep()))
      else
       def restp = ENV`LookUpState(mk_AS`Name(id_l,cid),true,<OLD>) in 
        if restp = nil then
          ( CI`SetTypeInfo(cid, mk_REP`AllTypeRep());            
            return mk_(false, mk_REP`AllTypeRep()) )
        else
#ifdef VDMPP
            if ENV`IsAccessType(restp)
            then let restp2 = restp.tp
                 in
                  (CI`SetTypeInfo(cid, restp2);
                   return mk_(true, restp2) )
            else
#endif VDMPP
          ( 
            CI`SetTypeInfo(cid, restp);
            return mk_(true, restp) );
\end{vdm_al}

In the $wf-Literal$ operation it is taken into account that the
abstract syntax indicate that a numeric literal can be an integer.
However, the scanner and parser is made such that only positive number
can occur as numeric literal and thus a small amount of optemisation
can be done here.

\begin{vdm_al}
    wf_Literal : TYPE`Ind * AS`Literal * REP`TypeRep ==> bool * REP`TypeRep --OK rettet
    wf_Literal (i, lit,exptp) ==
      let mk_(restp,cid) = 
          cases lit :
            mk_AS`BoolLit(-,cid)    -> mk_(mk_REP`BooleanTypeRep(),cid),
            mk_AS`CharLit(-,cid)    -> mk_(mk_REP`CharTypeRep(),cid),
            --mk_AS`RealLit(val,cid)  -> if is_nat1(val)
            --                           then mk_(mk_REP`NumericTypeRep(<NATONE>),cid)
            --                           else if is_nat(val)
            --                           then mk_(mk_REP`NumericTypeRep(<NAT>),cid)
            --                           else if is_int(val)
            --                           then mk_(mk_REP`NumericTypeRep(<INTEGER>),cid)
            --                           else mk_(mk_REP`NumericTypeRep(<REAL>),cid),
            mk_AS`RealLit(-,cid)    -> mk_(mk_REP`NumericTypeRep(<REAL>),cid),
            mk_AS`NumLit(val,cid)   -> if is_nat1(val)
                                       then mk_(mk_REP`NumericTypeRep(<NATONE>),cid)
                                       else if is_nat(val)
                                       then mk_(mk_REP`NumericTypeRep(<NAT>),cid)
                                       else mk_(mk_REP`NumericTypeRep(<INTEGER>),cid),
            mk_AS`QuoteLit(nm,cid)  -> mk_(mk_REP`QuoteTypeRep(mk_AS`Name([nm],CI`NilContextId)), cid),
                -- See previous comment on Name in QuoteLit
            mk_AS`NilLit(cid)       -> mk_(mk_REP`NilTypeRep(),cid),
            mk_AS`TextLit(cl,cid)   -> if cl= []
                                       then mk_(mk_REP`EmptySeqTypeRep(mk_REP`CharTypeRep()),cid)
                                       else mk_(mk_REP`SeqTypeRep(mk_REP`CharTypeRep()),cid)
          end
    in ( CI`SetTypeInfo(cid, restp);
         if TYPE`IsCompatible(i,restp,exptp)
         then return mk_(true, restp)
	 else (ERR`GenErr(lit, <ERROR>,397,[]);
	       return mk_(false,restp)));

end EXPR
\end{vdm_al}

\subsection{Test Coverage}

\begin{rtinfo}[MotGeneralNumericType]
{rtinfo.ast}[EXPR]
\end{rtinfo}
