/***
*  * WHAT
*  *    Interpreter. Error reporting functions.
*  * FILE
*  *    $Source: /mnt/cvsroot/toolbox/code/eval/rt_errmsg.cc,v $
*  * VERSION
*  *    $Revision: 1.61 $
*  * DATE
*  *    $Date: 2006/09/22 11:14:06 $
*  * FORMAT
*  *    $State: Exp $
*  * PROJECT
*  *    VDM-SL Toolbox
*  * STATUS 
*  *    Under development.
*  * AUTHOR
*  *    $Author: vdmtools $
*  * COPYRIGHT
*  *    (C) Kyushu University
***/

#include "rt_errmsg.h"
#include "RTERR.h"

string RTERR::GetErrorMessageJP(int num)
{
  switch (num) {
//    case RTERR_BOOL_EXPECTED:        return "A boolean was expected.";
    case RTERR_BOOL_EXPECTED:        return "1つのブール値が必要です";
//    case RTERR_INT_EXPECTED:         return "An integer was expected.";
    case RTERR_INT_EXPECTED:         return "1つの整数が必要です";
//    case RTERR_NUM_EXPECTED:         return "A number was expected";
    case RTERR_NUM_EXPECTED:         return "1つの数が必要です";
//    case RTERR_SET_EXPECTED:         return "A set was expected";
    case RTERR_SET_EXPECTED:         return "1つの集合が必要です";
//    case RTERR_SEQ_EXPECTED:         return "A sequence was expected";
    case RTERR_SEQ_EXPECTED:         return "1つの列が必要です";
//    case RTERR_REC_EXPECTED:         return "A record was expected";
    case RTERR_REC_EXPECTED:         return "1つのレコードが必要です";
//    case RTERR_MAP_EXPECTED:         return "A map was expected";
    case RTERR_MAP_EXPECTED:         return "1つの写像が必要です";
//    case RTERR_TUPLE_EXPECTED:       return "A tuple was expected";
    case RTERR_TUPLE_EXPECTED:       return "1つの組が必要です";
//    case RTERR_SYMB_LIT_EXPECTED:    return "A symbolic literal was expected";
    case RTERR_SYMB_LIT_EXPECTED:    return "1つの記号リテラルが必要です";
//    case RTERR_TWO_BOOL_EXPECTED:    return "Two booleans were expected";
    case RTERR_TWO_BOOL_EXPECTED:    return "2つのブール値が必要です";
//    case RTERR_TWO_INT_EXPECTED:     return "Two integers were expected";
    case RTERR_TWO_INT_EXPECTED:     return "2つの整数が必要です";
//    case RTERR_TWO_NUM_EXPECTED:     return "Two numbers were expected";
    case RTERR_TWO_NUM_EXPECTED:     return "2つの数が必要です";
//    case RTERR_TWO_SET_EXPECTED:     return "Two sets were expected";
    case RTERR_TWO_SET_EXPECTED:     return "2つの集合が必要です";
//    case RTERR_TWO_SEQ_EXPECTED:     return "Two sequences were expected";
    case RTERR_TWO_SEQ_EXPECTED:     return "2つの列が必要です";
//    case RTERR_MAP_OR_SEQ_EXPECTED:  return "A map or a sequence was expected";
    case RTERR_MAP_OR_SEQ_EXPECTED:  return "1つの写像か列が必要です";
//    case RTERR_TWO_MAP_EXPECTED:     return "Two maps were expected";
    case RTERR_TWO_MAP_EXPECTED:     return "2つの写像が必要です";
//    case RTERR_SET_AND_MAP_EXPECTED: return "A set and a map were expected";
    case RTERR_SET_AND_MAP_EXPECTED: return "1つの集合か列が必要です";
//    case RTERR_SEQ_AND_INT_EXPECTED: return "A sequence and two integers were expected";
    case RTERR_SEQ_AND_INT_EXPECTED: return "1つの列と2つの整数が必要です";
//    case RTERR_PATTERNNAME_EXPECTED: return "The binding pattern must evaluate to one patternname";
    case RTERR_PATTERNNAME_EXPECTED: return "束縛パターンは1つのパターン名にならなければなりません";
//    case RTERR_CHAR_EXPECTED:        return "A char was expected";
    case RTERR_CHAR_EXPECTED:        return "1つの文字が必要です";
//    case RTERR_ALL_INTS_EXPECTED:    return "The binding set can only contain integers";
    case RTERR_ALL_INTS_EXPECTED:    return "束縛集合は、整数だけを含むことができます";
//    case RTERR_ALL_NUMS_EXPECTED:    return "The indices for the loop must all be numbers";
    case RTERR_ALL_NUMS_EXPECTED:    return "ループの索引はすべて数でなければなりません";
//    case RTERR_ALL_SETS_EXPECTED:    return "All elements to 'dunion' or 'dinter' must be sets";
    case RTERR_ALL_SETS_EXPECTED:    return "'dunion'または 'dinter'のすべての要素は、集合でなければなりません";
//    case RTERR_ALL_SEQS_EXPECTED:    return "All elements to 'conc' must be sequences";
    case RTERR_ALL_SEQS_EXPECTED:    return "'conc'のすべての要素は、列でなければなりません";
//    case RTERR_ALL_MAPS_EXPECTED:    return "All elements to 'merge' must be maps";
    case RTERR_ALL_MAPS_EXPECTED:    return "'merge'のすべての要素は、写像でなければなりません";
//    case RTERR_OLDID_NOT_IN_OS:      return "The old name is not stored in the state";
    case RTERR_OLDID_NOT_IN_OS:      return "旧名称は状態に格納できません";
//    case RTERR_MAP_MERGE_DOM_OVERLAP: return "Duplicate entries for 'merge' had different values";
    case RTERR_MAP_MERGE_DOM_OVERLAP: return "'merge'で、重複する要素が異なる値を持ちます";
//    case RTERR_EMPTY_ENV_S:          return "The binding environment was empty";
    case RTERR_EMPTY_ENV_S:          return "束縛環境が空です";
//    case RTERR_ZERO_BY_STEP:         return "Step length in loop was 0";
    case RTERR_ZERO_BY_STEP:         return "ループのステップ幅が0です";
//    case RTERR_EVAL_PRE_GIVES_FALSE: return "The pre-condition evaluated to false";
    case RTERR_EVAL_PRE_GIVES_FALSE: return "事前条件の評価結果がfalseです";
//    case RTERR_EVAL_POST_GIVES_FALSE: return "The post-condition evaluated to false";
    case RTERR_EVAL_POST_GIVES_FALSE: return "事後条件の評価結果がfalseです";
//    case RTERR_ERROR_STATEMENT:      return "Can not evaluate 'error' statement";
    case RTERR_ERROR_STATEMENT:      return "'error'文は評価できません";
//    case RTERR_UNDEFINED_EXPRESSION: return "Can not evaluate 'undefined' expression";
    case RTERR_UNDEFINED_EXPRESSION: return "'undefined'式は評価できません";
//    case RTERR_NO_OTHERS_EXPR:       return "No 'others' branch in 'cases' expr";
    case RTERR_NO_OTHERS_EXPR:       return "'cases'式に'others'部がありません";
//    case RTERR_WRONG_QUANTIFIER:     return "Wrong quantifier";
    case RTERR_WRONG_QUANTIFIER:     return "おかしな限量式です";
//    case RTERR_PAT_NAME_IN_SEQCOMP:  return "Only pattern name is allowed in sequence comprehension";
    case RTERR_PAT_NAME_IN_SEQCOMP:  return "列内包ではパターン名のみ許されます";
//    case RTERR_ILLEGAL_INDICES:      return "Illegal index";
    case RTERR_ILLEGAL_INDICES:      return "許されない索引です";
//    case RTERR_DUPLICATES_NOT_EQUAL: return "Duplicate entries had different values";
    case RTERR_DUPLICATES_NOT_EQUAL: return "重複要素は異なる値を持ちます";
////    case RTERR_RECORD_TAG_UNKNOWN:   return "Unknown record tag";
//    case RTERR_RECORD_SIZE_WRONG:    return "Actual record size different from definition";
    case RTERR_RECORD_SIZE_WRONG:    return "実際のレコードサイズが、定義と異なります";
//    case RTERR_RECORD_FIELD_ID_UNKNOWN: return "Unknown record field selector";
    case RTERR_RECORD_FIELD_ID_UNKNOWN: return "未知のレコード項目選択子です";
//    case RTERR_ARG_NOT_IN_DOM:       return "Argument not found in map domain";
    case RTERR_ARG_NOT_IN_DOM:       return "写像の定義域に引数がありません";
//    case RTERR_FCT_V_TYPE_EXPECTED:  return "An explicit function/operation was expected";
    case RTERR_FCT_V_TYPE_EXPECTED:  return "1つの陽関数／陽操作が必要です";
//    case RTERR_UNDEF_ENCOUNTERED:    return "Identifier is undefined/not initialized";
    case RTERR_UNDEF_ENCOUNTERED:    return "識別子が未定義か、初期化されていません";
//    case RTERR_ID_UNKNOWN:           return "Unknown identifier";
    case RTERR_ID_UNKNOWN:           return "未知の識別子です";
//    case RTERR_OPERATOR_UNKNOWN:     return "Unknown operator";
    case RTERR_OPERATOR_UNKNOWN:     return "未知の操作です";
//    case RTERR_DIVISION_WITH_ZERO:   return "Division with zero";
    case RTERR_DIVISION_WITH_ZERO:   return "割り算の分母が0です";
//    case RTERR_ZERO_LENGTH_DETECTED: return "The sequence was empty";
    case RTERR_ZERO_LENGTH_DETECTED: return "列が空です";
//    case RTERR_PATTERN_UNKNOWN:      return "Unknown pattern";
    case RTERR_PATTERN_UNKNOWN:      return "未知のパターンです";
//    case RTERR_SET_TOO_BIG:          return "Set too big for 'power' - limit is 25";
    case RTERR_SET_TOO_BIG:          return "'power'に与える集合が大きすぎます：要素数25個が最大です";
//    case RTERR_EXPR_UNKNOWN:         return "Expression unknown";
    case RTERR_EXPR_UNKNOWN:         return "未知の式です";
//    case RTERR_WRONG_NO_OF_ARGS:     return "Wrong number of arguments";
    case RTERR_WRONG_NO_OF_ARGS:     return "引数の数が合いません";
//    case RTERR_STMT_UNKNOWN:         return "Unknown statement";
    case RTERR_STMT_UNKNOWN:         return "未知の文です";
//    case RTERR_REF_UNKNOWN:          return "Unknown reference in assign statement";
    case RTERR_REF_UNKNOWN:          return "代入文中で、未知の参照があります";
//    case RTERR_TYPE_UNKNOWN:         return "Unknown type";
    case RTERR_TYPE_UNKNOWN:         return "未知の型です";
//    case RTERR_IS_TYPE_UNKNOWN:      return "Unknown type in is_ expression";
    case RTERR_IS_TYPE_UNKNOWN:      return "is_式中に、未知の型があります";
//    case RTERR_IDENTICAL_FIELDS:     return "identical selector names in composite type";
    case RTERR_IDENTICAL_FIELDS:     return "レコード型中に、同一の選択子名があります";
//    case RTERR_TYPE_INCOMP:          return "Incompatible types found in dynamic type check";
    case RTERR_TYPE_INCOMP:          return "動的型チェック中に、矛盾する型が見つかりました";
//    case RTERR_STATE_INVARIANT_ERROR: return "State invariant was broken";
    case RTERR_STATE_INVARIANT_ERROR: return "状態の不変条件が破られました";
//    case RTERR_TAG_MULTIPLE_DEF:     return "Multiple definitions of tag";
    case RTERR_TAG_MULTIPLE_DEF:     return "タグの多重定義です";
//    case RTERR_NO_UNIQ_ELEM:         return "No unique element in 'iota'";
    case RTERR_NO_UNIQ_ELEM:         return "'iota'式で唯一の要素が得られません";
//    case RTERR_OP_EXIT_CONT:         return "Operation exited or returned no result";
    case RTERR_OP_EXIT_CONT:         return "操作が例外を発生したか、値を返しませんでした";
//    case RTERR_NO_POLY_FUNC:         return "Instantiated function is not polymorphic";
    case RTERR_NO_POLY_FUNC:         return "具体化される関数が多相関数ではありません";
//    case RTERR_NO_INJECTIVE_MAP:     return "Map is not injective - 'inverse' fails";
    case RTERR_NO_INJECTIVE_MAP:     return "写像が1対1写像ではなく、'invers'が失敗しました";
//    case RTERR_NOT_RNG_DOM_SUBSET:   return "The range is not a subset of the domain";
    case RTERR_NOT_RNG_DOM_SUBSET:   return "値域が定義域の部分集合ではありません";
//    case RTERR_TWO_FN_OR_MAP_EXPECTED: return "Two functions or maps expected for 'comp'";
    case RTERR_TWO_FN_OR_MAP_EXPECTED: return "'comp'では、2つの関数か写像が必要です";
//    case RTERR_FN_OR_MAP_OR_NUM_EXPECTED: return "Wrong arguments for '**'";
    case RTERR_FN_OR_MAP_OR_NUM_EXPECTED: return "関数か写像か数字が必要です";
//    case RTERR_NAT_EXPECTED:         return "A natural number was expected";
    case RTERR_NAT_EXPECTED:         return "1つの自然数が必要です";
//    case RTERR_OP_RETURNED_CONT:     return "The operation did not return a value";
    case RTERR_OP_RETURNED_CONT:     return "操作が値を返しませんでした";
//    case RTERR_STATE_DESIG_UNKNOWN:  return "Unknown state component";
    case RTERR_STATE_DESIG_UNKNOWN:  return "未知の状態構成要素です";
//    case RTERR_IMPL_OP_CALL:         return "Tried to call an implicit operation";
    case RTERR_IMPL_OP_CALL:         return "陰仕様の操作を呼ぼうとしています";
//    case RTERR_ILLEGAL_STATE_INIT:   return "Illegal state initialisation";
    case RTERR_ILLEGAL_STATE_INIT:   return "許されない状態の初期化です";
//    case RTERR_ILL_STATE_INIT_PAT:   return "Illegal state initialisation pattern";
    case RTERR_ILL_STATE_INIT_PAT:   return "許されない状態の初期化パターンです";
//    case RTERR_REC_PAT_EXPECTED:     return "Record pattern expected for state initialisation";
    case RTERR_REC_PAT_EXPECTED:     return "状態の初期化のために、レコード・パターンが期待されています";
//    case RTERR_ALL_PATID_EXPECTED:   return "Only pattern identifiers allowed for state initialisation";
    case RTERR_ALL_PATID_EXPECTED:   return "状態の初期化のために、パターン識別子だけが使えます";
//    case RTERR_TYPE_BIND_EVAL:       return "Can not evaluate type binds";
    case RTERR_TYPE_BIND_EVAL:       return "型束縛は評価(実行)できません";
//    case RTERR_FNDEF_EXPECTED:       return "Function definition expected";
    case RTERR_FNDEF_EXPECTED:       return "関数定義が期待されています";
//    case RTERR_IMPL_FN_APPLY:        return "Tried to apply an implicit function";
    case RTERR_IMPL_FN_APPLY:        return "陰仕様の関数を適用しようとしています";
//    case RTERR_POLY_NOT_INST:        return "The applied polymorphic function is not instantiated";
    case RTERR_POLY_NOT_INST:        return "適用された多相関数は具体化されていません";
//    case RTERR_MAP_AND_SET_EXPECTED: return "A map and a set were expected";
    case RTERR_MAP_AND_SET_EXPECTED: return "写像か集合が期待されています";
//    case RTERR_NOT_EXPL_OP_CALL:     return "The called object is not an explicit operation";
    case RTERR_NOT_EXPL_OP_CALL:     return "呼ばれたオブジェクトは陽仕様の操作ではありません";
//    case RTERR_GET_VALUE_EXPR:       return "No input value to get_value()";
    case RTERR_GET_VALUE_EXPR:       return "get_value()の入力値がありません";
//    case RTERR_OP_CANT_RETURN_A_VALUE: return "The operation's range is empty";
    case RTERR_OP_CANT_RETURN_A_VALUE: return "操作の値域が空です";
//    case RTERR_MOD_ALREADY_DEF:      return "The module is already defined";
    case RTERR_MOD_ALREADY_DEF:      return "モジュールはすでに定義されています";
//    case RTERR_EQUAL_RENAMINGS:      return "Name clash for renaming";
    case RTERR_EQUAL_RENAMINGS:      return "名前変更による名前の衝突が起きます";
//    case RTERR_PARMOD_NOT_DEFINED:   return "Parameterised module is not defined";
    case RTERR_PARMOD_NOT_DEFINED:   return "パラメータ化モジュールは定義されていません";
//    case RTERR_NOT_FULLY_INST:       return "Parameterised module is not fully instantiated";
    case RTERR_NOT_FULLY_INST:       return "パラメータ化モジュールは完全には具体化されていません";
//    case RTERR_TYPE_ALREADY_DEF:     return "The type is already defined";
    case RTERR_TYPE_ALREADY_DEF:     return "型はすでに定義されています";
//    case RTERR_MOD_NOT_DEFINED:      return "The module is not defined";
    case RTERR_MOD_NOT_DEFINED:      return "モジュールは定義されていません";
//    case RTERR_TYPE_NOT_EXPORTED:    return "The type is not exported";
    case RTERR_TYPE_NOT_EXPORTED:    return "型は輸出されていません";
//    case RTERR_CONSTRUCT_NOT_EXPORTED: return "The construct is not exported";
    case RTERR_CONSTRUCT_NOT_EXPORTED: return "この構成要素は輸出されていません";
//    case RTERR_WRONG_STATE_TYPE:     return "Wrong state type";
    case RTERR_WRONG_STATE_TYPE:     return "適切でない状態型です";
//    case RTERR_NOT_DEFINED_IN_MOD:   return "Incorrect use of 'using'";
    case RTERR_NOT_DEFINED_IN_MOD:   return "'using'の使い方が間違っています";
//    case RTERR_LIB_NOT_DEFINED:      return "couldn't open library: L";
    case RTERR_LIB_NOT_DEFINED:      return "ライブラリを開けません: ";
//    case RTERR_LIB_SYMBOL_NOT_DEFINED: return "token not defined in library";
    case RTERR_LIB_SYMBOL_NOT_DEFINED: return "ライブラリ中でトークンが定義されていません";
//    case RTERR_LIB_ARGUMENT_WRONG_NUMBER: return "actual number of argument didn't match the number the extern function expected";
    case RTERR_LIB_ARGUMENT_WRONG_NUMBER: return "引数の実際の数が、関数の外部節が期待する数と一致しませんでした";
//    case RTERR_LIB_NOT_DECLARED:     return "Not declared in dl module";
    case RTERR_LIB_NOT_DECLARED:     return "ダイナミックリンクモジュールで宣言されていません";
//    case RTERR_INTERNAL_ERROR:       return "Internal error, please report";
    case RTERR_INTERNAL_ERROR:       return "インタープリタ内部のエラーですので、VDMToolsサポートチームまで報告をお願いします。";
//    case RTERR_LIB_TYPE_ERROR:       return "Incompatible type in dl module call";
    case RTERR_LIB_TYPE_ERROR:       return "ダイナミックリンクモジュール呼び出しで型が適合しません";
//    case RTERR_TYPE_NOT_SUPPORTED:   return "Type is not yet supported";
    case RTERR_TYPE_NOT_SUPPORTED:   return "型がまだサポートされていません";
//    case RTERR_LIB_CLOSE_ERR:        return "Couldn't close dynamic library";
    case RTERR_LIB_CLOSE_ERR:        return "ダイナミックリンクライブラリがクローズできませんでした";
//    case RTERR_TAG_NOT_IN_NAME_MAP:  return "Name not defined in NameMap in dynamic library file";
    case RTERR_TAG_NOT_IN_NAME_MAP:  return "名前がダイナミックリンクライブラリ・ファイル中のNameMap内で定義されていません";
//    case RTERR_LIB_WRONG_SIGN:       return "Library function has wrong signature";
    case RTERR_LIB_WRONG_SIGN:       return "ライブラリ関数のシグネチャが間違っています";
//    case RTERR_FILE_DOES_NOT_EXISTS: return "Library Name not found in the search path";
    case RTERR_FILE_DOES_NOT_EXISTS: return "ライブラリ名が、検索パス内に見つかりません";
//    case RTERR_CAN_NOT_BE_EVALUATED: return "Extern function cannot be evaluated";
    case RTERR_CAN_NOT_BE_EVALUATED: return "外部節を持った関数は評価(実行)できません";
//    case RTERR_FN_EXIT_CONT:         return "Function exited or returned no result";
    case RTERR_FN_EXIT_CONT:         return "関数が、結果を返しませんでした";
//    case RTERR_LIB_VERSION_NOT_FOUND: return "Symbol VDMLibVersion not found in dynamic lib";
    case RTERR_LIB_VERSION_NOT_FOUND: return "ダイナミックリンクライブラリにVDMLibVersionシンボルが見つかりません";
//    case RTERR_LIB_WRONG_VERSION:    return "Version of VDM C++ library";
    case RTERR_LIB_WRONG_VERSION:    return "VDM C++ ライブラリのバージョンが正しくありません";
//    case RTERR_EXTENDED_FCT_EXPECTED: return "Extended function or operation expected";
    case RTERR_EXTENDED_FCT_EXPECTED: return "拡張関数／操作が期待されています";
//    case RTERR_UNEXPECTED_INFLOW:    return "Unexpected input flow";
    case RTERR_UNEXPECTED_INFLOW:    return "予期しない入力フローです";
//    case RTERR_COUND_NOT_MATCH_OUTFLOW: return "Return value could not match output flows";
    case RTERR_COUND_NOT_MATCH_OUTFLOW: return "返値が出力フローと一致しませんでした";
//    case RTERR_NONEMPTYSET_EXPECTED: return "A nonempty set was expected";
    case RTERR_NONEMPTYSET_EXPECTED: return "空でない集合が期待されていました";
//    case RTERR_NUMBER_ARG_NEQ_NUMBER_TYPE: return "Number of arguments does not match number type domain in function or operation";
    case RTERR_NUMBER_ARG_NEQ_NUMBER_TYPE: return "引数の数が、関数か操作の引数の型の数と一致しません";
//    case RTERR_TYPE_INCOMP_RETURN:   return "Incompatible return type in function or operation application";
    case RTERR_TYPE_INCOMP_RETURN:   return "関数／操作の適用で、戻り値の型が適合しません";
//    case RTERR_TYPE_INCOMP_APPLY:    return "Incompatible type in variables in function or operation application";
    case RTERR_TYPE_INCOMP_APPLY:    return "関数／操作の適用で、変数の型が適合しません";
//    case RTERR_SET_EXP_IN_PATTERN_BIND: return "Set expected in pattern bind";
    case RTERR_SET_EXP_IN_PATTERN_BIND: return "パターン束縛で集合が期待されています";
//    case RTERR_VALUE_NOT_IN_SETBIND: return "Value is not in Set Bind";
    case RTERR_VALUE_NOT_IN_SETBIND: return "値が集合束縛の中にありません";
//    case RTERR_MTHD_EXIT_CONT:       return "Method exited or returned no result";
    case RTERR_MTHD_EXIT_CONT:       return "メソッドが結果を返しません";
//    case RTERR_OBJ_REF_EXP:          return "An object reference was expected in the expression";
    case RTERR_OBJ_REF_EXP:          return "式中でオブジェクト参照が期待されていました";
//    case RTERR_CLNM_NOT_DEFINED:     return "Class name is not defined";
    case RTERR_CLNM_NOT_DEFINED:     return "クラス名が定義されていません: %1";
//    case RTERR_TAG_UNKNOWN:          return "Tag is unknown within the current scope";
    case RTERR_TAG_UNKNOWN:          return "現在のスコープ中で、タグが未定義です";
//    case RTERR_VALUE_NOT_IN_SEQBIND: return "Value is not in Seq Bind";
    case RTERR_VALUE_NOT_IN_SEQBIND: return "値が列束縛の中にありません";
//    case RTERR_MULT_DEF_METHS:       return "The method name is multiple defined within the current scope";
    case RTERR_MULT_DEF_METHS:       return "現在のスコープ中で、メソッド名が多重定義されています";
//    case RTERR_MULT_DEF_FCTS:        return "The function name is multiple defined within the current scope";
    case RTERR_MULT_DEF_FCTS:        return "現在のスコープ中で、関数名が多重定義されています";
//    case RTERR_MULT_INST_VARS:       return "The instance variable name is multiple defined within the current scope";
    case RTERR_MULT_INST_VARS:       return "現在のスコープ中で、インスタンス変数が多重定義されています";
//    case RTERR_MULT_VAL_IDS:         return "The identifier is multiple defined as a value in the current scope";
    case RTERR_MULT_VAL_IDS:         return "現在のスコープ中で、識別子が多重定義されています";
//    case RTERR_TOPOLOGY_STMT:        return "Cannot evaluate topology statement";
    case RTERR_TOPOLOGY_STMT:        return "topology文は評価(実行)できません";
//    case RTERR_SPEC_STMT:            return "Cannot evaluate specification statement";
    case RTERR_SPEC_STMT:            return "仕様記述文は評価(実行）できません";
//    case RTERR_INST_ABS_CL:          return "Cannot instantiate an abstract class: %1";
    case RTERR_INST_ABS_CL:          return "抽象クラスはインスタンス化できません: %1";
//    case RTERR_NOT_CL_NAME_IN_NEW_STMT: return "Unknown class name in new expression";
    case RTERR_NOT_CL_NAME_IN_NEW_STMT: return "new式のクラス名が未定義です";
//    case RTERR_OBJ_REF_EXP_CALL:     return "An object reference was expected in call statement";
    case RTERR_OBJ_REF_EXP_CALL:     return "call文中でオブジェクト参照が期待されていました";
//    case RTERR_NOT_MTHD_NAME:        return "A name of a full method was expected in invoke statement";
    case RTERR_NOT_MTHD_NAME:        return "文中で完全なメソッド名が期待されています";
//    case RTERR_INST_INV_BROKEN:      return "Instance invariant was broken";
    case RTERR_INST_INV_BROKEN:      return "インスタンス変数の不変条件が破られました";
//    case RTERR_IND_INH_NOT_SUPPORTED: return "Indexed inheritance is not supported";
    case RTERR_IND_INH_NOT_SUPPORTED: return "索引付き継承はサポートされていません";
//    case RTERR_UNEXP_RET_VAL_INIT_CL: return "Initialisation statement returned a value";
    case RTERR_UNEXP_RET_VAL_INIT_CL: return "初期化文が返値を持っています";
//    case RTERR_CIRC_CL_DEPENDENCY:   return "Circular inheritance dependency detected";
    case RTERR_CIRC_CL_DEPENDENCY:   return "継承が循環しています";
//    case RTERR_MULT_TPS_NAME:        return "Multiple defined types with the same name within current scope";
    case RTERR_MULT_TPS_NAME:        return "現在のスコープ中で、同名の型が多重定義されています";
//    case RTERR_DB_OBJ_EXISTS:        return "The object name already exists. Please destroy the object before creating a new object of the same name";
    case RTERR_DB_OBJ_EXISTS:        return "オブジェクト名がすでに定義されています。同じ名前のオブジェクトを作成する前に、オブジェクトをdestroyしてください。";
//    case RTERR_DB_OBJ_NOT_EXISTS:    return "The name is not an object";
    case RTERR_DB_OBJ_NOT_EXISTS:    return "この名前はオブジェクトではありません";
//    case RTERR_OBJ_RECORD_EXP:       return "An object or record was expected";
    case RTERR_OBJ_RECORD_EXP:       return "オブジェクトがレコードが期待されていました";
//    case RTERR_CIRC_CL_INIT:         return "Circular dependency in initialisation detected";
    case RTERR_CIRC_CL_INIT:         return "初期化が循環しています";
//    case RTERR_NAME_UNKNOWN:         return "Name unknown";
    case RTERR_NAME_UNKNOWN:         return "名前が未定義です";
//    case RTERR_DC_NOT_PATTERN_NAME:  return "An abstract field of a record must only pattern match with a pattern name";
    case RTERR_DC_NOT_PATTERN_NAME:  return "レコードの比較対象外項目は、パターン名によるパターンマッチでなければなりません";
//    case RTERR_LOCAL_COMPOSE_TYPEDEF: return "The interpreter does not support local type definitions of records";
    case RTERR_LOCAL_COMPOSE_TYPEDEF: return "インタープリタはレコードの局所的な型定義をサポートしていません";
//    case RTERR_NOTYETSPECFCT:        return "Cannot evaluate `not yet specified' functions";
    case RTERR_NOTYETSPECFCT:        return "`not yet specified' を含む関数は評価(実行)できません";
//    case RTERR_NOTYETSPECOP:         return "Cannot evaluate `not yet specified' operations";
    case RTERR_NOTYETSPECOP:         return "`not yet specified' を含む操作は評価(実行)できません";
//    case RTERR_REC_OR_OBJ_EXPECTED:  return "A record or object was expected";
    case RTERR_REC_OR_OBJ_EXPECTED:  return "レコードかオブジェクトが期待されています";
//    case RTERR_BUG_236:              return "You have hit bug number 236, please see the bug report for a work-around";
    case RTERR_BUG_236:              return "バグ番号263が発生しました。VDMToolsサポートチームに連絡をお願いします";
//    case RTERR_EXIT_IN_INIT:         return "Exit value returned in initialisation of instance variable";
    case RTERR_EXIT_IN_INIT:         return "インスタンス変数の初期化中で、例外が発生し、値が返されています";
//    case RTERR_SUBRESP:              return "Cannot evaluate `sub responsible' functions";
    case RTERR_SUBRESP:              return "`sub responsible'を含む関数は評価(実行)できません";
//    case RTERR_NUMERIC_SET:          return "Quantification in sequence comprehension must be over numeric values";
    case RTERR_NUMERIC_SET:          return "列の内包中の限量子は、数値でなければなりません";
//    case RTERR_WRONG_NO_RES:         return "Wrong number of results";
    case RTERR_WRONG_NO_RES:         return "返値の数が間違っています";
//    case RTERR_LOWER_BOUND_NOT_A_NUMBER: return "Lower bound is not a number";
    case RTERR_LOWER_BOUND_NOT_A_NUMBER: return "下限が数ではありません";
//    case RTERR_UPPER_BOUND_NOT_A_NUMBER: return "Upper bound is not a number";
    case RTERR_UPPER_BOUND_NOT_A_NUMBER: return "上限が数ではありません";
//    case RTERR_STEP_NOT_A_NUMBER:    return "Step is not a number";
    case RTERR_STEP_NOT_A_NUMBER:    return "ステップ幅が数ではありません";
//    case RTERR_UPPER_BOUND_LARGER_THAN_LOWER_BOUND: return "Lower bound larger than upper bound";
    case RTERR_UPPER_BOUND_LARGER_THAN_LOWER_BOUND: return "上限が下限より小さいです";
//    case RTERR_LOWER_BOUND_LARGER_THAN_UPPER_BOUND: return "Lower bound larger than upper bound";
    case RTERR_LOWER_BOUND_LARGER_THAN_UPPER_BOUND: return "下限が上限より大きいです";
//    case RTERR_STEP_INDEX_IS_ZERO:   return "Step index is zero";
    case RTERR_STEP_INDEX_IS_ZERO:   return "ステップ幅が0です";
//    case RTERR_LOOP_EXPR_NOT_AN_EXPR: return "Expression in while-statement does not evaluate to an expression";
    case RTERR_LOOP_EXPR_NOT_AN_EXPR: return "while文中の式が、評価(実行)できません";
//    case RTERR_TEST_EXPR_NOT_AN_EXPR: return "Test expression in if-statement does not evaluate to an expression";
    case RTERR_TEST_EXPR_NOT_AN_EXPR: return "if文のテスト式が、評価(実行）できません";
//    case RTERR_TUPLE_OUTSIDE_INDEX:  return "Tuple selection outside its index";
    case RTERR_TUPLE_OUTSIDE_INDEX:  return "Tuple selection outside its index";
//    case RTERR_INSTVAR_NOT_PUBLIC:   return "Instance variable must be public";
    case RTERR_INSTVAR_NOT_PUBLIC:   return "インスタンス変数がpublicでなければなりません";
//    case RTERR_INSTVAR_NOT_IN_SCOPE: return "Instance variable is not in scope";
    case RTERR_INSTVAR_NOT_IN_SCOPE: return "現在のスコープ中にインスタンス変数が定義されていません";
//    case RTERR_FUN_NOT_IN_SCOPE:     return "Function is not in scope";
    case RTERR_FUN_NOT_IN_SCOPE:     return "現在のスコープ中に関数が定義されていません";
//    case RTERR_OP_NOT_IN_SCOPE:      return "Operation is not in scope";
    case RTERR_OP_NOT_IN_SCOPE:      return "現在のスコープ中に操作が定義されていません";
//    case RTERR_VAL_NOT_IN_SCOPE:     return "Value is not in scope";
    case RTERR_VAL_NOT_IN_SCOPE:     return "現在のスコープ中に値が定義されていません";
//    case RTERR_POLYFUN_NOT_IN_SCOPE: return "Polymorphic function is not in scope";
    case RTERR_POLYFUN_NOT_IN_SCOPE: return "現在のスコープ中に多相関数が定義されていません";
//    case RTERR_TYPE_NOT_IN_SCOPE:    return "Type is not in scope";
    case RTERR_TYPE_NOT_IN_SCOPE:    return "現在のスコープ中に型が定義されていません";
//    case RTERR_NOT_IN_SCOPE:         return "Construct not in scope";
    case RTERR_NOT_IN_SCOPE:         return "現在のスコープ中に構成要素が定義されていません";
//    case RTERR_MULT_DEF:             return "Construct is multiple defined within the current scope";
    case RTERR_MULT_DEF:             return "現在のスコープ中で構成要素が多重定義されています";
//    case RTERR_INIT_NOT_POSSIBLE:    return "Initialisation is not possible";
    case RTERR_INIT_NOT_POSSIBLE:    return "初期化できません";
//    case RTERR_INDEXED_ASSIGN:       return "Indexed assignment can only be done when initialized";
    case RTERR_INDEXED_ASSIGN:       return "索引付きの代入は初期化されている場合のみ可能です";
//    case RTERR_OP_IN_GUARD:          return "You cannot use an operation inside a permission guard";
    case RTERR_OP_IN_GUARD:          return "許可述語中で操作は使えません";
//    case RTERR_NO_THREAD:            return "This class has no thread to start";
    case RTERR_NO_THREAD:            return "このクラスはstartするスレッドがありません";
//    case RTERR_DEADLOCK_DETECTED:    return "Deadlock is detected";
    case RTERR_DEADLOCK_DETECTED:    return "デッドロックが検出されました";
//    case RTERR_PRE_COND_APPLY_EXPR:  return "The special pre-condition application expression is not supported in the interpreter";
    case RTERR_PRE_COND_APPLY_EXPR:  return "特別な事前条件適用式は、インタープリタでサポートされていません";
//    case RTERR_NO_GUARD_IN_INIT:     return "An operation with a permission guard may not  be used in the initialisation of an instance variable";
    case RTERR_NO_GUARD_IN_INIT:     return "許可述語を伴う操作は、インスタンス変数の初期化に使ってはいけません";
//    case RTERR_OP_OR_FUN_NOT_IN_SCOPE: return "Operation or function is not in scope";
    case RTERR_OP_OR_FUN_NOT_IN_SCOPE: return "現在のスコープ中で、操作または関数は定義されていません";
//    case RTERR_OP_DEF_IN_MULTSUPERS: return "Operation defined in multiple super classes, so it is not allowed to add permission predicate for class";
    case RTERR_OP_DEF_IN_MULTSUPERS: return "操作が複数のスーパークラスで定義されているので、このクラスで許可述語を追加できません";
//    case RTERR_SEL_NONVALID_THREADID:  return "A non-valid thread id was used";
    case RTERR_SEL_NONVALID_THREADID:  return "不当なスレッドIDが使われていました";
//    case RTERR_MULT_THREAD_INH:      return "More than one thread inherited";
    case RTERR_MULT_THREAD_INH:      return "1つ以上のスレッドが継承されています";
//    case RTERR_DLCLASS_NEW_ERROR:    return "External dlclass instantiation failed";
    case RTERR_DLCLASS_NEW_ERROR:    return "外部ダイナミックリンククラス（dlclass）のインスタンス化に失敗しました";
//    case RTERR_DLCLASS_LOAD_ERROR:   return "dlclass loading failed";
    case RTERR_DLCLASS_LOAD_ERROR:   return "ダイナミックリンククラス（dlclass）のロードに失敗しました";
//    case RTERR_DLCLASS_APPLY_AFTER_DLCLOSE: return "apply of dlclass method after dlclose";
    case RTERR_DLCLASS_APPLY_AFTER_DLCLOSE: return "dlcloseの後に、ダイナミックリンククラス（dlclass）メソッドを適用しています";
//    case RTERR_DLCLASS_DELETE_FAILED: return "external delete of dlclass failed";
    case RTERR_DLCLASS_DELETE_FAILED: return "ダイナミックリンククラス（dlclass）の外部削除（external delete）に失敗しました";
//    case RTERR_CLASS_NOT_DLCLASS:    return "Class is not a dlclass: ";
    case RTERR_CLASS_NOT_DLCLASS:    return "クラスはダイナミックリンククラス（dlclass）ではありません: ";
#ifdef VDMSL
//    case RTERR_NO_DL_LICENSE:        return "Initialisation stopped. Failed to check out vdmdl license.";
    case RTERR_NO_DL_LICENSE:        return "vdmdlライセンスの確認に失敗し、初期化が停止しました。";
#endif // VDMSL
#ifdef VDMPP
//    case RTERR_NO_DL_LICENSE:        return "Initialisation stopped. Failed to check out vppdl license.";
    case RTERR_NO_DL_LICENSE:        return "vppdlライセンスの確認に失敗し、初期化が停止しました。";
#endif // VDMPP
//    case RTERR_DL_NOT_ENABLED:       return "dlmodules/dlclasses are not supported in this Toolbox.";
    case RTERR_DL_NOT_ENABLED:       return "このVDMToolsでは、ダイナミックリンクモジュール（dlmodule）あるいはダイナミックリンククラス（dlclass）はサポートされていません。";
//    case RTERR_POLY_CALL:            return "Attempt to execute a polymorphic function without instantiating its type variables.";
    case RTERR_POLY_CALL:            return "型変数のインスタンス化をせずに多相関数の実行を試みています";
//    case RTERR_APPLY_NONAPPVAL:      return "Apply expression contains left hand side which is not a map, sequence or function";
    case RTERR_APPLY_NONAPPVAL:      return "適用式の左辺が写像、列、関数のいずれでもありません";
//    case RTERR_LOGDLCALL:            return "Log of dlcall: " ;
    case RTERR_LOGDLCALL:            return "dlcallのログ: " ;
//    case RTERR_NOCONSTRUCTOR:        return "No constructor with this parameter list is in scope";
    case RTERR_NOCONSTRUCTOR:        return "現在のスコープ中に、このパラメータリストを持つ構成子はありません";
//    case RTERR_MULTIOVERLOADED:      return "Unable to resolve overloaded operation call";
    case RTERR_MULTIOVERLOADED:      return "対応するオーバーロード操作が決定できません";
//    case RTERR_STATIC_NOT_IN_SCOPE:  return "Static member is not in scope";
    case RTERR_STATIC_NOT_IN_SCOPE:  return "現在のスコープ中に静的（static）な構成要素はありません";
//    case RTERR_STATIC_IV_NO_VALUE:   return "Static instance variable must be initialized";
    case RTERR_STATIC_IV_NO_VALUE:   return "静的（static）インスタンス変数は初期化されていなければなりません";
//    case RTERR_CANNOT_PROCEED_AFTER_RUNTIME_ERROR: return "Cannot proceed after a runtime error." ;
    case RTERR_CANNOT_PROCEED_AFTER_RUNTIME_ERROR: return "実行時エラーの後は、処理を続行できません" ;
//    case RTERR_NOOVERLOADED:         return "No overloaded operation or function with this parameter list is in scope";
    case RTERR_NOOVERLOADED:         return "現在のスコープ中に、このパラメータリストを持つオーバーロード操作または関数はありません";
//    case RTERR_NOOBJECT:             return "No object is present";
    case RTERR_NOOBJECT:             return "オブジェクトがありません";
//    case RTERR_CPUIMPLCLASS:         return "When a system specification is made CPU is an implicit class";
    case RTERR_CPUIMPLCLASS:         return "システム仕様で、CPUはあらかじめ定義された暗黙のクラスです";
//    case RTERR_BUSIMPLCLASS:         return "When a system specification is made BUS is an implicit class";
    case RTERR_BUSIMPLCLASS:         return "システム仕様で、BUSはあらかじめ定義された暗黙のクラスです";
//    case RTERR_DEPLOYINST:           return "Only instances can be deployed to a CPU";
    case RTERR_DEPLOYINST:           return "インスタンスはCPUにのみ配置されます";
//    case RTERR_NOBUS:                return "No BUS is connecting these two CPUs";
    case RTERR_NOBUS:                return "これら2つのCPUを繫ぐBUSがありません";
//    case RTERR_ONLYDEPLOYORPRIO:     return "Only deploy and priority operations can be used in system constructor";
    case RTERR_ONLYDEPLOYORPRIO:     return "deploy操作とsetPriority操作は、システム構成子中でのみ使うことができます";
//    case RTERR_UNSUPPRIO:            return "Unsupported CPU priority scheme";
    case RTERR_UNSUPPRIO:            return "サポートされていないCPUのスケジューリング方針です";
//    case RTERR_UNSUPCPUCAP:          return "Unsupported CPU capacity (should be a nat)";
    case RTERR_UNSUPCPUCAP:          return "CPUの処理能力は自然数（nat）で指定しなければなりません";
//    case RTERR_WRONGCPUCONS:         return "Wrong parameters to CPU constructor";
    case RTERR_WRONGCPUCONS:         return "CPU構成子のパラメータが正しくありません";
//    case RTERR_UNSUPPKIND:           return "Unsupported BUS kind";
    case RTERR_UNSUPPKIND:           return "サポートされていないBUSの種類です";
//    case RTERR_UNSUPBUSCAP:          return "Unsupported BUS capacity (should be a nat)";
    case RTERR_UNSUPBUSCAP:          return "BUSの処理能力は自然数（nat）で指定しなければなりません";
//    case RTERR_NOSETOFCPUS:          return "This should be a set of CPU names";
    case RTERR_NOSETOFCPUS:          return "これはCPU名の集合でなければならない";
//    case RTERR_WRONGBUSCONS:         return "Wrong parameters to BUS constructor";
    case RTERR_WRONGBUSCONS:         return "BUS構成子のパラメータが不当です";
//    case RTERR_TYPE_INCOMP_IN_FNOP_APPLY: return "Incompatible types found in call of function/operation with dynamic type check";
    case RTERR_TYPE_INCOMP_IN_FNOP_APPLY: return "関数／操作呼び出しの動的型チェックで、適合しない型が見つかりました";
//    case RTERR_TYPE_INV_BROKEN:      return "Type invariant was broken";
    case RTERR_TYPE_INV_BROKEN:      return "型の不変条件が破られました";
//    case RTERR_EVAL_ASSERT_GIVES_FALSE:      return  "The assertion evaluated to false";
    case RTERR_EVAL_ASSERT_GIVES_FALSE:    return "表明の評価結果がfalseです";
//    case RTERR_TAG_CYCLIC:           return "Circular defined tag detected";
    case RTERR_TAG_CYCLIC:           return "タグの定義が循環しています";
//    case RTERR_MULTIPLE_PATTERN:     return "Pattern may match multiply";
    case RTERR_MULTIPLE_PATTERN:     return "パターンが複数マッチします";
//    case RTERR_DLMODULE_LOAD_ERROR:   return "dlmodule loading failed";
    case RTERR_DLMODULE_LOAD_ERROR:   return "ダイナミックリンクモジュール（dlmodule）のロードに失敗しました";
//    case RTERR_MEASURE_ERROR:         return wstring(L"Current measure value isn't smaller than previous value");
    case RTERR_MEASURE_ERROR:         return "Measure値が減少していません";
//    case RTERR_NO_RUNNING_THREAD:    return wstring(L"Thread is't started or is already dead");
    case RTERR_NO_RUNNING_THREAD:    return "スレッドは開始していないか終了しています";
//    case RTERR_NAT_OR_TUPLE_OF_NAT_EXPECTED: return wstring(L"A natural number or a tuple of natural numbers was expected");
    case RTERR_NAT_OR_TUPLE_OF_NAT_EXPECTED: return "1個の自然数か自然数の組が必要です";
//    case RTERR_PURE_OP_EXIT_CONT:    return wstring(L"Pure operation exited or returned no result");
    case RTERR_PURE_OP_EXIT:         return "純操作が例外を発生しました";
//    case RTERR_PURE_OP_CALL:         return wstring(L"Pure operation call impure operation");
    case RTERR_PURE_OP_CALL:         return "純操作が非純操作を呼び出しました";
//    case RTERR_STATE_COMPONENT_PURE_OP return wstring(L"Pure operation uses state component");
    case RTERR_STATE_COMPONENT_PURE_OP: return "純操作が状態構成要素を使用しました";

//    case RTERR_UNKNOWN_AS_TYPE:      return "Internal Error: unknown AS type";
    case RTERR_UNKNOWN_AS_TYPE:      return "Internal Error: unknown AS type";
//    case RTERR_UNKNOWN_OPERATOR:     return "Internal Error: Unknown operator";
    case RTERR_UNKNOWN_OPERATOR:     return "Internal Error: Unknown operator";
//    case RTERR_ID_NOT_IN_LIST:       return "Internal Error: id not in list";
    case RTERR_ID_NOT_IN_LIST:       return "Internal Error: id not in list";
//    case RTERR_UNKNOWN_RECORD_TYPE:  return "Unknown record type";
    case RTERR_UNKNOWN_RECORD_TYPE:  return "Unknown record type";
//    case RTERR_CIRCULAR_STATIC_DEPENDENCY: return "Circular static dependency detected";
    case RTERR_CIRCULAR_STATIC_DEPENDENCY: return "静的変数が循環しています";
//    case RTERR_UNKNOWN_OBJECT:       return "Internal Error: Unknown object";
    case RTERR_UNKNOWN_OBJECT:       return "Internal Error: Unknown object";
//    case RTERR_CIRCULAR_TYPE_INV_DEPENDENCY: return "Circular type invariant dependency in dynamic type check";
    case RTERR_CIRCULAR_TYPE_INV_DEPENDENCY: return "動的型チェックで不変条件が循環しています";
//    case RTERR_PERIODIC_THREAD_UNSUPPORTED: return "Periodic Thread is't supported.";
    case RTERR_PERIODIC_THREAD_UNSUPPORTED: return "周期スレッドは使用できません";
//    case RTERR_INCOMPATIBLE_BIND_TYPE: return "Incompatible type found in pattern binding";
    case RTERR_INCOMPATIBLE_BIND_TYPE: return "パターン束縛で型が適合しません";
//    case RTERR_DLCLASS_CALL_FAILED:  return "dlclass call failed";
    case RTERR_DLCLASS_CALL_FAILED:  return "dlclass call failed";
//    case RTERR_INVALID_INSTRUCTION:  return "Internal Error: Invalid Instruction";
    case RTERR_INVALID_INSTRUCTION:  return "Internal Error: Invalid Instruction";
//    case RTERR_UNEXPECTED_PREFIX_OP: return "Internal Error: unexpected prefix op";
    case RTERR_UNEXPECTED_PREFIX_OP: return "Internal Error: unexpected prefix op";
//    case RTERR_UNEXPECTED_BINARY_OP: return "Internal Error: unexpected binary op";
    case RTERR_UNEXPECTED_BINARY_OP: return "Internal Error: unexpected binary op";
//    case RTERR_UNEXPECTED_EXPRESSION: return "Internal Error: unexpected expression";
    case RTERR_UNEXPECTED_EXPRESSION: return "Internal Error: unexpected expression";
//    case RTERR_UNEXPECTED_HISTORY_EVENT: return "Internal Error: unexpected history event";
    case RTERR_UNEXPECTED_HISTORY_EVENT: return "Internal Error: unexpected history event";
//    case RTERR_UNEXPECTED_TRACE_EVENT: return "Internal Error: unexpected trace event";
    case RTERR_UNEXPECTED_TRACE_EVENT: return "Internal Error: unexpected trace event";
//    case RTERR_UNABLE_OPEN_LOGFILE:  return "Unable to open logfile for writing";
    case RTERR_UNABLE_OPEN_LOGFILE:  return "Unable to open logfile for writing";
//    case RTERR_NO_HISTORY_MAP:       return "Internal Error: No HistMap";
    case RTERR_NO_HISTORY_MAP:       return "Internal Error: No HistMap";
//    case RTERR_UNKNOWN_VALCOND:      return "Internal Error: Unknown ValCond";
    case RTERR_UNKNOWN_VALCOND:      return "Internal Error: Unknown ValCond";
//    case RTERR_UNKNOWN_VALCOND_KIND: return "Internal Error: Unknown ValCond kind";
    case RTERR_UNKNOWN_VALCOND_KIND: return "Internal Error: Unknown ValCond kind";
//    case RTERR_ILLEGAL_VALCOND_INDEX: return "Internal Error: Illegal index";
    case RTERR_ILLEGAL_VALCOND_INDEX: return "Internal Error: Illegal index";
//    case RTERR_UNKNOWN_VALCOND_RECORD: return "Internal Error: Unknown ValCond Record";
    case RTERR_UNKNOWN_VALCOND_RECORD: return "Internal Error: Unknown ValCond Record";
//    case RTERR_OP_RETURNED_VALUE:    return "The operation return a value";
    case RTERR_OP_RETURNED_VALUE:    return "操作が値を返します";
//    case RTERR_OP_NAME_EXPECTED:     return "A operation name was expected";
    case RTERR_OP_NAME_EXPECTED:     return "操作名が必要です";
//    case RTERR_SPORADIC_THREAD_UNSUPPORTED: return "Sporadic Thread is't supported.";
    case RTERR_SPORADIC_THREAD_UNSUPPORTED: return "散発スレッドは使用できません";
    default: {
      return "";
    }
  }
}
