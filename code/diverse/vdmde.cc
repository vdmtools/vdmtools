/***
*  * WHAT
*  *    VDM-SL Toolbox development environment.
*  * Id
*  *    $Id: vdmde.cc,v 1.183 2006/06/23 05:34:19 vdmtools Exp $
*  * COPYRIGHT
*  *    (C) Kyushu University
***/

#include "date.h"
#include "SEM.h"
#include "val2x.h"
#include "contextinfo.h"
#include "cli_options.h"
#include "settings.h"

// Interface to the Specification Manager
#include "ToolKit.h"
#include "BaseTools.h"
#include "Interface.h"
#include "PromptErr.h"
#include "BatchErr.h"
#include "UMLTool.h"
#include "projectval.h"

// Interface to the POG
#include "pog-interface.h"

#include "tb_wstring.h"
#include "tb_exceptions.h"
#include "astaux.h"
#include "stringext.h"
#include "asciiInterface.h"
#include "tb_getopt.h"
#include "tools.h"
#include "tbutils.h"
#include "tbdebug.h"
#ifdef VICE
#include "TIMETRACE.h"
#endif // VICE

#include <fstream>
#include <locale.h>
#include <sstream>

TBOptions *cliOpt = NULL;

// redifinition of the the error stream.
// used in -b mode

static wofstream error_stream;
static int report_error (const wchar_t* msg, int len)
{
  wcerr.write(msg, len);
  wcerr.flush ();
  if (error_stream)
    error_stream.write(msg, len);
  return 1;
}

#include <signal.h>
//  void sigfunc(int sig)
//  {
//    wchar_t * s = L"signal handler called. exiting...\n";
//    write(2, s, strlen(s));
//    exit(0);
//  }

// This funcion is called when the user presses the C-c
void StopButton(int sig)
{
  TBDEBUG::BreakIP();
}

#ifdef VDMPP
void initUML()
{
  // Establish the UML mapper instance
  if (!ToolMediator::UMLT()->vdm_InitUMLMapper()) {
    wcerr << L"UML instance was not initialized." << endl << flush;
    exit(1);
  }
  // Point the UML mapper to the location of the UML dir
}
#endif // VDMPP

// batchInternal
void batchInternal(CLIOptions & thisCliOpt)
{
  ifstream vdmtest (".vdmtest");
  if (!vdmtest)
  {
    vdm_err << L"Couldn't open '.vdmtest' file" << endl << flush;
    TOOLS::ExitToolbox(2);
  }

  if (!TOOLS::ReadStartUpFile ())
    TOOLS::ExitToolbox(1); // errors detected in startup file

  ToolMediator::InitCoverageFile(thisCliOpt.GetCoverageFile(), GetCI());
  while (!vdmtest.eof ())
  {
    string argfile = "";
    vdmtest >> argfile;
    if (argfile.length() > 0)
    {
      error_stream.open((argfile + ".err").c_str(), ios::out);

      // form: testcase.arg
      int dotargstart = argfile.length() - 4;
      wstring optionsfile_name (TBWSTR::string2wstring(string(argfile, 0, dotargstart)) + L".opt");
      if (!TBUTILS::file_exists(optionsfile_name))
        optionsfile_name = L"nulloptions";

      Settings.UnsetTranslation();

      SEQ<TYPE_ProjectTypes_FileName> optionsfile_l;
      optionsfile_l.ImpAppend(PTAUX::mk_FileName(optionsfile_name));
      if (!ToolMediator::BTools()->vdm_SyntaxCheck (optionsfile_l).GetValue ())
        TOOLS::ExitToolbox (2);

      if (!ToolMediator::BTools()->vdm_InitInterpreter().GetValue())
        TOOLS::ExitToolbox (1);

      Tuple res (ToolMediator::BTools()->vdm_ParseAndEvalExprs (PTAUX::mk_FileName(TBWSTR::string2wstring(argfile))));

      vdm_log.flush();
      vdm_err.flush();

      bool ok = res.GetBoolValue (1);
      error_stream.close();
      if (!ok && thisCliOpt.IsInternalTest())
      {
        // Rename rterr.msg to test case specific name
        wstring rterrfile = L"rterr.msg";
        TBUTILS::file_copy_overwrite(TBWSTR::string2wstring(argfile + ".msg"), rterrfile);
//        continue;
      }
      else
        TBUTILS::remove_file(TBWSTR::string2wstring(argfile + ".err"));

      // Also a hack to move L"logfile" to argfile.logfile
      // This relates to logfiles generated by the VICE extensions
      wstring logfilename = L"logfile";
      if (TBUTILS::file_exists(logfilename))
      {
        TBUTILS::file_copy_overwrite(TBWSTR::string2wstring(argfile + ".logfile"), logfilename);
      }

      Sequence res_lv (res.GetSequence (2));
      Generic res_v (res_lv.Hd()); // [SEM`VAL]
      if (!res_v.IsNil())
      {
        ofstream argfile_res((argfile + ".res").c_str());
        wostringstream wos;
        VAL2X::PrintSemValue(res_v, wos);
        argfile_res << TBWSTR::wstring2string(wos.str());
        argfile_res.close();
      }

      if (thisCliOpt.IsInternalTest())
      {
        ofstream argfile_pt((argfile + ".pt").c_str());
        res_v.WriteVal (argfile_pt);
      }
    }
  }
  vdmtest.close ();
  ToolMediator::SaveCoverageCounters(thisCliOpt.GetCoverageFile(), GetCI());
}

void batchInterpreter(CLIOptions & thisCliOpt, char *argv[])
{
  Settings.UnsetTranslation();

  int index = thisCliOpt.GetOptionsIndex();
  // Note here what we use index-1 since the arg file occurs immediately
  // before the spec files
  wstring argfile (TBWSTR::string2wstring(argv[index-1]));
  
#ifdef VICE
  wstring tf (thisCliOpt.GetTimeFile());
  if (tf != L"")
    ToolMediator::BTools()->vdm_SetTimeFile(PTAUX::mk_FileName(tf));
#endif // VICE

  if (!ToolMediator::BTools()->vdm_InitInterpreter().GetValue())
    TOOLS::ExitToolbox (1);
  
  ToolMediator::InitCoverageFile(thisCliOpt.GetCoverageFile(), GetCI());
  
#ifdef VDMPP
  if (Settings.PriorityBased())
    ToolMediator::BTools()->vdm_SetPriorityFile(PTAUX::mk_FileName(thisCliOpt.GetPriorityFile()));
  
  wstring cls (thisCliOpt.GetClassNameForPush());
  if (!cls.empty())
  {
    Bool pok (ToolMediator::BTools()->vdm_PushModule(PTAUX::mk_ModuleName(cls)));
    if (!pok)
      TOOLS::ExitToolbox (1);
  }
#endif //VDMPP
  
  if (thisCliOpt.IsSetException())
  {
    Settings.RTErrExceptionOn();
  }

// 20150220 -->
#ifdef VICE
  TIMETRACE::SetNewLog(false);
#endif // VICE
// <-- 20150220

  Tuple res (ToolMediator::BTools()->vdm_ParseAndEvalExprs(PTAUX::mk_FileName(argfile)));
  ToolMediator::SaveCoverageCounters(thisCliOpt.GetCoverageFile(), GetCI());
  
#ifdef VDMPP
  if (!cls.empty())
  {
    Bool pok (ToolMediator::BTools()->vdm_PopModule());
    if (!pok)
      TOOLS::ExitToolbox (1);
  }
#endif //VDMPP
  
  const Bool & ok (res.GetBool (1));
  if (!ok.GetValue())
    TOOLS::ExitToolbox (1);

  if (thisCliOpt.IsInternalTest())
  {
    const Sequence & res_lv (res.GetSequence (2));
    const TYPE_SEM_VAL & res_v (res_lv.Hd());
    wofstream m4pp("m4pp");
    VAL2X::PrintSemValue (res_v, m4pp);
    m4pp.close();
    ofstream out ("m4pt");
    if (!out) {
      vdm_err << L"Couldn't open file 'm4pt'" << endl << flush;
      TOOLS::ExitToolbox (1);
    }
    res_v.WriteVal (out);
    out.close();
  }
  wstring output_file (thisCliOpt.GetResultFile());
  if (output_file != L"") {
    const Sequence & res_lv (res.GetSequence(2));
    wostringstream fs;
    size_t len_res_lv = res_lv.Length();
    for (size_t idx = 1; idx <= len_res_lv; idx++)
      VAL2X::PrintSemValue(res_lv[idx], fs);

    ofstream f (TBWSTR::wstring2fsstr(output_file).c_str());
    if (!f) {
      vdm_err << L"Couldn't create file `" << output_file << L"'" << endl << flush;
      TOOLS::ExitToolbox(1);
    }
    f << TBWSTR::wstring2string(fs.str()) << endl;
    f.close();
  }
}

void batchSyntaxCheck(CLIOptions & thisCliOpt)
{
  ToolMediator::SaveCoverageCounters(thisCliOpt.GetCoverageFile(), GetCI());
  if (thisCliOpt.IsInternalTest())
  {
    ofstream m4pp("m4pp");
    Map m (ToolMediator::GetFileMapNumName());
    ToolMediator::PrintAstTuple(m4pp, ToolMediator::GetAllASTs(), GetCI(), m);
  }
  
  if (thisCliOpt.SaveTempFile())
  {
    // copy tmp file if existing to file.txt
    SEQ<TYPE_ProjectTypes_FileName> file_l (thisCliOpt.GetFileList());
    size_t len_file_l = file_l.Length();
    for (size_t idx = 1; idx <= len_file_l; idx++)
    {
      const TYPE_ProjectTypes_FileName & file (file_l[idx]);
      TYPE_ProjectTypes_FileName tmpfile (ToolMediator::GetVDMTempFileName (file));
      wstring filestr (PTAUX::ExtractFileName (file) + L".txt");
      wstring tmpfilestr (PTAUX::ExtractFileName (tmpfile));
      if (!tmpfilestr.empty()) {
        if(TBUTILS::file_copy_overwrite(filestr, tmpfilestr))
          vdm_log << L"RTF File " << PTAUX::ExtractFileName(file)
                  << L" saved in ascii form to " << filestr
                  << endl << flush;
        else
          vdm_err << L"Unable to save RTF File " << PTAUX::ExtractFileName(file)
                  << L" in ascii form" << endl << flush;
      }
    }
  }
}

void batchPrettyPrint(CLIOptions & thisCliOpt)
{
  if (!ToolMediator::BTools()->vdm_PrettyPrint (thisCliOpt.GetFileList()).GetValue ()) 
    TOOLS::ExitToolbox (2);
}

void batchTypeCheckerAndCG(CLIOptions & thisCliOpt)
{
// 20100728 -->
  TOOLS::OutputStatSemErrors(Nil());
// <-- 20100728

  PrimaryFlagType pf = thisCliOpt.GetPrimaryFlag();

  if(( pf == FLAG_CPPCG ) && !Settings.canCG()) return;
  if(( pf == FLAG_JAVACG ) && !Settings.canJavaCG()) return;
  
  if (thisCliOpt.IsDefTypeCheck())
    Settings.DefOn();
  else
    Settings.DefOff();

  Settings.UnsetTranslation();
  
// 20121112 -->
#ifdef VDMPP
  Sequence ast_l (ToolMediator::GetVDMASTs());
  size_t len_ast_l = ast_l.Length();
  for (size_t idx = 1; idx <= len_ast_l; idx++)
    GetStatSem().ExpandClass(Settings.TypeCheck(), ast_l[idx]);

#endif // VDMPP
// <-- 20121112

  SEQ<TYPE_ProjectTypes_ModuleName> mod_l (ToolMediator::VDMModules().ToSequence());
  
//
//wcout << ToolMediator::Errs()->vdm_GetErrors().Length() << endl;
//

  bool ok = ToolMediator::BTools()->vdm_TypeCheck (mod_l).GetValue ();
  
  if (thisCliOpt.IsInternalTest() && ok)
  {
    ofstream m4pp("m4pp");
    Sequence ast_l (ToolMediator::GetVDMASTs());
    Map m (ToolMediator::GetFileMapNumName());
    ToolMediator::PrintAstTuple(m4pp, ast_l, GetCI(), m);
  }

  if (pf == FLAG_TYPECHECKER)
    return;

  if (!ok)
    TOOLS::ExitToolbox (1);
  
  Quote kind ((pf == FLAG_CPPCG) ? Quote(L"CPP") : Quote(L"JAVA"));
// 20060906
  Bool testcond (Settings.PreCheck());
  Bool preandpost = true;
  
#ifdef VDMPP
  Generic package_name = Nil();
  Bool skeleton = thisCliOpt.JavaSkeletonsOnly() || thisCliOpt.JavaGenSmall();
  Bool onlytypes = thisCliOpt.JavaTypesOnly();
  Bool conc = thisCliOpt.JavaGenConc();
  Bool smalltypes = thisCliOpt.JavaGenSmall();
  if (pf == FLAG_JAVACG) {
    preandpost = testcond.GetValue() || thisCliOpt.JavaGenPrePost();
    wstring packageString (thisCliOpt.GetJavaPackageName());
    if (packageString != L"")
      package_name = Sequence(packageString);

    wstring  interfaceList = thisCliOpt.JavaGetInterfaces();
    if (interfaceList != L"")
      TOOLS::SetInterfacesOption(interfaceList);

    Settings.SetJCGVDMPrefix(thisCliOpt.JavaVDMPrefix());
  
// 20081208 -->
    wstring classesList (thisCliOpt.GetJavaClassNames());
    if (!classesList.empty())
    {
      wstring separator = L",";
      wstring classNames[20];
      int numClasses = STR_split(classesList, classNames, 20, STR_RXwhite_and_comma);
      mod_l.Clear();
      for (int i = 0; i < numClasses; i ++)
      {
        TYPE_ProjectTypes_ModuleName mod (PTAUX::mk_ModuleName(classNames[i]));
        mod_l.ImpAppend(mod);
      }
    }
// <-- 20081208
// 20121106 -->
    SEQ<TYPE_ProjectTypes_ModuleName> mod_l_q;
    size_t len_mod_l = mod_l.Length();
    for (size_t idx = 1; idx <= len_mod_l; idx++)
    {
      if (PTAUX::ExtractModuleName(mod_l[idx]).find(L"JDK_") != 0)
        mod_l_q.ImpAppend(mod_l[idx]);
    }
    mod_l = mod_l_q;
// <-- 20121106
  }
  ok = ToolMediator::BTools()->vdm_CodeGenerate (mod_l,
                                   kind,
                                   skeleton,
                                   preandpost,
                                   onlytypes,
                                   smalltypes,
                                   package_name,
                                   conc,
                                   testcond).GetValue ();
#endif //VDMPP
#ifdef VDMSL
  ok = ToolMediator::BTools()->vdm_CodeGenerate (mod_l,
                                   kind,
                                   Bool(false),
                                   preandpost,
                                   Bool(false),
                                   Bool(false),
                                   Nil(),
                                   Bool(false),
                                   testcond).GetValue ();
#endif // VDMSL
}

void batchPOG(CLIOptions & thisCliOpt, char * argv[])
{
  PrimaryFlagType pf = thisCliOpt.GetPrimaryFlag();

  //      if (argc > 3) {
  //        vdm_err << L"Too many arguments!" << endl << flush;
  //        ExitToolbox (-1);
  //}

  bool the_Setting_DEF = Settings.IsDEF();
  Settings.DefOff();

  SEQ<TYPE_ProjectTypes_ModuleName> mod_l (ToolMediator::VDMModules().ToSequence());
  
  bool ok = ToolMediator::BTools()->vdm_TypeCheck (mod_l).GetValue ();
  
  if(the_Setting_DEF)
    Settings.DefOn();
  else
    Settings.DefOff();
  
  string filename = argv[optind];
  if (ok) {
  
    string pogfilename;
    ofstream pogFile;
    if (pf == FLAG_POG)
    {
      pogfilename = filename+".pog";
      pogFile.open(pogfilename.c_str());
    }
    else
    {
      wstring resfile (thisCliOpt.GetResultFile());
      if (resfile != L"")
        pogfilename = TBWSTR::wstring2fsstr(resfile);
      else
      {
        pogfilename = filename + ".res";
      }
    }
  
    PogInterface& pog = GetPogInterface();
  
    SET<TYPE_TEST_ProofObligationPP> tpopps;

    Generic g;
    for (bool bb = mod_l.First(g); bb; bb = mod_l.Next(g))
    {
      TYPE_ProjectTypes_String moduleName (TYPE_ProjectTypes_ModuleName(g).get_nm());
      wstring name;
      moduleName.GetString(name);
  
      vdm_log << L"Generating proof obligations for " << name << L"..." << flush;
  
      pog.setup();
      pog.genPO(mk_sequence(ASTAUX::MkNameFromId(moduleName, NilContextId)));
  
      if (pf == FLAG_POG)
      {
        pogFile << TBWSTR::wstring2string(pog.getPrettyPO()) << endl;
      }
      else
        tpopps.ImpUnion(pog.getTestPOs());

      vdm_log << L"done" << endl;
    }
    if (pf == FLAG_POG)
    {
      pogFile.close();
    }
    else
    {
      wofstream pog_res (pogfilename.c_str());
      pog_res << tpopps << endl;
      pog_res.close();
    }
  }
  else
  { // TypeCheck Error
    if (pf == FLAG_POGTEST)
    {
      SEQ<TYEP_SSERR_ErrMsg> res;
      SEQ<TYPE_ProjectTypes_WarnMsg> warns (ToolMediator::Errs()->vdm_GetWarnings());
      size_t len_warns = warns.Length();
      for (size_t widx = 1; widx <= len_warns; widx++)
      {
        const TYPE_ProjectTypes_WarnMsg & wm (warns[widx]); 
        const type_cLL & t_l (wm.GetSequence(vdm_ProjectTypes::pos_WarnMsg_msg));
        type_cL msg;
        if (!t_l.IsEmpty())
          msg = t_l[1];
        res.ImpAppend(TYEP_SSERR_ErrMsg().Init(wm.GetInt(vdm_ProjectTypes::pos_WarnMsg_fid),
                                               wm.GetInt(vdm_ProjectTypes::pos_WarnMsg_line),
                                               wm.GetInt(vdm_ProjectTypes::pos_WarnMsg_col),
                                               msg, Quote(L"WARNING")));
      }

      SEQ<TYPE_ProjectTypes_ErrMsg> errors (ToolMediator::Errs()->vdm_GetErrors());
      size_t len_errors = errors.Length();
      for (size_t eidx = 1; eidx <= len_errors; eidx++)
      {
        const TYPE_ProjectTypes_ErrMsg & em (errors[eidx]); 
        const type_cLL & t_l (em.GetSequence(vdm_ProjectTypes::pos_ErrMsg_msg));
        type_cL msg;
        if (!t_l.IsEmpty())
          msg = t_l[1];
        res.ImpAppend(TYEP_SSERR_ErrMsg().Init(em.GetInt(vdm_ProjectTypes::pos_ErrMsg_fid),
                                               em.GetInt(vdm_ProjectTypes::pos_ErrMsg_line),
                                               em.GetInt(vdm_ProjectTypes::pos_ErrMsg_col),
                                               msg, Quote(L"ERROR")));
      }

      wstring resfile (thisCliOpt.GetResultFile());
      string pogfilename;
      if (resfile != L"")
        pogfilename = TBWSTR::wstring2fsstr(resfile);
      else
        pogfilename = filename + ".res";
      wofstream pog_res (pogfilename.c_str());
      pog_res << res << endl;
      pog_res.close();
    }
  }
}

void RunBatchMode(int argc, char *argv[], CLIOptions & thisCliOpt)
{
  TOOLS::InitToolbox (true);

// 20121105 -->
#ifdef VDMPP
//  if (thisCliOpt.GetPrimaryFlag() == FLAG_JAVACG)
    Settings.SetJCGHackParser(true);
#endif // VDMPP
// <-- 20121105

  if (! ToolMediator::BTools()->vdm_SyntaxCheck (thisCliOpt.GetFileList()).GetValue ())
    TOOLS::ExitToolbox (2);

  switch(thisCliOpt.GetPrimaryFlag()) {
    case FLAG_INTERNAL: {
      batchInternal(thisCliOpt);
      break;
    }
    case FLAG_INTERPRETER: {
      batchInterpreter(thisCliOpt, argv);
      break;
    }
    case FLAG_SYNTAXCHECK: {
      batchSyntaxCheck(thisCliOpt);
      break;
    }
    case FLAG_PRETTYPRINT: {
      batchPrettyPrint(thisCliOpt);
      break;
    }
    case FLAG_TYPECHECKER:
    case FLAG_CPPCG:
    case FLAG_JAVACG: {
      batchTypeCheckerAndCG(thisCliOpt);
      break;
    }
    case FLAG_POG:
    case FLAG_POGTEST: {
      batchPOG(thisCliOpt, argv);
      break;
    }
    case FLAG_EXTERNAL: {
// 20150319 -->
// not used
/*
      TOOLS::ExternalParseService(thisCliOpt);
*/
// <-- 20150319
      break;
    }
    default: break;
  }
}

void RunInteractiveMode(int argc, char *argv[], CLIOptions & thisCliOpt)
{
  // Mode: command-mode
  wstring err;
  if(!TOOLS::InitCorbaApi(argc, argv, err)) {
    wcerr << L"Unable to initialise CORBA API. " << err << endl << flush;
    exit(1);
  }

  TOOLS::DisplayVersion( vdm_log );
  TOOLS::InitToolbox (false);
  TOOLS::ReadStartUpFile ();
  ToolMediator::BTools ()->vdm_SyntaxCheck (thisCliOpt.GetFileList());

  wstring scriptfile (thisCliOpt.GetOptionalScript());
  if (!scriptfile.empty())
  {
    TOOLS::ReadScriptFile(scriptfile);
  }

  if (!thisCliOpt.QuitToolBox())
  {
    // Enable the signal handler
    signal(SIGINT, StopButton);

    ToolMediator::Interf ()->vdm_ExecuteMainLoop ();
  }
}

int main (int argc, char *argv[])
{
  SEQ<Char> myname (TBUTILS::tb_getbasename(TBWSTR::string2wstring(string(argv[0]))));
  Settings.SetName(myname);

  setlocale(LC_ALL, "");
  setlocale(LC_CTYPE, NULL);

  // Set numelic locale to English
  TBUTILS::setLCNumericEnglish();

  // Set encoding for File System
  TBWSTR::setCodePageEnv(TBUTILS::GetDefaultCodePage());

  // Set flush mode.
  ebuf.SetLog (report_error);

  (void) VDMSetErrorHandler(TB_Exception::EXC_ThrowHandler);

  CLIOptions thisCliOpt;
  cliOpt = &thisCliOpt;

// 20100409 -->
  Settings.InvOff();
  Settings.DtcOff();
  Settings.PreOff();
  Settings.PostOff();
  Settings.AssertOff();
  Settings.DoCheckOff();
// <-- 2010409

  bool batchMode = thisCliOpt.ProcessOptions(argc, argv);

  // Initialise the types defined in the modules.
  TOOLS::InitModuleTypes();

  // Set up the ToolKit
  //  (we use the default settings of vdm_log and vdm_err)

  //  The Errors class must be initiated with a state.
  //  This is PromptErr in case of Ascii interface,
  //  and BatchErr in case of GUI or batch version.
  type_ref_Interface if_r (new AsciiInterface ());

  vdm_BatchErr batchErr;
  type_ref_ErrorState batch_state (&batchErr);

  vdm_PromptErr promptErr;
  type_ref_ErrorState prompt_state (&promptErr);

  vdm_Errors * errs = new AsciiErrors();
  if (batchMode)
    errs->vdm_InitState(batch_state);
  else
    errs->vdm_InitState(prompt_state);
  type_ref_Errors errs_r (errs);

  vdm_Errors * exprerrs = new AsciiErrors();
  exprerrs->vdm_InitState(batch_state);
  type_ref_Errors exprerrs_r (exprerrs);

  vdm_ToolKit toolkit;
  toolkit.vdm_Init (if_r, errs_r, exprerrs_r);
  //

  if (batchMode)
  {
    RunBatchMode(argc, argv, thisCliOpt);
  }
  else
  {
// 20100409 -->
    Settings.InvOn();
    Settings.DtcOn();
    Settings.PreOn();
    Settings.PostOn();
    Settings.DoCheckOn();
// <--20121026
    RunInteractiveMode(argc, argv, thisCliOpt);
  }
#ifdef VDMPP
  ToolMediator::UMLT()->vdm_TerminateUMLMapper();
#endif // VDMPP
  TOOLS::ExitToolbox(0);               // So output streams are flushed.

  return(0);
}

#ifdef SHOW_MALLOC_STATS
#include "stdio.h"

class ShowBuildCount {
public:
  ShowBuildCount() { printf(L"\nInitial buildcount=%d\n", MetaivVal::BuildCount); }
  ~ShowBuildCount() { printf(L"\nInitial buildcount=%d\n", MetaivVal::BuildCount); }
};

ShowBuildCount showbuildcount; /*  */

#endif //SHOW_MALLOC_STATS

