%--------------------------------------------------------------------------------
% $Id: contextinfo.vdm,v 1.23 2002/12/19 12:46:20 mikhail Exp $
% Implemented in: contextinfo.w, tokenlist.h
%--------------------------------------------------------------------------------
\section{Module CI}

It is possible to attached context information on every node in the
Abstract Syntax Tree (AST). An example of this is position information and
type information. 

The context information is modelled as a pointer mechanism: Every node in
the AST has an abstract field containing a context identifier. This
identifier points into a table containing the context information of the
node. The context information is described in this module.

\insertfig{cntxt.idr}{12cm}{The overall structure of the context information and token list}{\label{fig:cntxt}}

\begin{vdm_al}
--module CI
class CI


--imports
--  from REP all,
--  from AS all
--
--exports 
--    all
--
--definitions
\end{vdm_al}


The {\em ContextId} is the context identifier being placed on every node in
the AST. The {\em ContextId} is an int (but only -1 is allowed in the
negative range). The first 10 bits of the context identifier models the
module identifier, and the next 22 bits models the node identfier.

\begin{vdm_al}
 types
public
     ContextId = int;   -- was nat, but changed because of NilContextId

public
     NodeId = nat
     inv nid == nid < MaxNid -1;

public
     FileId = nat
     inv fid == fid < MaxFid -1;

public
     TypeInfo = REP`TypeRep;
values

--   MaxNid: nat = 2**22;
public
   MaxNid: nat = 2**24;
public
   MaxFid: nat = 2**10;

public
   NilContextId: int = -1;
\end{vdm_al}

During interpretation of the dynamic semantics, type checking in the static
checker and code generation in the code generator, there is a need for
constructing temporary AST parts and thereby to construct temporary
context id's. Therefore for each component (intepreter, code generator and
type checker) a special entry is reserved:
\begin{vdm_al}

public
   CGEntry: nat = 1;
public
   IPEntry: nat = 2;
public
   TCEntry: nat = 3;
\end{vdm_al}


\begin{vdm_al}
--state Sigma of
--  tll_ci : seq of TokenContextInfo
--  fid_m : FileIdMap
--init s == s = mk_Sigma([],{|->})
--end
instance variables
private
  tll_ci : seq of TokenContextInfo := [];
private
  fid_m : FileIdMap := {|->};

types 
public
TokenContextInfo::
  tll : TokenList
  ci  : ContextInfo;

public
ContextInfo = seq of ContextNodeInfo;
public
FileIdMap = map FileId to seq of char;
\end{vdm_al}

The state of the context information consists of:

\begin{itemize}
\item tll\_ci: The context information and token-list for each file. This
  sequence is index with the \emph{FileId}. It is a sequence where each
  element corresponds to one file and these elements contain the following
  sub elements:
  \begin{itemize}
  \item A sequence of {\em TokenInfo}, i.e.\ the tokens from the input
    file. The order of the elements in the sequence is equal to the order
    of the tokens in the input file.
  \item A sequence of {\em ContextNodeInfo}, i.e.\ all necessary
    context information for each node in the AST. The key to the
    sequence is the {\em NodeId}.
  \end{itemize}
\item fid\_m: The mapping from file identifiers, {\em FileId}, to the
  file name.
\end{itemize}

For every file a sequence of the VDM tokens is generated, the {\em
  TokenList} describes the data type of this sequence.

\begin{vdm_al}
public
TokenList = seq of TokenInfo;
\end{vdm_al}

A {\em TokenInfo} consists of:

\begin{itemize}
\item lexid: The token identifier as given by the lex scanner (maybe
  used by the pretty printer).
\item text: The text of an identifier (used only by the pretty printer).
\item pos\_st: Position of the first char in the token.
\item pos\_end: Position of the last char in the token.
\end{itemize}

\begin{vdm_al}
public
TokenInfo ::
  lexid   : LexId
  text    : TextId
  pos_st  : TokenPos
  pos_end : TokenPos;

public
LexId = int;

public
TextId = seq of char;
\end{vdm_al}

The token position contains the section position and the line and
column positions. For \LaTeX\ documents the section position will
always be one. The section field is used for RTF documents.

The \texttt{relAbs\_line} is an absolute line, except that line information
is not counted. That is lines of the kind \texttt{-- Line }. These lines
are generated by the RTF parser, but are not located in the input RTF
file. This is a semi hack to get breakpoints on lines working (see TB54).

\begin{vdm_al}
public
TokenPos ::
  section: Section
  abs_line : Line
  relAbs_line : Line
  sec_line : Line
  column : Column;

public
Section = nat;
public
Line = nat;
public
Column = nat;
\end{vdm_al}


The token span, {\em TokenSpan}, describes which tokens a node
consists of: described by the start token and the end token in the
token list, and the \emph{middle} token (named \texttt{token\_ast}).

\begin{vdm_al}
public
TokenSpan ::
  token_st  : TokenRef
  token_ast : TokenRef
  token_end : TokenRef;

public
TokenRef = int;
\end{vdm_al}


The {\em ContextInfo} is the information that can be related to a node
in the AST:
\begin{itemize}
\item tokenpos: The token span, i.e.\ a link to the tokens in the
  token list that the node consists of.
\item coverage: The test coverage information.
\item typeinfo: Type information. This is inserted by the type
  checker, and used by the code generator.
\item pid-m: type information for patterns in comprehensions. This
  information is also inserted by the type checker and used by the
  code generator.  
\item index: Index information. Used to generate index information by
  the pretty printer.
\item isBreakable: This flag is true if it is possible to berak at this
context id. It is possible to vreak at a context id, if the id is located
in a program table.
\end{itemize}

\begin{vdm_al}

public
     ContextNodeInfo ::
        tokenpos : [TokenSpan]
        coverage : TestCoverageInfo
        typeinfo : [TypeInfo]
        pid_m    : [ map AS`Name to REP`TypeRep ]
        index    : [IndexInfo]
        isBreakable : bool
        breakpoint  : bool ;

public
     TestCoverageInfo = int;
public
     IndexInfo = nat

values
public
  InitCntxtNodeInfo: ContextNodeInfo = mk_ContextNodeInfo( nil, -1, nil, nil, nil, false, false)

\end{vdm_al}

The functions {\em ConvCid2Mid} and {\em ConvCid2Nid} are used to
convert context identifiers to module and node identifiers respectively.
\begin{vdm_al}
functions

public
  ConvCid2Fid: ContextId -> FileId
  ConvCid2Fid(cid) ==
    cid div MaxNid;

public
  ConvCid2Nid: ContextId -> NodeId
  ConvCid2Nid(cid) ==
    cid mod MaxNid;

public
  SplitCid: ContextId -> FileId * NodeId
  SplitCid(cid) ==
    mk_(ConvCid2Fid(cid), ConvCid2Nid(cid));

\end{vdm_al}

The functions {\em IsAValidFileId\/} and {\em IsAValidContextId\/} test whether a {\em FileId\/} and
 {\em ContextId\/} respectively is defined in {\em tll\_ci}.

\begin{vdm_al}
operations
public
  IsAValidFileId: FileId ==> bool
  IsAValidFileId (fid) ==
    return fid in set inds tll_ci;

public
  IsAValidContextId: ContextId ==> bool
  IsAValidContextId (cid) ==
    if cid <> NilContextId
    then let mk_(fid,nid) = SplitCid(cid)
         in
           return fid in set inds tll_ci and nid in set inds tll_ci(fid).ci
    else return false
\end{vdm_al}


\subsection{Initialisation}
The operation {\em UseContextTab} initializes the information for a file identifier.

\begin{vdm_al}
operations

public
  UseContextTab: FileId * bool ==> ()
  UseContextTab(fid, reset) ==
   (if len tll_ci < fid
    then 
       tll_ci := tll_ci ^ [mk_TokenContextInfo([],[]) | - in set {len tll_ci + 1,...,fid}];
    if reset
    then 
      tll_ci(fid) := mk_TokenContextInfo([],[])
   );

\end{vdm_al}

The operation {\em Push} adds an entry in the context table for
a file id and returns a new corresponding {\em ContextId}.

\begin{vdm_al}
public
  Push: FileId ==> ContextId
  Push(fid) ==
    let mk_TokenContextInfo(tll,ci) = tll_ci(fid)
    in
     (tll_ci(fid) := mk_TokenContextInfo(tll, ci ^ [ InitCntxtNodeInfo ]);
      return  fid*MaxNid + len ci + 1)
  pre IsAValidFileId(fid);

\end{vdm_al}

\subsection{Type Information}

The operation {\em GetTypeInfo} extracts the type information for a given context identifier. 

\begin{vdm_al}
operations
public
  GetTypeInfo: ContextId ==> [REP`TypeRep]
  GetTypeInfo(cid) ==
    let mk_(fid,nid) = SplitCid(cid),
        mk_TokenContextInfo(-,ci) = tll_ci(fid) in
    return ci(nid).typeinfo
  pre HasTypeInfo(cid) and IsAValidContextId(cid);

\end{vdm_al}
The operation {\em GetJSSTypeInfo} extracts the Java Static Semantics type information 
for a given context identifier. 

\begin{vdm_al}
public
  GetJSSTypeInfo: ContextId ==> [TypeInfo]
  GetJSSTypeInfo(cid) ==
    let mk_(fid,nid) = SplitCid(cid),
        mk_TokenContextInfo(-,ci) = tll_ci(fid) in
    return ci(nid).typeinfo
  pre HasTypeInfo(cid) and IsAValidContextId(cid);

\end{vdm_al}

The opeation {\em SetTypeInfo} sets the type information for a given context identifier.

\begin{vdm_al}
public
SetTypeInfo: ContextId * REP`TypeRep ==> ()
SetTypeInfo(cid, type) ==
  let mk_(fid, nid) = SplitCid(cid) in
      tll_ci(fid).ci(nid).typeinfo := type
  pre IsAValidContextId(cid);

\end{vdm_al}

The opeation {\em SetJSSTypeInfo} sets the Java Static Semantics type information 
for a given context identifier.

\begin{vdm_al}
public
SetJSSTypeInfo: ContextId * [TypeInfo] ==> ()
SetJSSTypeInfo(cid, type) ==
  let mk_(fid, nid) = SplitCid(cid) in
      tll_ci(fid).ci(nid).typeinfo := type
  pre IsAValidContextId(cid);
\end{vdm_al}

The operation {\em HasTypeInfo} determines if type information is
available for a given context identifier. The operation is used in
invariant functions for the nodes that should contain type
information. 

\begin{vdm_al}
public
 HasTypeInfo: ContextId ==> bool
 HasTypeInfo(cid) ==
 return 
   IsTypeChecked() => let mk_(fid, nid) = SplitCid(cid)
                      in tll_ci(fid).ci(nid).typeinfo <> nil;
\end{vdm_al}


The operation {\em GetPidM} extracts type information for pattern
names for a given context identifier.
\begin{vdm_al}
public
 GetPidM: ContextId ==> map AS`Name to REP`TypeRep
 GetPidM(cid) ==
   let mk_(fid, nid) = SplitCid(cid)
   in return tll_ci(fid).ci(nid).pid_m
 pre IsAValidContextId(cid) and HasPidMInfo(cid);
\end{vdm_al}

The operation {\em SetPidM} sets type information for pattern names
for a given context identifier:

\begin{vdm_al}
public
SetPidM: ContextId * map AS`Name to REP`TypeRep ==> ()
SetPidM(cid, pidm) ==
  let mk_(fid,nid) = SplitCid(cid)
  in tll_ci(fid).ci(nid).pid_m := pidm
pre IsAValidContextId(cid);
\end{vdm_al}

The operation {\em HasPidMInfo} determines if type information for
pattern name is available for a given context identifier. The
operation is used in invariant functions for the nodes that should
contain type information for pattern name.

\begin{vdm_al}
public
 HasPidMInfo: ContextId ==> bool
 HasPidMInfo(cid) ==
   return
     IsTypeChecked() => let mk_(fid, nid) = SplitCid(cid)
                        in tll_ci(fid).ci(nid).pid_m <> nil
pre IsAValidContextId(cid);
\end{vdm_al}


The operation {\em IsTypeChecked} determines if the specification has
been type checked, and thus, if type information for the node on AST
has been generated. 

For testing at the specification level this operation have been set to
return false in order to allow pre-consition checking of the specification.
\begin{vdm_al}
public
IsTypeChecked: () ==> bool
IsTypeChecked() ==
  return false;

\end{vdm_al}


\subsection{Position Information}

\begin{vdm_al}
public
  GetFileLineColPos: ContextId ==> seq of char * Line * Column
  GetFileLineColPos(cid) ==
    def mk_(found, fid, -, pos_ast, -) = GetFilePos(cid)
    in if found
       then let fileName = fid_m(fid),
            mk_TokenPos(-, abs_line,-,-,column) = pos_ast
            in return mk_(fileName, abs_line, column)
       else error;
        
\end{vdm_al}

The operation {\em GetPos} extracts the token span of a given node
(represented by its context identifier), i.e.\ the first and the last
token that the node consists of.

\begin{vdm_al}
public
 GetPos: ContextId ==> [TokenSpan]
 GetPos(cid) ==
   let mk_(fid, nid) = SplitCid(cid) in
   return tll_ci(fid).ci(nid).tokenpos
 pre IsAValidContextId(cid);

\end{vdm_al}


The operation {\em SetPosInfo} sets the token span for a specific node
(represented by its context identifier).

\begin{vdm_al}
public
 SetPos: ContextId * TokenSpan ==> ()
 SetPos(cid, pos) ==
   let mk_(fid, nid) = SplitCid(cid)
   in tll_ci(fid).ci(nid).tokenpos := pos
 pre IsAValidContextId(cid);
\end{vdm_al}

Note the boolean is used in the implementation to signal an internal error if the
element was not found.

\begin{vdm_al}
public
  GetFilePos: ContextId ==> bool * FileId * TokenPos * TokenPos * TokenPos
  GetFilePos(cid) ==
   let mk_(fid, nid) = SplitCid(cid),
       mk_TokenSpan(sta,ast,en) = tll_ci(fid).ci(nid).tokenpos,
       mk_TokenInfo(-,-,tst,-) = tll_ci(fid).tll(sta),
       mk_TokenInfo(-,-,-,ten) = tll_ci(fid).tll(en),
       mk_TokenInfo(-,-,ast_start,-)   = tll_ci(fid).tll(ast)
   in
   return mk_(true, fid, tst, ast_start, ten)
  pre IsAValidContextId(cid) and 
      let mk_(fid,nid) = SplitCid(cid)
      in tll_ci(fid).ci(nid).tokenpos <> nil;

public
  GetLocation : ContextId ==> nat * nat
  GetLocation (cid) ==
    def mk_(-,-,-,ast,-) = GetFilePos(cid);
        line = ast.abs_line;
        col  = ast.column 
     in 
        return mk_(line,col); 
\end{vdm_al}


\subsection{Inverse position information}

\begin{vdm_al}

types
public
  Point :: x: nat
           y: nat;

operations

public
  GetCidAtPos: seq of char * int * int ==> bool * seq of char * [ContextId]
  GetCidAtPos(file, line, col) ==
    def fid = GetFidForFile(file)
    in if fid = nil
       then return mk_(false, "No such file", nil)
       else def ci : ContextInfo = tll_ci(fid).ci;
                tll : TokenList = tll_ci(fid).tll;
                mk_(found, nodeId) = FindPosInContextInfo(ci, tll, line, col)
            in if found
               then return mk_(true, "", CreateCid(fid, nodeId))
               else return mk_(false, "Position beyond end of file", NilContextId);


public
  GetFidForFile: seq of char ==> [FileId]
  GetFidForFile(file) ==
    --let m = inverse fid_m
    --in if file in set dom m
    --   then return m(file)
    --   else return nil;
    return 
      cases fid_m:
        { fid |-> (file) } munion - -> fid,
        others                      -> nil
      end;

public
  FindPosInContextInfo: ContextInfo * TokenList * int * int ==> bool * [NodeId]
  FindPosInContextInfo(ci, tll, line, col) ==
  ( dcl closestPoint  : Point := mk_Point(2**32, 2**32),
        minNid  : NodeId := 0;
    for index = 1 to len(ci) do
      let cni = ci(index),
          tokenpos : [TokenSpan] = cni.tokenpos
      in if tokenpos = nil or tokenpos.token_ast = -1
            or not cni.isBreakable
         then skip
         else let token_ast : TokenRef = tokenpos.token_ast,
                  token_info : TokenInfo = tll(token_ast),
                  token_st : TokenPos = token_info.pos_st,
                  token_len : nat = len(token_info.text),
                  curLine : Line = token_st.relAbs_line,
                  curCol : Column = token_st.column
              in if PointCloser(mk_Point(col,line), closestPoint, mk_Point(curCol+token_len-1, curLine))
                 then ( closestPoint := mk_Point(curCol, curLine);
                        minNid := index );
     if minNid = 0
     then return mk_(false, 0)
     else return mk_(true, minNid));

public
  PointCloser: Point * Point * Point ==> bool
  PointCloser(searchPoint, closestPoint, candidate) ==

    if candidate.y < searchPoint.y or 
       (candidate.y = searchPoint.y and candidate.x < searchPoint.x)
    then return false -- Candidate is before the point we search for.

    else return candidate.y < closestPoint.y or
                candidate.y = closestPoint.y and candidate.x < closestPoint.x;
             
  -- implemented as `cid' in contextinfo.w
public
  CreateCid: FileId * NodeId ==> ContextId
  CreateCid(fid,nid) ==
    return fid*MaxNid + nid;

\end{vdm_al}

\subsection{Breakpoint Handling}


\begin{vdm_al}

public
  IsCidBreakable: ContextId ==> bool
  IsCidBreakable(cid) ==
    let mk_(fid,nid) = SplitCid(cid)
    in return tll_ci(fid).ci(nid).isBreakable;

public
  SetBreakable: ContextId ==> ()
  SetBreakable(cid) ==
    let mk_(fid,nid) = SplitCid(cid)
    in tll_ci(fid).ci(nid).isBreakable := true;

public
  SetBreakpoint: ContextId ==> ()
  SetBreakpoint(cid) ==
    let mk_(fid,nid) = SplitCid(cid)
    in tll_ci(fid).ci(nid).breakpoint := true;

public
  RemoveBreakpoint: ContextId ==> ()
  RemoveBreakpoint(cid) ==
    let mk_(fid,nid) = SplitCid(cid)
    in tll_ci(fid).ci(nid).breakpoint := false;
            
public
  IsBreakpointAtCid: ContextId ==> bool
  IsBreakpointAtCid(cid) ==
    let mk_(fid,nid) = SplitCid(cid)
    in return tll_ci(fid).ci(nid).breakpoint;


\end{vdm_al}


\subsection{Test Coverage Information}

The operation {\em GetTestCoverageInfo} extracts the test coverage
information for a give context identifier.

\begin{vdm_al}

public
GetTestCoverageInfo: ContextId ==> TestCoverageInfo
GetTestCoverageInfo(cid) ==
let mk_(fid,nid) = SplitCid(cid)
in return tll_ci(fid).ci(nid).coverage
pre IsAValidContextId(cid);
\end{vdm_al}


\begin{vdm_al}
public
IncTestCoverageInfo: ContextId  ==> ()
IncTestCoverageInfo(cid) ==
let mk_(fid,nid) = SplitCid(cid)
in tll_ci(fid).ci(nid).coverage := tll_ci(fid).ci(nid).coverage + 1
pre IsAValidContextId(cid)

\end{vdm_al}

\subsection{Construction of temporary Context Information}

In the dynamic semantics, the type checker and the interpreter
temporary subparts of the AST is constructed. As a consequence
temporary context information should also be constructed. Three
reserved file identifiers in the {\em ContextInfo} table have been
reserved for storing temporary context information. 

The operations in this subsection all works on these temporary context
information.

\begin{vdm_al}
operations

public
ResetCGTable: () ==> ()
ResetCGTable() ==
UseContextTab(CGEntry,true);

public
ResetIPTable: () ==> ()
ResetIPTable() ==
UseContextTab(IPEntry,true);

public
ResetTCTable: () ==> ()
ResetTCTable() ==
UseContextTab(TCEntry,true);
 
\end{vdm_al}

\begin{vdm_al}
public
PushCGPosType: [TokenSpan ] * [REP`TypeRep] ==> ContextId
PushCGPosType(pos, type) ==
  def cid = Push(CGEntry)
  in
   (SetTypeInfo(cid, type);
    SetPos(cid, pos);
    return cid;
   );

public
PushCGType: [REP`TypeRep] ==> ContextId
PushCGType(type) ==
  def cid = Push(CGEntry)
  in
   (SetTypeInfo(cid, type);
    return cid;
   );
\end{vdm_al}


\subsection{Updating the State}


\begin{vdm_al}
public
UpdateStateSigma: seq of TokenContextInfo * FileIdMap ==> ()
UpdateStateSigma(tllci,fidm) ==
( if (exists i in set (inds tll_ci inter inds tllci) & 
           tllci(i) <> mk_TokenContextInfo([],[]) and
           tll_ci(i) <> mk_TokenContextInfo([],[])) or
     (exists fid in set dom fidm inter dom fid_m & fidm(fid) <> fid_m(fid))
  then error
  else
  ( let tllci_indexset = { i | i in set inds tllci & i <= len tll_ci and 
                               tllci(i) <> mk_TokenContextInfo([],[]) } in
    for all i in set tllci_indexset do
      tll_ci(i) := tllci(i);
    for i = len tll_ci + 1 to len tllci do
      tll_ci := tll_ci ^ [ tllci(i) ];
    fid_m := fid_m ++ fidm )
)

end CI
\end{vdm_al}
