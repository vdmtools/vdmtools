\subsection{Sequence}
\subsubsection{Ó”C}
	—ñ‚ğ•\‚·B
\subsubsection{ŠT—v}
	SequenceŒ^‚Å’è‹`‚³‚ê‚½‹@”\ˆÈŠO‚Ì‹@”\‚ğ’è‹`‚·‚éB
\subsubsection{’ˆÓ–€}
	—ğj“IŒo‰ß‚Ì‚½‚ßA‚æ‚èŠÖ”Œ^ƒvƒƒOƒ‰ƒ~ƒ“ƒO‚É“K‚µ‚½ŠÖ”‚ÆA‚»‚¤‚Å‚È‚¢‚à‚Ì‚ª‚ ‚éB
	ŠÖ”Œ^ƒvƒƒOƒ‰ƒ~ƒ“ƒO‚É“K‚µ‚½ŠÖ”‚ÍA‰pš–¼‚Ìê‡‘å•¶š‚Ån‚Ü‚éB
	‘å•¶š‚Ån‚Ü‚é“¯ˆê–¼‚ÌŠÖ”‚ª‚ ‚éê‡A¬•¶š‚Ån‚Ü‚éŠÖ”E‘€ì‚ÍAŒÃ‚¢’è‹`‚ÅAŒİŠ·«‚Ì‚½‚ß‚É‘¶İ‚·‚éB
	‘å•¶š‚Ån‚Ü‚é“¯ˆê–¼‚ÌŠÖ”‚ª–³‚¢ê‡‚ÍA¬•¶š‚Ån‚Ü‚éŠÖ”E‘€ì‚àŠÖ”Œ^ƒvƒƒOƒ‰ƒ~ƒ“ƒO‚É“K‚µ‚Ä‚¢‚éB
\subsubsection{QÆ}
	‘½‚­‚ÌŠÖ”‚ÍAŠÖ”Œ^ƒvƒƒOƒ‰ƒ~ƒ“ƒOŒ¾ŒêConcurrent Clean‚Ìƒ‰ƒCƒuƒ‰ƒŠ[‚©‚çˆÚA‚µ‚½B

\begin{vdm_al}	
class Sequence

values

	Rcsid = "$Id: Sequence.vpp,v 1.1 2005/10/31 02:15:42 vdmtools Exp $";
	
functions 

--—ñs‚Ì—v‘f‚Ì‡Œv‚ğ•Ô‚·B
static public ƒ°[@Œ^]: seq of @Œ^ ->  @Œ^
ƒ°(—ñ) == ƒ°•â•ŠÖ”[@Œ^](—ñ)(0)
pre
	is_(—ñ, seq of int) or is_(—ñ, seq of nat) or is_(—ñ, seq of nat1) or
 	is_(—ñ, seq of real) or is_(—ñ, seq of rat);

static ƒ°•â•ŠÖ”[@Œ^] : seq of @Œ^ -> @Œ^ -> @Œ^
ƒ°•â•ŠÖ”(—ñ)(‡Œv) ==
	if —ñ = [] then
		‡Œv
	else
		ƒ°•â•ŠÖ”[@Œ^](tl —ñ)(‡Œv + hd —ñ);

--—ñs‚Ì‘S—v‘f‚ÌÏ‚ğ•Ô‚·
static public ƒ®[@Œ^]: seq of @Œ^ ->  @Œ^
ƒ®(—ñ) == ƒ®•â•ŠÖ”[@Œ^](1)(—ñ)
pre
	is_(—ñ, seq of int) or is_(—ñ, seq of nat) or is_(—ñ, seq of nat1) or
 	is_(—ñ, seq of real) or is_(—ñ, seq of rat);
 	
static ƒ®•â•ŠÖ”[@Œ^] : @Œ^ -> seq of @Œ^ -> @Œ^
ƒ®•â•ŠÖ”(Ï)(—ñ) ==
	cases —ñ :
	[æ“ª] ^ Œã‘±—ñ	-> ƒ®•â•ŠÖ”[@Œ^](Ï * æ“ª)(Œã‘±—ñ),
	[]			-> Ï
	end;

--—ñs‚Ì—v‘f‚Ì•½‹Ï‚ğ‹‚ß‚é
static public •½‹Ï‚ğ“¾‚é[@Œ^]: seq of @Œ^ ->  [real]
•½‹Ï‚ğ“¾‚é(—ñ) == if —ñ = [] then nil else •½‹Ï‚ğ“¾‚é•â•ŠÖ”[@Œ^](0)(0)(—ñ);

static •½‹Ï‚ğ“¾‚é•â•ŠÖ”[@Œ^] : @Œ^ -> @Œ^ -> seq of @Œ^ -> real
•½‹Ï‚ğ“¾‚é•â•ŠÖ”(‡Œv)(—v‘f”)(—ñ) ==
	cases —ñ :
	[æ“ª] ^ Œã‘±—ñ	-> •½‹Ï‚ğ“¾‚é•â•ŠÖ”[@Œ^](‡Œv + æ“ª)(—v‘f” + 1)(Œã‘±—ñ),
	[]			-> ‡Œv / —v‘f”
	end;

--ŠÖ”f‚Å—^‚¦‚ç‚ê‚½‘S‡˜‚ÅA—ñs‚Ì—v‘f‚ª¸‡‚Å‚ ‚é‚©”Û‚©‚ğ•Ô‚·B
static public ‘S‡˜¸‡‚©H [@Œ^]:
	(@Œ^ * @Œ^ -> bool) -> seq of @Œ^ -> bool
‘S‡˜¸‡‚©H (‡˜Œˆ’èŠÖ”)(—ñ) ==
	forall i,j  in set inds —ñ & i < j  => ‡˜Œˆ’èŠÖ”(—ñ(i),—ñ(j)) or —ñ(i) = —ñ(j);

--ŠÖ”f‚Å—^‚¦‚ç‚ê‚½‘S‡˜‚ÅA—ñs‚Ì—v‘f‚ª~‡‚Å‚ ‚é‚©”Û‚©‚ğ•Ô‚·B
static public ‘S‡˜~‡‚©H [@Œ^]:
	(@Œ^ * @Œ^ -> bool) -> seq of @Œ^ -> bool
‘S‡˜~‡‚©H (‡˜Œˆ’èŠÖ”)(—ñ) ==
	forall i,j  in set inds —ñ & i < j  => ‡˜Œˆ’èŠÖ”(—ñ(j),—ñ(i)) or —ñ(i) = —ñ(j);

--‰‰Zqƒ‚Å—^‚¦‚ç‚ê‚½‘S‡˜‚ÅA—ñs‚Ì—v‘f‚ª¸‡‚Å‚ ‚é‚©”Û‚©‚ğ•Ô‚·B
static public ¸‡‚©H [@Œ^]: seq of @Œ^ -> bool
¸‡‚©H(—ñ) ==
	‘S‡˜¸‡‚©H [@Œ^](lambda x : @Œ^, y : @Œ^ & x < y)(—ñ);

--‰‰Zqƒ‚Å—^‚¦‚ç‚ê‚½‘S‡˜‚ÅA—ñs‚Ì—v‘f‚ª~‡‚Å‚ ‚é‚©”Û‚©‚ğ•Ô‚·B
static public ~‡‚©H[@Œ^]: seq of @Œ^ -> bool
~‡‚©H(—ñ) ==
	‘S‡˜~‡‚©H [@Œ^](lambda x : @Œ^, y : @Œ^ & x < y)(—ñ);

--ŠÖ”f‚Å—^‚¦‚ç‚ê‚½‡˜‚ÅA—ñs‚Ì—v‘f‚ğ¸‡‚Éƒ\[ƒg‚·‚éB
/*
static public slowsort[@Œ^] : (@Œ^ * @Œ^ -> bool) -> seq of @Œ^ -> seq of @Œ^
slowsort(‡˜Œˆ’èŠÖ”)(—ñ) ==
	cases —ñ:
		[]	-> [],
		[—v‘f]	-> [—v‘f],
		[—v‘f]^-	-> 
			let	¶ = sort[@Œ^](‡˜Œˆ’èŠÖ”)([—ñ(i) | i in set inds —ñ & ‡˜Œˆ’èŠÖ”(—ñ(i),—v‘f)]),
				’† = [—ñ(i) | i in set inds —ñ & not ‡˜Œˆ’èŠÖ”(—ñ(i),—v‘f) and
                                                                     not ‡˜Œˆ’èŠÖ”(—v‘f,—ñ(i))],
				‰E = sort[@Œ^](‡˜Œˆ’èŠÖ”)([—ñ(i) | i in set inds —ñ & ‡˜Œˆ’èŠÖ”(—v‘f,—ñ(i))])
			in
				¶ ^ ’† ^ ‰E
	end;
*/
	
--ŠÖ”f‚Å—^‚¦‚ç‚ê‚½‡˜‚ÅA—ñs‚Ì—v‘f‚ğ¸‡‚ÉƒNƒCƒbƒNƒ\[ƒg‚·‚éB
static public sort[@Œ^] : (@Œ^ * @Œ^ -> bool) -> seq of @Œ^ -> seq of @Œ^
sort(‡˜Œˆ’èŠÖ”)(—ñ) ==
	cases —ñ:
		[]	-> [],
		[—v‘f]^•”•ª—ñ	-> 
			sort[@Œ^](‡˜Œˆ’èŠÖ”)([•”•ª—ñ(i) | i in set inds •”•ª—ñ & ‡˜Œˆ’èŠÖ”(•”•ª—ñ(i),—v‘f)]) ^
			[—v‘f] ^
			sort[@Œ^](‡˜Œˆ’èŠÖ”)([•”•ª—ñ(i) | i in set inds •”•ª—ñ & not ‡˜Œˆ’èŠÖ”(•”•ª—ñ(i),—v‘f)])
	end;

--‰‰Zqƒ‚Å—^‚¦‚ç‚ê‚½‡˜‚ÅA—ñs‚Ì—v‘f‚ğ¸‡‚Éƒ\[ƒg‚·‚éB
static public ¸‡Sort[@Œ^] : seq of @Œ^ -> seq of @Œ^
¸‡Sort(—ñ) == sort[@Œ^](lambda x : @Œ^, y : @Œ^ & x < y)(—ñ);

--‰‰Zq„‚Å—^‚¦‚ç‚ê‚½‡˜‚ÅA—ñs‚Ì—v‘f‚ğ¸‡‚Éƒ\[ƒg‚·‚éB‰‰Zqƒ‚©‚çŒ©‚ê‚Î~‡B
static public ~‡Sort[@Œ^] : seq of @Œ^ -> seq of @Œ^
~‡Sort(—ñ) == sort[@Œ^](lambda x : @Œ^, y : @Œ^ & x > y)(—ñ);

--‡˜Œˆ’èŠÖ”—ñ‚Å—^‚¦‚ç‚ê‚½‡˜‚Å‚ ‚ê‚ÎtrueA‚»‚¤‚Å‚È‚¯‚ê‚Îfalse‚ğ•Ô‚·B
static public ‡˜’Ê‚è‚©H[@Œ^] : seq of (@Œ^ * @Œ^ -> bool) -> seq of @Œ^ -> seq of @Œ^ -> bool
‡˜’Ê‚è‚©H(‡˜Œˆ’èŠÖ”—ñ)(—ñ1)(—ñ2) ==
	cases mk_(—ñ1,—ñ2):
		mk_([],[])		-> false,
		mk_([],-)		-> true,
		mk_(-,[])	-> false,
		mk_([æ“ª1]^Œã‘±1,[æ“ª2]^Œã‘±2)	->
			if (hd ‡˜Œˆ’èŠÖ”—ñ)(æ“ª1,æ“ª2) then
				true
			elseif (hd ‡˜Œˆ’èŠÖ”—ñ)(æ“ª2,æ“ª1) then
				false
			else
				Sequence`‡˜’Ê‚è‚©H[@Œ^](tl ‡˜Œˆ’èŠÖ”—ñ)(Œã‘±1)(Œã‘±2)
	end;

--ŠÖ”f‚Å—^‚¦‚ç‚ê‚½‡˜‚ÅA—ñs1,s2‚Ì—v‘f‚ğƒ}[ƒW‚·‚éB
static public ƒ}[ƒW‚·‚é[@Œ^] : (@Œ^ * @Œ^ -> bool) -> seq of @Œ^ -> seq of @Œ^ -> seq of @Œ^
ƒ}[ƒW‚·‚é(‡˜Œˆ’èŠÖ”)(s1)(s2) == 
	cases mk_(s1,s2):
		mk_([], y)						-> y,
		mk_(x, [])						-> x,
		mk_([æ“ª1]^Œã‘±1,[æ“ª2]^Œã‘±2)		->
			if ‡˜Œˆ’èŠÖ”(æ“ª1,æ“ª2) then
				[æ“ª1] ^ Sequence`ƒ}[ƒW‚·‚é[@Œ^](‡˜Œˆ’èŠÖ”)(Œã‘±1)(s2)
			else
				[æ“ª2] ^ Sequence`ƒ}[ƒW‚·‚é[@Œ^](‡˜Œˆ’èŠÖ”)(s1)(Œã‘±2)
	end;

--—ñ‚Ìw’è‚³‚ê‚½ˆÊ’u‚É—v‘f‚ğ’Ç‰Á‚·‚éB
static public InsertAt[@Œ^]: nat1 -> @Œ^ -> seq of @Œ^ -> seq of @Œ^
InsertAt(ˆÊ’u)(—v‘f)(—ñ) ==
	cases mk_(ˆÊ’u, —ñ) :
	mk_(1, —ñ)				-> [—v‘f] ^ —ñ,
	mk_(-, [])				-> [—v‘f],
	mk_(ˆÊ’u, [æ“ª] ^ Œã‘±—ñ)	-> [æ“ª] ^ InsertAt[@Œ^](ˆÊ’u - 1)(—v‘f)(Œã‘±—ñ)
	end;

--—ñ‚Ìw’è‚³‚ê‚½ˆÊ’u‚Ì—v‘f‚ğíœ‚·‚éB
static public RemoveAt[@Œ^]: nat1 -> seq of @Œ^ -> seq of @Œ^
RemoveAt(ˆÊ’u)(—ñ) ==
	cases mk_(ˆÊ’u, —ñ) :
	mk_(1, [-] ^ Œã‘±—ñ)		-> Œã‘±—ñ,
	mk_(ˆÊ’u, [æ“ª] ^ Œã‘±—ñ)	-> [æ“ª] ^ RemoveAt[@Œ^](ˆÊ’u - 1)(Œã‘±—ñ),
	mk_(-, [])				-> []
	end;

--—ñ‚©‚çd•¡‚·‚é—v‘f‚ğíœ‚·‚éB
static public RemoveDup[@Œ^] :  seq of @Œ^ ->  seq of @Œ^
RemoveDup(—ñ) == 
	cases —ñ :
	[æ“ª]^Œã‘±		-> [æ“ª] ^ RemoveDup[@Œ^](filter[@Œ^](lambda x : @Œ^ & x <> æ“ª)(Œã‘±)) ,
	[]			-> []
	end;
	
--—ñ‚©‚ç—v‘f‚ğíœ‚·‚é
static public RemoveMember[@Œ^] :  @Œ^ -> seq of @Œ^ -> seq of @Œ^
RemoveMember(—v‘f)(—ñ) == 
	cases —ñ :
	[æ“ª]^Œã‘±		-> if —v‘f = æ“ª then Œã‘± else [æ“ª] ^ RemoveMember[@Œ^](—v‘f)(Œã‘±),
	[]			-> []
	end;
	
--—ñ‚©‚ç—v‘f‚ğíœ‚·‚é
static public RemoveMembers[@Œ^] :  seq of @Œ^ -> seq of @Œ^ -> seq of @Œ^
RemoveMembers(—v‘f—ñ)(—ñ) == 
	cases —v‘f—ñ :
	[]			-> —ñ,
	[æ“ª]^Œã‘±		-> RemoveMembers[@Œ^](Œã‘±)(RemoveMember[@Œ^](æ“ª)(—ñ))
	end;

--—ñ‚Ìw’è‚³‚ê‚½ˆÊ’u‚Ì—v‘f‚ğw’è‚³‚ê‚½V—v‘f‚Å’u‚«Š·‚¦‚éB
static public UpdateAt[@Œ^]: nat1 -> @Œ^ -> seq of @Œ^ -> seq of @Œ^
UpdateAt(ˆÊ’u)(—v‘f)(—ñ) ==
	cases mk_(ˆÊ’u, —ñ) :
	mk_(-, [])				-> [],
	mk_(1, [-] ^ Œã‘±—ñ)		-> [—v‘f] ^ Œã‘±—ñ,
	mk_(ˆÊ’u,  [æ“ª] ^ Œã‘±—ñ)	-> [æ“ª] ^ UpdateAt[@Œ^](ˆÊ’u - 1)(—v‘f)(Œã‘±—ñ)
	end;

--—ñ‚Ìæ“ªiŒÂ‚©‚ç‚È‚é—ñ‚ğ•Ô‚·B
static public take[@Œ^]: int -> seq of @Œ^ -> seq of @Œ^
take(i)(—ñ) == —ñ(1,...,i);

--—ñ‚Ìæ“ª‚©‚çAŠÖ”‚ğ–‚½‚µ‘±‚¯‚éŠÔ‚Ì•”•ª—ñ‚ğ•Ô‚·B
static public TakeWhile[@Œ^] : (@Œ^ -> bool) -> seq of @Œ^ ->seq of @Œ^
TakeWhile(ŠÖ”)(—ñ) ==
	cases —ñ :
	[æ“ª] ^ Œã‘±—ñ	-> 
		if ŠÖ”(æ“ª) then
			[æ“ª] ^ TakeWhile[@Œ^](ŠÖ”)(Œã‘±—ñ)
		else
			[],
	[]	-> []
	end;

--—ñ‚Ìæ“ªiŒÂ‚ğœ‚­—ñ‚ğ•Ô‚·B
static public drop[@Œ^]: int -> seq of @Œ^ -> seq of @Œ^
drop(i)(—ñ) == —ñ(i+1,...,len —ñ);

--—ñ‚Ìæ“ª‚©‚çAŠÖ”‚ğ–‚½‚³‚È‚¢ŠÔ‚Ì•”•ª—ñ‚ğ•Ô‚·B
static public DropWhile[@Œ^] : (@Œ^ -> bool) -> seq of @Œ^ ->seq of @Œ^
DropWhile(ŠÖ”)(—ñ) ==
	cases —ñ :
	[æ“ª] ^ Œã‘±—ñ	-> 
		if ŠÖ”(æ“ª) then
			DropWhile[@Œ^](ŠÖ”)(Œã‘±—ñ)
		else
			—ñ,
	[]	-> []
	end;

--w’è‚³‚ê‚½—ñ‚ğAæ“ª‚©‚çŠÖ”‚ğ–‚½‚µ‘±‚¯‚éŠÔ‚Ì—ñ‚ÆAŠÖ”‚ğ–‚½‚³‚È‚­‚È‚Á‚ÄˆÈ~‚Ì—ñ‚Ì‘g‚É•ª‚¯‚éB
static public Span[@Œ^] : (@Œ^ -> bool) -> seq of @Œ^ -> seq of @Œ^ * seq of @Œ^
Span(ŠÖ”)(—ñ) ==
	cases —ñ :
	[æ“ª] ^ Œã‘±—ñ	-> 
		if ŠÖ”(æ“ª) then
			let	mk_(ğŒ‚ğ–‚½‚·—ñ, ğŒ‚ğ–‚½‚³‚È‚¢—ñ) = Span[@Œ^](ŠÖ”)(Œã‘±—ñ)
			in
			mk_([æ“ª] ^ ğŒ‚ğ–‚½‚·—ñ, ğŒ‚ğ–‚½‚³‚È‚¢—ñ)
		else
			mk_([], —ñ),
	[]	-> mk_([], [])
	end;

--—ñ‚ÌŠJnˆÊ’u‚©‚ç—v‘f”•ªæ‚èo‚µ‚½•”•ª—ñ‚ğ•Ô‚·
static public SubSeq[@Œ^]: nat -> nat -> seq1 of @Œ^ -> seq of @Œ^
SubSeq(ŠJnˆÊ’u)(—v‘f”)(—ñ) == —ñ(ŠJnˆÊ’u,...,ŠJnˆÊ’u+—v‘f”-1);

--—ñ‚ÌÅŒã‚Ì—v‘f‚ğ•Ô‚·B
static public last[@Œ^]: seq of @Œ^ -> @Œ^
last(—ñ) == —ñ(len —ñ);

--ŠÖ”‚ğ—ñ‚É“K—p‚µ‚½Œ‹‰Ê‚Ì—ñ‚ğ•Ô‚·B
static public fmap[@Œ^1,@Œ^2]: (@Œ^1 -> @Œ^2) -> seq of @Œ^1 -> seq of @Œ^2
fmap(ŠÖ”)(—ñ) == [ŠÖ”(—ñ(i)) | i in set inds —ñ];

--ŠÖ”‚É‚æ‚Á‚Ä—ñ‚ğàh‰ß‚·‚éB‚Â‚Ü‚èA—ñ‚Ì‚¤‚¿ŠÖ”‚ğ–‚½‚·‚à‚Ì‚Ì—ñ‚ğ•Ô‚·B
static public filter[@Œ^]: (@Œ^ -> bool) -> seq of @Œ^ -> seq of @Œ^
filter(ŠÖ”)(—ñ) == [—ñ(i) | i in set inds —ñ & ŠÖ”(—ñ(i))];

--—ñ‚É‘Î‚·‚é‚½‚½‚İ‚İ‰‰Zi¶‘¤‚©‚ç“K—p)
static public Foldl[@Œ^1, @Œ^2] : 
	(@Œ^1 -> @Œ^2 -> @Œ^1) -> @Œ^1 -> seq of @Œ^2 -> @Œ^1
Foldl(ŠÖ”)(ˆø”)(—ñ) == 
	cases —ñ :
	[]			-> ˆø”,
	[æ“ª] ^ Œã‘±—ñ	-> Foldl[@Œ^1,@Œ^2](ŠÖ”)(ŠÖ”(ˆø”)(æ“ª))(Œã‘±—ñ)
	end;

--—ñ‚É‘Î‚·‚é‚½‚½‚İ‚İ‰‰Zi‰E‘¤‚©‚ç“K—pj
static public Foldr[@Œ^1, @Œ^2] : 
	(@Œ^1 -> @Œ^2 -> @Œ^2) -> @Œ^2 -> seq of @Œ^1 -> @Œ^2
Foldr(ŠÖ”)(ˆø”)(—ñ) == 
	cases —ñ :
	[]			-> ˆø”,
	[æ“ª] ^ Œã‘±—ñ	-> ŠÖ”(æ“ª)(Foldr[@Œ^1,@Œ^2](ŠÖ”)(ˆø”)(Œã‘±—ñ))
	end;

--—v‘f‚ª‚ ‚é‚©”Û‚©‚ğ•Ô‚·B
static public isMember[@Œ^] : @Œ^ -> seq of @Œ^ -> bool
isMember(—v‘f)(—ñ) == 
	cases —ñ :
	[æ“ª]^Œã‘±		-> —v‘f = æ“ª or isMember[@Œ^] (—v‘f)(Œã‘±),
	[]			-> false
	end;

--—v‘f—ñ’†‚Ì—v‘f‚ªA—ñ‚É‚ ‚é‚©”Û‚©‚ğ•Ô‚·B
static public isAnyMember[@Œ^]:  seq of @Œ^ -> seq of @Œ^ -> bool
isAnyMember(—v‘f—ñ)(—ñ) == 
	cases —v‘f—ñ :
	[æ“ª]^Œã‘±		->  isMember[@Œ^] (æ“ª)(—ñ) or isAnyMember[@Œ^] (Œã‘±)(—ñ) ,
	[]			-> false
	end;

--w’è‚³‚ê‚½—v‘f‚ªA—ñ‚Ì‰½”Ô–Ú‚É‚ ‚é‚©‚ğ•Ô‚·BÅ‰‚Ì—v‘f‚ÌˆÊ’u‚ğ•Ô‚·B
static public Index[@Œ^]: @Œ^ -> seq of @Œ^ -> int
Index(—v‘f)(—ñ) == 
	let	i = 0
	in	Index•â•ŠÖ”[@Œ^](—v‘f)(—ñ)(i);

static Index•â•ŠÖ”[@Œ^]: @Œ^ -> seq of @Œ^ -> int -> int
Index•â•ŠÖ”(—v‘f)(—ñ)(õˆø) ==
	cases —ñ:
		[]			-> 0,
		[æ“ª]^Œã‘±	->
			if æ“ª = —v‘f then 
				õˆø + 1
			else
				Index•â•ŠÖ”[@Œ^](—v‘f)(Œã‘±)(õˆø+1)
	end;
	
--w’è‚³‚ê‚½—v‘f‚ªA—ñ‚Ì‰½”Ô–Ú‚É‚ ‚é‚©‚ğ‚ÂW‡‚ğ•Ô‚·B
static public IndexAll[@Œ^] : @Œ^ -> seq of @Œ^ -> set of int
IndexAll(—v‘f)(—ñ) == {i | i in set inds —ñ & —ñ(i) = —v‘f};
	
--—ñ‚Ì—v‘f‚ª—ñ‚Ìê‡A‚»‚Ì—v‘f‚ğ—v‘f‚Æ‚µ‚Ä‚Â—ñ‚ğ•Ô‚·B
static public flatten[@Œ^] : seq of seq of @Œ^ -> seq of @Œ^
flatten(—ñ) == conc —ñ;

--—ñ‚Ì—v‘f‚ªnil‚Ì‚à‚Ì‚ğíœ‚µ‚½—ñ‚ğ•Ô‚·
static public compact[@Œ^] : seq of [@Œ^] -> seq of @Œ^
compact(—ñ) == [—ñ(i) | i in set inds —ñ & —ñ(i) <> nil];

--—ñ‚Ì‹t‡‚Ì—ñ‚ğ“¾‚éBreverse‚ª—\–ñŒê‚Ì‚½‚ßAfreverse‚Æ‚¢‚¤ŠÖ”–¼‚É‚µ‚½B
static public freverse[@Œ^] : seq of @Œ^ -> seq of @Œ^
freverse(—ñ) == [—ñ(len —ñ + 1 -  i) | i in set inds —ñ];

--—ñ‚©‚ç‡—ñ‚ğ“¾‚é
static public Permutations[@Œ^]: seq of @Œ^ -> set of seq of @Œ^
Permutations(—ñ) == 
cases —ñ:
	[],[-] -> {—ñ},
	others -> dunion {{[—ñ(i)]^j | j in set Permutations[@Œ^](RestSeq[@Œ^](—ñ,i))} | i in set inds —ñ}
end;

--—ñ‚Ìi”Ô–Ú‚Ì—v‘f‚ğœ‚¢‚½c‚è‚Ì—ñ‚ğ•Ô‚·
static public RestSeq[@Œ^]: seq of @Œ^ * nat -> seq of @Œ^
RestSeq(—ñ,i) == [—ñ(j) | j in set (inds —ñ \ {i})];

--‘g‚Ì—ñ‚ğA—ñ‚Ì‘g‚É•ÏŠ·‚·‚é
static public Unzip[@Œ^1, @Œ^2] : seq of (@Œ^1 * @Œ^2) -> seq of @Œ^1 * seq of @Œ^2
Unzip(—ñ) ==
	cases —ñ :
	[]				-> mk_([], []),
	[mk_(x, y)] ^ Œã‘±—ñ	->
		let	mk_(xs, ys) = Unzip[@Œ^1, @Œ^2](Œã‘±—ñ)
		in
		mk_([x] ^ xs, [y] ^ ys)
	end;

--—ñ‚Ì‘g‚ğA‘g‚Ì—ñ‚É•ÏŠ·‚·‚é
static public Zip[@Œ^1, @Œ^2] : seq of @Œ^1 * seq of @Œ^2 -> seq of (@Œ^1 * @Œ^2)
Zip(—ñ1, —ñ2) == Zip2[@Œ^1, @Œ^2](—ñ1)(—ñ2);
\end{vdm_al}

—ñ‚Ì‘g‚ğA‘g‚Ì—ñ‚É•ÏŠ·‚·‚éi‚æ‚èŠÖ”Œ^ƒvƒƒOƒ‰ƒ~ƒ“ƒO‚É“K‚µ‚½Œ`®j
\begin{vdm_al}	
static public Zip2[@Œ^1, @Œ^2] : seq of @Œ^1 -> seq of @Œ^2 -> seq of (@Œ^1 * @Œ^2)
Zip2(—ñ1)(—ñ2) == 
	cases mk_(—ñ1, —ñ2) :
	mk_([æ“ª1] ^ Œã‘±—ñ1, [æ“ª2] ^ Œã‘±—ñ2)		-> [mk_(æ“ª1, æ“ª2)] ^ Zip2[@Œ^1, @Œ^2](Œã‘±—ñ1)(Œã‘±—ñ2),
	mk_(-, -)							-> []
	end;

end Sequence
\end{vdm_al}

\begin{rtinfo}
[Sequence]{vdm.tc}[Sequence]
\end{rtinfo}
