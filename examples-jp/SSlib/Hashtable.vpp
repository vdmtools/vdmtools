/*$Id: Hashtable.vpp,v 1.1 2005/10/31 02:15:42 vdmtools Exp $
 *@Ó”CF
 *	ƒnƒbƒVƒ…•\ 
 
 *@g—p•û–@F
 *	i‚PjObject‚Ì•K—vğŒ
 *		Hashtable‚ÉŠi”[‚·‚é’l‚Å‚ ‚éObject‚ÍAhashCode()ŠÖ”‚Æequals()ŠÖ”‚ğ‚½‚Ë‚Î‚È‚ç‚È‚¢B
 *		‚Q‚Â‚ÌƒIƒuƒWƒFƒNƒgt1, t2‚ÌhashCode‚ª“™‚µ‚¯‚ê‚ÎAt1.equals(t2)‚Æ‚È‚ç‚È‚¯‚ê‚Î‚È‚ç‚È‚¢B
     ’ˆÓ–€
	—ğj“IŒo‰ß‚Ì‚½‚ßA‚æ‚èŠÖ”Œ^ƒvƒƒOƒ‰ƒ~ƒ“ƒO‚É“K‚µ‚½ŠÖ”‚ÆA‚»‚¤‚Å‚È‚¢‚à‚Ì‚ª‚ ‚éB
	ŠÖ”Œ^ƒvƒƒOƒ‰ƒ~ƒ“ƒO‚É“K‚µ‚½ŠÖ”‚ÍA‰pš–¼‚Ìê‡‘å•¶š‚Ån‚Ü‚éB
	‘å•¶š‚Ån‚Ü‚é“¯ˆê–¼‚ÌŠÖ”‚ª‚ ‚éê‡A¬•¶š‚Ån‚Ü‚éŠÖ”E‘€ì‚ÍAŒÃ‚¢’è‹`‚ÅAŒİŠ·«‚Ì‚½‚ß‚É‘¶İ‚·‚éB
	‘å•¶š‚Ån‚Ü‚é“¯ˆê–¼‚ÌŠÖ”‚ª–³‚¢ê‡‚ÍA¬•¶š‚Ån‚Ü‚éŠÖ”E‘€ì‚àŠÖ”Œ^ƒvƒƒOƒ‰ƒ~ƒ“ƒO‚É“K‚µ‚Ä‚¢‚éB
	
 *@§–ñF
 *	ƒX[ƒp[ƒNƒ‰ƒXw–â‘è—Ìˆæ‹¤’Ê’è‹`x‚Å‡•¹Œ^‚ğg—p‚µ‚Ä‚¢‚é‚ÆA
 *	Rose Link‚Ì‹@”\§–ñ‚Ì‚½‚ßRose‚ÌƒNƒ‰ƒX}‚ğ¶¬‚Å‚«‚È‚¢B
 *
 *	
*/
class Hashtable is subclass of w‹¤’Ê’è‹`x 

types
public u’†gv = map Object to Object;
public uƒoƒPƒcv = map int to u’†gv;

instance variables
ƒoƒPƒc : uƒoƒPƒcv := { |->};

operations
--\¬q
--‹ó‚ÌHashtableƒCƒ“ƒXƒ^ƒ“ƒX‚ğ•Ô‚·B
public Hashtable : () ==> Hashtable
Hashtable() == 
	(
	ƒoƒPƒc := { |-> };
	return self
	);
	
--Ê‘œ‚©‚çHashtableƒCƒ“ƒXƒ^ƒ“ƒX‚ğ•Ô‚·B
public Hashtable : u’†gv ==> Hashtable
Hashtable(a’†g) == 
	(
	self.putAll(a’†g);
	return self
	);

--Hashtable‚ÌƒNƒŠƒA[
public clear : () ==> ()
clear() == setBuckets({ |-> });

public getBuckets : () ==> uƒoƒPƒcv 
getBuckets() == return ƒoƒPƒc;

public setBuckets : uƒoƒPƒcv ==> ()
setBuckets(aBucket) == ƒoƒPƒc := aBucket;

--Hahtable‚Ì‚·‚×‚Ä‚Ìkey‚ÌW‡‚ğ•Ô‚·
public keySet : () ==> set of Object
keySet() ==
	let	buckets = self.getBuckets()
	in
	(
	dcl allKeySet : set of Object := {};
	for all a’†g in set rng buckets do
		allKeySet := allKeySet union dom a’†g;
	return allKeySet
	);

--key‚Æ’l‚ÌÊ‚ğHashtable‚É’Ç‰Á‚·‚é
public put : Object * Object ==> ()
put(key, ’l) ==
	let	buckets = self.getBuckets(),
		hashcode = key.hashCode()
	in
	(
	if hashcode in set dom buckets then
		self.setBuckets(buckets ++ {hashcode |-> (buckets(hashcode) munion {key |-> ’l})})
	else
		self.setBuckets(buckets munion {hashcode |-> {key |-> ’l}})
	);

--Ê‘œ‚Ì“à—e‚ğHashtable‚É’Ç‰Á‚·‚é
public putAll : u’†gv ==> ()
putAll(a’†g) == 
	for all key in set dom a’†g do (
		self.put(key, a’†g(key))
	);

--key‚É‘Î‰‚·‚é’l‚ğæ‚èo‚·
public get : Object  ==> [Object]
get(key) ==
	let	buckets = self.getBuckets(),
		hashcode = key.hashCode()
	in
	(
	if hashcode in set dom buckets then
		let	a’†g = buckets(hashcode)
		in
		for all aKey in set dom a’†g do (
			if key.equals(aKey) then
				return a’†g(aKey)
		);
	return nil
	);

--key‚Æ‚»‚ê‚É‘Î‰‚·‚é’l‚ğHashtable‚©‚çíœ‚·‚é
public remove : Object ==> [Object]
remove(key) ==
	let	buckets = self.getBuckets(),
		hashcode = key.hashCode(),
		íœ‘ÎÛ = self.get(key)
	in
	(
	if íœ‘ÎÛ <> nil then
		let	a’†g = buckets(hashcode),
			new’†g = a’†g :-> {íœ‘ÎÛ}
		in
		(
		self.setBuckets(buckets ++ {hashcode |-> new’†g});
		return íœ‘ÎÛ
		)
	else
		return nil
	);

--Hashtable‚Ì‚·‚×‚Ä‚Ì’l‚ÌW‡‚ğ•Ô‚·
public valueSet : () ==> set of Object
valueSet() ==
	let	buckets = self.getBuckets()
	in
	(
	dcl ’lW‡ : set of Object := {};
	for all a’†g in set rng buckets do
		’lW‡ := ’lW‡ union rng a’†g;
	return ’lW‡
	);

functions

--Hashtable’†‚Ìkey‚Ì”‚ğ•Ô‚·
public size : () -> nat
size() == card self.keySet();

--Hashtable’†‚Ékey‚ª–³‚¢‚©”Û‚©‚ğ•Ô‚·
public isEmpty : () -> bool
isEmpty() == self.keySet() = {};
		
--—^‚¦‚ç‚ê‚½Object‚ª‚ ‚é‚È‚ç‚ÎAtrue‚ğ•Ô‚·B
public contains : Object -> bool
contains(anObject) ==
	let	buckets = self.getBuckets()
	in
	exists hashcode in set dom buckets &
		let	a’†g = buckets(hashcode)
		in
		exists key in set dom a’†g &
			 a’†g(key).equals(anObject);
		
--—^‚¦‚ç‚ê‚½key‚ª‚ ‚é‚È‚ç‚ÎA‚”‚’‚•‚…‚ğ•Ô‚·B
public containsKey : Object -> bool
containsKey(aKey) ==
	let	buckets = self.getBuckets()
	in
	exists hashcode in set dom buckets & 
		exists key in set dom buckets(hashcode) &
			aKey.equals(key);

-----------ŠÖ”Œ^ƒvƒƒOƒ‰ƒ~ƒ“ƒO‚É‚æ‚éÀ‘•
functions
--aKey‚ÆaValue‚ÌÊ‚ğHashtable‚É’Ç‰Á‚·‚é
static public Put[@Œ^1, @Œ^2] : 
	(map int to (map @Œ^1 to  @Œ^2)) -> (@Œ^1 -> @Œ^1) -> @Œ^1 -> @Œ^2 
	-> (map int to (map @Œ^1 to  @Œ^2))
Put(aHashtable)(aHashCode)(aKey)(aValue) ==
	let	hashcode = aHashCode(aKey)
	in
	if hashcode in set dom aHashtable then
		aHashtable ++ {hashcode |-> (aHashtable(hashcode) ++ {aKey |-> aValue})}
	else
		aHashtable munion {hashcode |-> {aKey |-> aValue}}
	;

--Ê‘œ‚Ì“à—e‚ğHashtable‚É’Ç‰Á‚·‚é
static public PutAll[@Œ^1, @Œ^2] : 
	(map int to (map @Œ^1 to  @Œ^2)) -> (@Œ^1 -> @Œ^1) -> (map @Œ^1 to  @Œ^2) 
	-> (map int to (map @Œ^1 to  @Œ^2)) 
PutAll(aHashtable)(aHashCode)(aMap) == 
	PutAll•â•ŠÖ”[@Œ^1, @Œ^2](aHashtable)(aHashCode)(aMap)(dom aMap);

static public PutAll•â•ŠÖ”[@Œ^1, @Œ^2] :
	(map int to (map @Œ^1 to  @Œ^2)) -> (@Œ^1 -> int) -> (map @Œ^1 to  @Œ^2)  -> set of @Œ^1
	-> (map int to (map @Œ^1 to  @Œ^2)) 
PutAll•â•ŠÖ”(aHashtable)(aHashCode)(aMap)(aKeySet) ==
	if aKeySet = {} then
		aHashtable
	else
		let	aKey in set aKeySet	in
		let	VHashtable = Put[@Œ^1, @Œ^2](aHashtable)(aHashCode)(aKey)(aMap(aKey))	
		in
		PutAll•â•ŠÖ”[@Œ^1, @Œ^2](VHashtable)(aHashCode)(aMap)(aKeySet \ {aKey})
	;

--aKey‚É‘Î‰‚·‚é’l‚ğæ‚èo‚·
static public Get[@Œ^1, @Œ^2] : (map int to (map @Œ^1 to  @Œ^2)) -> (@Œ^1 -> @Œ^1) -> @Œ^1  -> [@Œ^2]
Get(aHashtable)(aHashCode)(aKey) ==
	let	hashcode = aHashCode(aKey)
	in
	if hashcode in set dom aHashtable then
		Map`Get[@Œ^1, @Œ^2](aHashtable(hashcode))(aKey)
	else
		nil
	;

--key‚Æ‚»‚ê‚É‘Î‰‚·‚é’l‚ğHashtable‚©‚çíœ‚·‚é
static public Remove[@Œ^1, @Œ^2] : (map int to (map @Œ^1 to  @Œ^2)) -> (@Œ^1 -> @Œ^1) -> @Œ^1 -> (map int to (map @Œ^1 to  @Œ^2))
Remove(aHashtable)(aHashCode)(aKey) == 
	let	hashcode = aHashCode(aKey)
	in
	{h |-> ({aKey} <-: aHashtable(hashcode)) | h in set {hashcode}} munion 
		{hashcode} <-: aHashtable ;

--Hashtable‚ÌƒNƒŠƒA[
static public Clear[@Œ^1, @Œ^2] : () -> (map int to (map @Œ^1 to  @Œ^2))
Clear() == ({ |-> });

--Hahtable‚Ì‚·‚×‚Ä‚Ìkey‚ÌW‡‚ğ•Ô‚·
static public KeySet[@Œ^1, @Œ^2] : (map int to (map @Œ^1 to  @Œ^2)) -> set of  @Œ^1
KeySet(aHashtable) == 
	let	aMapSet = rng aHashtable,
		“K—pŠÖ” = lambda x : map @Œ^1 to  @Œ^2 & dom x
	in
	if aMapSet <> {} then
		dunion Set`fmap[@Œ^1, @Œ^2](“K—pŠÖ”)(aMapSet)
	else
		{};

--Hashtable‚Ì‚·‚×‚Ä‚Ì’l‚ÌW‡‚ğ•Ô‚·
static public ValueSet[@Œ^1, @Œ^2] : (map int to (map @Œ^1 to  @Œ^2)) -> set of  @Œ^2
ValueSet(aHashtable) == 
	let	aMapSet = rng aHashtable,
		“K—pŠÖ” = lambda x : map @Œ^1 to  @Œ^2 & rng x
	in
	if aMapSet <> {} then
		dunion Set`fmap[@Œ^1, @Œ^2](“K—pŠÖ”)(aMapSet)
	else
		{};
	
--Hashtable’†‚Ìkey‚Ì”‚ğ•Ô‚·
static public Size[@Œ^1, @Œ^2] : (map int to (map @Œ^1 to  @Œ^2)) -> nat
Size(aHashtable) == card KeySet[@Œ^1, @Œ^2](aHashtable) ;

--Hashtable’†‚Ékey‚ª–³‚¢‚©”Û‚©‚ğ•Ô‚·
static public IsEmpty[@Œ^1, @Œ^2] : (map int to (map @Œ^1 to  @Œ^2)) -> bool
IsEmpty(aHashtable) == KeySet[@Œ^1, @Œ^2](aHashtable) = {};
		
--—^‚¦‚ç‚ê‚½aValue‚ª‚ ‚é‚È‚ç‚ÎAtrue‚ğ•Ô‚·B
static public Contains[@Œ^1, @Œ^2] : (map int to (map @Œ^1 to  @Œ^2)) -> @Œ^2 -> bool
Contains(aHashtable)(aValue) == 
	let	aMapSet = rng aHashtable	
	in
	if aMapSet <> {} then
		exists aMap in set aMapSet & aValue in set rng aMap
	else
		false;
		
--—^‚¦‚ç‚ê‚½key‚ª‚ ‚é‚È‚ç‚ÎA‚”‚’‚•‚…‚ğ•Ô‚·B
static public ContainsKey[@Œ^1, @Œ^2] : (map int to (map @Œ^1 to  @Œ^2)) -> @Œ^1 -> bool
ContainsKey(aHashtable)(aKey) == 
	let	aMapSet = rng aHashtable	
	in
	if aMapSet <> {} then
		exists aMap in set aMapSet & aKey in set dom aMap
	else
		false;

end Hashtable